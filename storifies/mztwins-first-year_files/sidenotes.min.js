(function (root, factory) {
    if ((typeof Livefyre === 'object') && (typeof Livefyre.define === 'function') && Livefyre.define.amd) {
        // Livefyre.define is defined by https://github.com/Livefyre/require
        Livefyre.define([], factory);

    } else if (typeof define === 'function' && define.amd) {
        //Allow using this built library as an AMD module
        //in another project. That other project will only
        //see this AMD call, not the internal modules in
        //the closure below.
        define([], factory);

    } else {
        //Browser globals case. Just assign the
        //result to a property on the global.
        root.Livefyre = root.Livefyre || {};
        root.Livefyre.Sidenotes = factory();
    }
}(this, function () {
    //almond, and your modules will be inlined here

/**
 * almond 0.2.7 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

define('jquery',[], function(require, exports, module) {/*! jQuery v1.10.1 | (c) 2005, 2013 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery-1.10.1.min.map
*/
(function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f="1.10.1",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=/\S+/g,C=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,k=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,E=/^[\],:{}\s]*$/,S=/(?:^|:|,)(?:\s*\[)+/g,A=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,j=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,D=/^-ms-/,L=/-([\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||"load"===e.type||"complete"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener("DOMContentLoaded",q,!1),e.removeEventListener("load",q,!1)):(a.detachEvent("onreadystatechange",q),e.detachEvent("onload",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},l=2),"object"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray||function(e){return"array"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?c[y.call(e)]||"object":typeof e},isPlainObject:function(e){var n;if(!e||"object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,"constructor")&&!v.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,"@").replace(j,"]").replace(S,"")))?Function("return "+n)():(x.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||x.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,"ms-").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call("\ufeff\u00a0")?function(e){return null==e?"":b.call(e)}:function(e){return null==e?"":(e+"").replace(C,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if("object"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),"complete"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener("DOMContentLoaded",q,!1),e.addEventListener("load",q,!1);else{a.attachEvent("onreadystatechange",q),e.attachEvent("onload",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll("left")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){c["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b="sizzle"+-new Date,w=e.document,T=0,C=0,N=lt(),k=lt(),E=lt(),S=!1,A=function(){return 0},j=typeof t,D=1<<31,L={}.hasOwnProperty,H=[],q=H.pop,_=H.push,M=H.push,O=H.slice,F=H.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},B="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",P="[\\x20\\t\\r\\n\\f]",R="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",W=R.replace("w","w#"),$="\\["+P+"*("+R+")"+P+"*(?:([*^$|!~]?=)"+P+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+W+")|)|)"+P+"*\\]",I=":("+R+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+$.replace(3,8)+")*)|.*)\\)|)",z=RegExp("^"+P+"+|((?:^|[^\\\\])(?:\\\\.)*)"+P+"+$","g"),X=RegExp("^"+P+"*,"+P+"*"),U=RegExp("^"+P+"*([>+~]|"+P+")"+P+"*"),V=RegExp(P+"*[+~]"),Y=RegExp("="+P+"*([^\\]'\"]*)"+P+"*\\]","g"),J=RegExp(I),G=RegExp("^"+W+"$"),Q={ID:RegExp("^#("+R+")"),CLASS:RegExp("^\\.("+R+")"),TAG:RegExp("^("+R.replace("w","w*")+")"),ATTR:RegExp("^"+$),PSEUDO:RegExp("^"+I),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+P+"*(even|odd|(([+-]|)(\\d*)n|)"+P+"*(?:([+-]|)"+P+"*(\\d+)|))"+P+"*\\)|)","i"),bool:RegExp("^(?:"+B+")$","i"),needsContext:RegExp("^"+P+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+P+"*((?:-\\d)?\\d*)"+P+"*\\)|)(?=[^-]|$)","i")},K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,et=/^(?:input|select|textarea|button)$/i,tt=/^h\d$/i,nt=/'|\\/g,rt=RegExp("\\\\([\\da-f]{1,6}"+P+"?|("+P+")|.)","ig"),it=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{M.apply(H=O.call(w.childNodes),w.childNodes),H[w.childNodes.length].nodeType}catch(ot){M={apply:H.length?function(e,t){_.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function at(e,t,n,i){var o,a,s,l,u,c,d,m,y,x;if((t?t.ownerDocument||t:w)!==f&&p(t),t=t||f,n=n||[],!e||"string"!=typeof e)return n;if(1!==(l=t.nodeType)&&9!==l)return[];if(h&&!i){if(o=Z.exec(e))if(s=o[1]){if(9===l){if(a=t.getElementById(s),!a||!a.parentNode)return n;if(a.id===s)return n.push(a),n}else if(t.ownerDocument&&(a=t.ownerDocument.getElementById(s))&&v(t,a)&&a.id===s)return n.push(a),n}else{if(o[2])return M.apply(n,t.getElementsByTagName(e)),n;if((s=o[3])&&r.getElementsByClassName&&t.getElementsByClassName)return M.apply(n,t.getElementsByClassName(s)),n}if(r.qsa&&(!g||!g.test(e))){if(m=d=b,y=t,x=9===l&&e,1===l&&"object"!==t.nodeName.toLowerCase()){c=bt(e),(d=t.getAttribute("id"))?m=d.replace(nt,"\\$&"):t.setAttribute("id",m),m="[id='"+m+"'] ",u=c.length;while(u--)c[u]=m+xt(c[u]);y=V.test(e)&&t.parentNode||t,x=c.join(",")}if(x)try{return M.apply(n,y.querySelectorAll(x)),n}catch(T){}finally{d||t.removeAttribute("id")}}}return At(e.replace(z,"$1"),t,n,i)}function st(e){return K.test(e+"")}function lt(){var e=[];function t(n,r){return e.push(n+=" ")>o.cacheLength&&delete t[e.shift()],t[n]=r}return t}function ut(e){return e[b]=!0,e}function ct(e){var t=f.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function pt(e,t,n){e=e.split("|");var r,i=e.length,a=n?null:t;while(i--)(r=o.attrHandle[e[i]])&&r!==t||(o.attrHandle[e[i]]=a)}function ft(e,t){var n=e.getAttributeNode(t);return n&&n.specified?n.value:e[t]===!0?t.toLowerCase():null}function dt(e,t){return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}function ht(e){return"input"===e.nodeName.toLowerCase()?e.defaultValue:t}function gt(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function mt(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function yt(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function vt(e){return ut(function(t){return t=+t,ut(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}s=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},r=at.support={},p=at.setDocument=function(e){var n=e?e.ownerDocument||e:w,i=n.parentWindow;return n!==f&&9===n.nodeType&&n.documentElement?(f=n,d=n.documentElement,h=!s(n),i&&i.frameElement&&i.attachEvent("onbeforeunload",function(){p()}),r.attributes=ct(function(e){return e.innerHTML="<a href='#'></a>",pt("type|href|height|width",dt,"#"===e.firstChild.getAttribute("href")),pt(B,ft,null==e.getAttribute("disabled")),e.className="i",!e.getAttribute("className")}),r.input=ct(function(e){return e.innerHTML="<input>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")}),pt("value",ht,r.attributes&&r.input),r.getElementsByTagName=ct(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),r.getElementsByClassName=ct(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),r.getById=ct(function(e){return d.appendChild(e).id=b,!n.getElementsByName||!n.getElementsByName(b).length}),r.getById?(o.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){return e.getAttribute("id")===t}}):(delete o.find.ID,o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),o.find.TAG=r.getElementsByTagName?function(e,n){return typeof n.getElementsByTagName!==j?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},o.find.CLASS=r.getElementsByClassName&&function(e,n){return typeof n.getElementsByClassName!==j&&h?n.getElementsByClassName(e):t},m=[],g=[],(r.qsa=st(n.querySelectorAll))&&(ct(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||g.push("\\["+P+"*(?:value|"+B+")"),e.querySelectorAll(":checked").length||g.push(":checked")}),ct(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&g.push("[*^$]="+P+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||g.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),g.push(",.*:")})),(r.matchesSelector=st(y=d.webkitMatchesSelector||d.mozMatchesSelector||d.oMatchesSelector||d.msMatchesSelector))&&ct(function(e){r.disconnectedMatch=y.call(e,"div"),y.call(e,"[s!='']:x"),m.push("!=",I)}),g=g.length&&RegExp(g.join("|")),m=m.length&&RegExp(m.join("|")),v=st(d.contains)||d.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},r.sortDetached=ct(function(e){return 1&e.compareDocumentPosition(n.createElement("div"))}),A=d.compareDocumentPosition?function(e,t){if(e===t)return S=!0,0;var i=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);return i?1&i||!r.sortDetached&&t.compareDocumentPosition(e)===i?e===n||v(w,e)?-1:t===n||v(w,t)?1:c?F.call(c,e)-F.call(c,t):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return S=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:c?F.call(c,e)-F.call(c,t):0;if(o===a)return gt(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?gt(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},n):f},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){if((e.ownerDocument||e)!==f&&p(e),t=t.replace(Y,"='$1']"),!(!r.matchesSelector||!h||m&&m.test(t)||g&&g.test(t)))try{var n=y.call(e,t);if(n||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(i){}return at(t,f,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==f&&p(e),v(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==f&&p(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!h):t;return a===t?r.attributes||!h?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null:a},at.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},at.uniqueSort=function(e){var t,n=[],i=0,o=0;if(S=!r.detectDuplicates,c=!r.sortStable&&e.slice(0),e.sort(A),S){while(t=e[o++])t===e[o]&&(i=n.push(o));while(i--)e.splice(n[i],1)}return e},a=at.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=a(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=a(t);return n},o=at.selectors={cacheLength:50,createPseudo:ut,match:Q,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(rt,it),e[3]=(e[4]||e[5]||"").replace(rt,it),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var n,r=!e[5]&&e[2];return Q.CHILD.test(e[0])?null:(e[3]&&e[4]!==t?e[2]=e[4]:r&&J.test(r)&&(n=bt(r,!0))&&(n=r.indexOf(")",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(rt,it).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=N[e+" "];return t||(t=RegExp("(^|"+P+")"+e+"("+P+"|$)"))&&N(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,l){var u,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!l&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[b]||(m[b]={}),u=c[e]||[],d=u[0]===T&&u[1],f=u[0]===T&&u[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[T,d,f];break}}else if(v&&(u=(t[b]||(t[b]={}))[e])&&u[0]===T)f=u[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[b]||(p[b]={}))[e]=[T,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||at.error("unsupported pseudo: "+e);return r[b]?r(t):r.length>1?(n=[e,e,"",t],o.setFilters.hasOwnProperty(e.toLowerCase())?ut(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=F.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:ut(function(e){var t=[],n=[],r=l(e.replace(z,"$1"));return r[b]?ut(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:ut(function(e){return function(t){return at(e,t).length>0}}),contains:ut(function(e){return function(t){return(t.textContent||t.innerText||a(t)).indexOf(e)>-1}}),lang:ut(function(e){return G.test(e||"")||at.error("unsupported lang: "+e),e=e.replace(rt,it).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===d},focus:function(e){return e===f.activeElement&&(!f.hasFocus||f.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return tt.test(e.nodeName)},input:function(e){return et.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:vt(function(){return[0]}),last:vt(function(e,t){return[t-1]}),eq:vt(function(e,t,n){return[0>n?n+t:n]}),even:vt(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:vt(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:vt(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:vt(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}};for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=mt(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=yt(n);function bt(e,t){var n,r,i,a,s,l,u,c=k[e+" "];if(c)return t?0:c.slice(0);s=e,l=[],u=o.preFilter;while(s){(!n||(r=X.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),l.push(i=[])),n=!1,(r=U.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(z," ")}),s=s.slice(n.length));for(a in o.filter)!(r=Q[a].exec(s))||u[a]&&!(r=u[a](r))||(n=r.shift(),i.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?at.error(e):k(e,l).slice(0)}function xt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function wt(e,t,n){var r=t.dir,o=n&&"parentNode"===r,a=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||o)return e(t,n,i)}:function(t,n,s){var l,u,c,p=T+" "+a;if(s){while(t=t[r])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[r])if(1===t.nodeType||o)if(c=t[b]||(t[b]={}),(u=c[r])&&u[0]===p){if((l=u[1])===!0||l===i)return l===!0}else if(u=c[r]=[p],u[1]=e(t,n,s)||i,u[1]===!0)return!0}}function Tt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function Ct(e,t,n,r,i){var o,a=[],s=0,l=e.length,u=null!=t;for(;l>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),u&&t.push(s));return a}function Nt(e,t,n,r,i,o){return r&&!r[b]&&(r=Nt(r)),i&&!i[b]&&(i=Nt(i,o)),ut(function(o,a,s,l){var u,c,p,f=[],d=[],h=a.length,g=o||St(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:Ct(g,f,e,s,l),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,l),r){u=Ct(y,d),r(u,[],s,l),c=u.length;while(c--)(p=u[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){u=[],c=y.length;while(c--)(p=y[c])&&u.push(m[c]=p);i(null,y=[],u,l)}c=y.length;while(c--)(p=y[c])&&(u=i?F.call(o,p):f[c])>-1&&(o[u]=!(a[u]=p))}}else y=Ct(y===a?y.splice(h,y.length):y),i?i(null,a,y,l):M.apply(a,y)})}function kt(e){var t,n,r,i=e.length,a=o.relative[e[0].type],s=a||o.relative[" "],l=a?1:0,c=wt(function(e){return e===t},s,!0),p=wt(function(e){return F.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;i>l;l++)if(n=o.relative[e[l].type])f=[wt(Tt(f),n)];else{if(n=o.filter[e[l].type].apply(null,e[l].matches),n[b]){for(r=++l;i>r;r++)if(o.relative[e[r].type])break;return Nt(l>1&&Tt(f),l>1&&xt(e.slice(0,l-1).concat({value:" "===e[l-2].type?"*":""})).replace(z,"$1"),n,r>l&&kt(e.slice(l,r)),i>r&&kt(e=e.slice(r)),i>r&&xt(e))}f.push(n)}return Tt(f)}function Et(e,t){var n=0,r=t.length>0,a=e.length>0,s=function(s,l,c,p,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,C=u,N=s||a&&o.find.TAG("*",d&&l.parentNode||l),k=T+=null==C?1:Math.random()||.1;for(w&&(u=l!==f&&l,i=n);null!=(h=N[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,l,c)){p.push(h);break}w&&(T=k,i=++n)}r&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,r&&b!==v){g=0;while(m=t[g++])m(x,y,l,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=q.call(p));y=Ct(y)}M.apply(p,y),w&&!s&&y.length>0&&v+t.length>1&&at.uniqueSort(p)}return w&&(T=k,u=C),x};return r?ut(s):s}l=at.compile=function(e,t){var n,r=[],i=[],o=E[e+" "];if(!o){t||(t=bt(e)),n=t.length;while(n--)o=kt(t[n]),o[b]?r.push(o):i.push(o);o=E(e,Et(i,r))}return o};function St(e,t,n){var r=0,i=t.length;for(;i>r;r++)at(e,t[r],n);return n}function At(e,t,n,i){var a,s,u,c,p,f=bt(e);if(!i&&1===f.length){if(s=f[0]=f[0].slice(0),s.length>2&&"ID"===(u=s[0]).type&&r.getById&&9===t.nodeType&&h&&o.relative[s[1].type]){if(t=(o.find.ID(u.matches[0].replace(rt,it),t)||[])[0],!t)return n;e=e.slice(s.shift().value.length)}a=Q.needsContext.test(e)?0:s.length;while(a--){if(u=s[a],o.relative[c=u.type])break;if((p=o.find[c])&&(i=p(u.matches[0].replace(rt,it),V.test(s[0].type)&&t.parentNode||t))){if(s.splice(a,1),e=i.length&&xt(s),!e)return M.apply(n,i),n;break}}}return l(e,f)(i,t,!h,n,V.test(e)),n}o.pseudos.nth=o.pseudos.eq;function jt(){}jt.prototype=o.filters=o.pseudos,o.setFilters=new jt,r.sortStable=b.split("").sort(A).join("")===b,p(),[0,0].sort(A),r.detectDuplicates=S,x.find=at,x.expr=at.selectors,x.expr[":"]=x.expr.pseudos,x.unique=at.uniqueSort,x.text=at.getText,x.isXMLDoc=at.isXML,x.contains=at.contains}(e);var O={};function F(e){var t=O[e]={};return x.each(e.match(T)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?O[e]||F(e):x.extend({},e);var n,r,i,o,a,s,l=[],u=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=l.length,n=!0;l&&o>a;a++)if(l[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,l&&(u?u.length&&c(u.shift()):r?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function i(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&p.has(n)||l.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=l.length:r&&(s=t,c(r))}return this},remove:function(){return l&&x.each(arguments,function(e,t){var r;while((r=x.inArray(t,l,r))>-1)l.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?x.inArray(e,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=u=r=t,this},disabled:function(){return!l},lock:function(){return u=t,r||p.disable(),this},locked:function(){return!u},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],!l||i&&!u||(n?u.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var a=o[0],s=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=g.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?g.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,l,u;if(r>1)for(s=Array(r),l=Array(r),u=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(a(t,u,n)).fail(o.reject).progress(a(t,l,s)):--i;return i||o.resolveWith(u,n),o.promise()}}),x.support=function(t){var n,r,o,s,l,u,c,p,f,d=a.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*")||[],r=d.getElementsByTagName("a")[0],!r||!r.style||!n.length)return t;s=a.createElement("select"),u=s.appendChild(a.createElement("option")),o=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t.getSetAttribute="t"!==d.className,t.leadingWhitespace=3===d.firstChild.nodeType,t.tbody=!d.getElementsByTagName("tbody").length,t.htmlSerialize=!!d.getElementsByTagName("link").length,t.style=/top/.test(r.getAttribute("style")),t.hrefNormalized="/a"===r.getAttribute("href"),t.opacity=/^0.5/.test(r.style.opacity),t.cssFloat=!!r.style.cssFloat,t.checkOn=!!o.value,t.optSelected=u.selected,t.enctype=!!a.createElement("form").enctype,t.html5Clone="<:nav></:nav>"!==a.createElement("nav").cloneNode(!0).outerHTML,t.inlineBlockNeedsLayout=!1,t.shrinkWrapBlocks=!1,t.pixelPosition=!1,t.deleteExpando=!0,t.noCloneEvent=!0,t.reliableMarginRight=!0,t.boxSizingReliable=!0,o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!u.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}o=a.createElement("input"),o.setAttribute("value",""),t.input=""===o.getAttribute("value"),o.value="t",o.setAttribute("type","radio"),t.radioValue="t"===o.value,o.setAttribute("checked","t"),o.setAttribute("name","t"),l=a.createDocumentFragment(),l.appendChild(o),t.appendChecked=o.checked,t.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip;for(f in x(t))break;return t.ownLast="0"!==f,x(function(){var n,r,o,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",l=a.getElementsByTagName("body")[0];l&&(n=a.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",l.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",o=d.getElementsByTagName("td"),o[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===o[0].offsetHeight,o[0].style.display="",o[1].style.display="none",t.reliableHiddenOffsets=p&&0===o[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",x.swap(l,null!=l.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===d.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(a.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(l.style.zoom=1)),l.removeChild(n),n=d=o=r=null)
}),n=s=l=u=r=o=null,t}({});var B=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;function R(e,n,r,i){if(x.acceptData(e)){var o,a,s=x.expando,l=e.nodeType,u=l?x.cache:e,c=l?e[s]:e[s]&&s;if(c&&u[c]&&(i||u[c].data)||r!==t||"string"!=typeof n)return c||(c=l?e[s]=p.pop()||x.guid++:s),u[c]||(u[c]=l?{}:{toJSON:x.noop}),("object"==typeof n||"function"==typeof n)&&(i?u[c]=x.extend(u[c],n):u[c].data=x.extend(u[c].data,n)),a=u[c],i||(a.data||(a.data={}),a=a.data),r!==t&&(a[x.camelCase(n)]=r),"string"==typeof n?(o=a[n],null==o&&(o=a[x.camelCase(n)])):o=a,o}}function W(e,t,n){if(x.acceptData(e)){var r,i,o=e.nodeType,a=o?x.cache:e,s=o?e[x.expando]:x.expando;if(a[s]){if(t&&(r=n?a[s]:a[s].data)){x.isArray(t)?t=t.concat(x.map(t,x.camelCase)):t in r?t=[t]:(t=x.camelCase(t),t=t in r?[t]:t.split(" ")),i=t.length;while(i--)delete r[t[i]];if(n?!I(r):!x.isEmptyObject(r))return}(n||(delete a[s].data,I(a[s])))&&(o?x.cleanData([e],!0):x.support.deleteExpando||a!=a.window?delete a[s]:a[s]=null)}}}x.extend({cache:{},noData:{applet:!0,embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(e){return e=e.nodeType?x.cache[e[x.expando]]:e[x.expando],!!e&&!I(e)},data:function(e,t,n){return R(e,t,n)},removeData:function(e,t){return W(e,t)},_data:function(e,t,n){return R(e,t,n,!0)},_removeData:function(e,t){return W(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&x.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),x.fn.extend({data:function(e,n){var r,i,o=null,a=0,s=this[0];if(e===t){if(this.length&&(o=x.data(s),1===s.nodeType&&!x._data(s,"parsedAttrs"))){for(r=s.attributes;r.length>a;a++)i=r[a].name,0===i.indexOf("data-")&&(i=x.camelCase(i.slice(5)),$(s,i,o[i]));x._data(s,"parsedAttrs",!0)}return o}return"object"==typeof e?this.each(function(){x.data(this,e)}):arguments.length>1?this.each(function(){x.data(this,e,n)}):s?$(s,e,x.data(s,e)):null},removeData:function(e){return this.each(function(){x.removeData(this,e)})}});function $(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(P,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:B.test(r)?x.parseJSON(r):r}catch(o){}x.data(e,n,r)}else r=t}return r}function I(e){var t;for(t in e)if(("data"!==t||!x.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}x.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=x._data(e,n),r&&(!i||x.isArray(r)?i=x._data(e,n,x.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),a=function(){x.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return x._data(e,n)||x._data(e,n,{empty:x.Callbacks("once memory").add(function(){x._removeData(e,t+"queue"),x._removeData(e,n)})})}}),x.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?x.queue(this[0],e):n===t?this:this.each(function(){var t=x.queue(this,e,n);x._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=x.Deferred(),a=this,s=this.length,l=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=x._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(l));return l(),o.promise(n)}});var z,X,U=/[\t\r\n\f]/g,V=/\r/g,Y=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,G=/^(?:checked|selected)$/i,Q=x.support.getSetAttribute,K=x.support.input;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return e=x.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,l="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,l=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e,r="boolean"==typeof t;return x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var o,a=0,s=x(this),l=t,u=e.match(T)||[];while(o=u[a++])l=r?l:!s.hasClass(o),s[l?"addClass":"removeClass"](o)}else(n===i||"boolean"===n)&&(this.className&&x._data(this,"__className__",this.className),this.className=this.className||e===!1?"":x._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(U," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=x.isFunction(e),this.each(function(n){var o;1===this.nodeType&&(o=i?e.call(this,n,x(this).val()):e,null==o?o="":"number"==typeof o?o+="":x.isArray(o)&&(o=x.map(o,function(e){return null==e?"":e+""})),r=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=x.valHooks[o.type]||x.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(V,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=x.find.attr(e,"value");return null!=t?t:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,l=0>i?s:o?i:0;for(;s>l;l++)if(n=r[l],!(!n.selected&&l!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),a=i.length;while(a--)r=i[a],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,n,r){var o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===i?x.prop(e,n,r):(1===s&&x.isXMLDoc(e)||(n=n.toLowerCase(),o=x.attrHooks[n]||(x.expr.match.bool.test(n)?X:z)),r===t?o&&"get"in o&&null!==(a=o.get(e,n))?a:(a=x.find.attr(e,n),null==a?t:a):null!==r?o&&"set"in o&&(a=o.set(e,r,n))!==t?a:(e.setAttribute(n,r+""),r):(x.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(T);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)?K&&Q||!G.test(n)?e[r]=!1:e[x.camelCase("default-"+n)]=e[r]=!1:x.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!x.isXMLDoc(e),a&&(n=x.propFix[n]||n,o=x.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var t=x.find.attr(e,"tabindex");return t?parseInt(t,10):Y.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:-1}}}}),X={set:function(e,t,n){return t===!1?x.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&x.propFix[n]||n,n):e[x.camelCase("default-"+n)]=e[n]=!0,n}},x.each(x.expr.match.bool.source.match(/\w+/g),function(e,n){var r=x.expr.attrHandle[n]||x.find.attr;x.expr.attrHandle[n]=K&&Q||!G.test(n)?function(e,n,i){var o=x.expr.attrHandle[n],a=i?t:(x.expr.attrHandle[n]=t)!=r(e,n,i)?n.toLowerCase():null;return x.expr.attrHandle[n]=o,a}:function(e,n,r){return r?t:e[x.camelCase("default-"+n)]?n.toLowerCase():null}}),K&&Q||(x.attrHooks.value={set:function(e,n,r){return x.nodeName(e,"input")?(e.defaultValue=n,t):z&&z.set(e,n,r)}}),Q||(z={set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},x.expr.attrHandle.id=x.expr.attrHandle.name=x.expr.attrHandle.coords=function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&""!==i.value?i.value:null},x.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&r.specified?r.value:t},set:z.set},x.attrHooks.contenteditable={set:function(e,t,n){z.set(e,""===t?!1:t,n)}},x.each(["width","height"],function(e,n){x.attrHooks[n]={set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}}})),x.support.hrefNormalized||x.each(["href","src"],function(e,t){x.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}}),x.support.style||(x.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.support.enctype||(x.propFix.enctype="encoding"),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,n){return x.isArray(n)?e.checked=x.inArray(x(e).val(),n)>=0:t}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}function at(){try{return a.activeElement}catch(e){}}x.event={global:{},add:function(e,n,r,o,a){var s,l,u,c,p,f,d,h,g,m,y,v=x._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=x.guid++),(l=v.events)||(l=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof x===i||e&&x.event.triggered===e.type?t:x.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(T)||[""],u=n.length;while(u--)s=rt.exec(n[u])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),g&&(p=x.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=x.event.special[g]||{},d=x.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&x.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=l[g])||(h=l[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),x.event.global[g]=!0);e=null}},remove:function(e,t,n,r,i){var o,a,s,l,u,c,p,f,d,h,g,m=x.hasData(e)&&x._data(e);if(m&&(c=m.events)){t=(t||"").match(T)||[""],u=t.length;while(u--)if(s=rt.exec(t[u])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=x.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),l=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));l&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||x.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)x.event.remove(e,d+t[u],n,r,!0);x.isEmptyObject(c)&&(delete m.handle,x._removeData(e,"events"))}},trigger:function(n,r,i,o){var s,l,u,c,p,f,d,h=[i||a],g=v.call(n,"type")?n.type:n,m=v.call(n,"namespace")?n.namespace.split("."):[];if(u=f=i=i||a,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+x.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),l=0>g.indexOf(":")&&"on"+g,n=n[x.expando]?n:new x.Event(g,"object"==typeof n&&n),n.isTrigger=o?2:3,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:x.makeArray(r,[n]),p=x.event.special[g]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!x.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(u=u.parentNode);u;u=u.parentNode)h.push(u),f=u;f===(i.ownerDocument||a)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((u=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(x._data(u,"events")||{})[n.type]&&x._data(u,"handle"),s&&s.apply(u,r),s=l&&u[l],s&&x.acceptData(u)&&s.apply&&s.apply(u,r)===!1&&n.preventDefault();if(n.type=g,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(h.pop(),r)===!1)&&x.acceptData(i)&&l&&i[g]&&!x.isWindow(i)){f=i[l],f&&(i[l]=null),x.event.triggered=g;try{i[g]()}catch(y){}x.event.triggered=t,f&&(i[l]=f)}return n.result}},dispatch:function(e){e=x.event.fix(e);var n,r,i,o,a,s=[],l=g.call(arguments),u=(x._data(this,"events")||{})[e.type]||[],c=x.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((x.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,l),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],l=n.delegateCount,u=e.target;if(l&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!=this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||"click"!==e.type)){for(o=[],a=0;l>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?x(r,this).index(u)>=0:x.find(r,this,null,[u]).length),o[r]&&o.push(i);o.length&&s.push({elem:u,handlers:o})}return n.length>l&&s.push({elem:this,handlers:n.slice(l)}),s},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||a),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,o):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,o,s=n.button,l=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||a,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&l&&(e.relatedTarget=l===e.target?n.toElement:l),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==at()&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===at()&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},click:{trigger:function(){return x.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=a.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},x.Event=function(e,n){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&x.extend(this,n),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,t):new x.Event(e,n)},x.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.submitBubbles||(x.event.special.submit={setup:function(){return x.nodeName(this,"form")?!1:(x.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=x.nodeName(n,"input")||x.nodeName(n,"button")?n.form:t;r&&!x._data(r,"submitBubbles")&&(x.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),x._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&x.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return x.nodeName(this,"form")?!1:(x.event.remove(this,"._submit"),t)}}),x.support.changeBubbles||(x.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(x.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),x.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),x.event.simulate("change",this,e,!0)})),!1):(x.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!x._data(t,"changeBubbles")&&(x.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||x.event.simulate("change",this.parentNode,e,!0)}),x._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return x.event.remove(this,"._change"),!Z.test(this.nodeName)}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&a.addEventListener(e,r,!0)},teardown:function(){0===--n&&a.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return x().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=x.guid++)),this.each(function(){x.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,x(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){x.event.remove(this,e,r,n)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?x.event.trigger(e,n,r,!0):t}});var st=/^.[^:#\[\.,]*$/,lt=/^(?:parents|prev(?:Until|All))/,ut=x.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if("string"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+" "+e:e,n},has:function(e){var t,n=x(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(x.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e||[],!0))},filter:function(e){return this.pushStack(ft(this,e||[],!1))},is:function(e){return!!ft(this,"string"==typeof e&&ut.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],a=ut.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(a?a.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?x.inArray(this[0],x(e)):x.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(ct[e]||(i=x.unique(i)),lt.test(e)&&(i=i.reverse())),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!x(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(st.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return x.inArray(e,t)>=0!==n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Ct=/^(?:checkbox|radio)$/i,Nt=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:x.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(a),Dt=jt.appendChild(a.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===t?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||a).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(Ft(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&_t(Ft(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&x.cleanData(Ft(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&x.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!x.support.htmlSerialize&&mt.test(e)||!x.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(x.cleanData(Ft(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=d.apply([],e);var r,i,o,a,s,l,u=0,c=this.length,p=this,f=c-1,h=e[0],g=x.isFunction(h);if(g||!(1>=c||"string"!=typeof h||x.support.checkClone)&&Nt.test(h))return this.each(function(r){var i=p.eq(r);g&&(e[0]=h.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(l=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),r=l.firstChild,1===l.childNodes.length&&(l=r),r)){for(a=x.map(Ft(l,"script"),Ht),o=a.length;c>u;u++)i=l,u!==f&&(i=x.clone(i,!0,!0),o&&x.merge(a,Ft(i,"script"))),t.call(this[u],i,u);if(o)for(s=a[a.length-1].ownerDocument,x.map(a,qt),u=0;o>u;u++)i=a[u],kt.test(i.type||"")&&!x._data(i,"globalEval")&&x.contains(s,i)&&(i.src?x._evalUrl(i.src):x.globalEval((i.text||i.textContent||i.innerHTML||"").replace(St,"")));l=r=null}return this}});function Lt(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function Ht(e){return e.type=(null!==x.find.attr(e,"type"))+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function _t(e,t){var n,r=0;for(;null!=(n=e[r]);r++)x._data(n,"globalEval",!t||x._data(t[r],"globalEval"))}function Mt(e,t){if(1===t.nodeType&&x.hasData(e)){var n,r,i,o=x._data(e),a=x._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)x.event.add(t,n,s[n][r])}a.data&&(a.data=x.extend({},a.data))}}function Ot(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!x.support.noCloneEvent&&t[x.expando]){i=x._data(t);for(r in i.events)x.removeEvent(t,r,i.handle);t.removeAttribute(x.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),x.support.html5Clone&&e.innerHTML&&!x.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Ct.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=0,i=[],o=x(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),x(o[r])[t](n),h.apply(i,n.get());return this.pushStack(i)}});function Ft(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||x.nodeName(o,n)?s.push(o):x.merge(s,Ft(o,n));return n===t||n&&x.nodeName(e,n)?x.merge([e],s):s}function Bt(e){Ct.test(e.type)&&(e.defaultChecked=e.checked)}x.extend({clone:function(e,t,n){var r,i,o,a,s,l=x.contains(e.ownerDocument,e);if(x.support.html5Clone||x.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(x.support.noCloneEvent&&x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(r=Ft(o),s=Ft(e),a=0;null!=(i=s[a]);++a)r[a]&&Ot(i,r[a]);if(t)if(n)for(s=s||Ft(e),r=r||Ft(o),a=0;null!=(i=s[a]);a++)Mt(i,r[a]);else Mt(e,o);return r=Ft(o,"script"),r.length>0&&_t(r,!l&&Ft(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,l,u,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===x.type(o))x.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),l=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[l]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!x.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!x.support.tbody){o="table"!==l||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)x.nodeName(u=o.childNodes[i],"tbody")&&!u.childNodes.length&&o.removeChild(u)}x.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),x.support.appendChecked||x.grep(Ft(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===x.inArray(o,r))&&(a=x.contains(o.ownerDocument,o),s=Ft(f.appendChild(o),"script"),a&&_t(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,l=x.expando,u=x.cache,c=x.support.deleteExpando,f=x.event.special;for(;null!=(n=e[s]);s++)if((t||x.acceptData(n))&&(o=n[l],a=o&&u[o])){if(a.events)for(r in a.events)f[r]?x.event.remove(n,r):x.removeEvent(n,r,a.handle);
u[o]&&(delete u[o],c?delete n[l]:typeof n.removeAttribute!==i?n.removeAttribute(l):n[l]=null,p.push(o))}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})}}),x.fn.extend({wrapAll:function(e){if(x.isFunction(e))return this.each(function(t){x(this).wrapAll(e.call(this,t))});if(this[0]){var t=x(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+w+")(.*)$","i"),Yt=RegExp("^("+w+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+w+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=x._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=x._data(r,"olddisplay",ln(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&x._data(r,"olddisplay",i?n:x.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}x.fn.extend({css:function(e,n){return x.access(this,function(e,n,r){var i,o,a={},s=0;if(x.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=x.css(e,n[s],!1,o);return a}return r!==t?x.style(e,n,r):x.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){var t="boolean"==typeof e;return this.each(function(){(t?e:nn(this))?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":x.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,l=x.camelCase(n),u=e.style;if(n=x.cssProps[l]||(x.cssProps[l]=tn(u,l)),s=x.cssHooks[n]||x.cssHooks[l],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:u[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(x.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||x.cssNumber[l]||(r+="px"),x.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(u[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{u[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,l=x.camelCase(n);return n=x.cssProps[l]||(x.cssProps[l]=tn(e.style,l)),s=x.cssHooks[n]||x.cssHooks[l],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||x.isNumeric(o)?o||0:a):a}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s.getPropertyValue(n)||s[n]:t,u=e.style;return s&&(""!==l||x.contains(e.ownerDocument,e)||(l=x.style(e,n)),Yt.test(l)&&Ut.test(n)&&(i=u.width,o=u.minWidth,a=u.maxWidth,u.minWidth=u.maxWidth=u.width=l,l=s.width,u.width=i,u.minWidth=o,u.maxWidth=a)),l}):a.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s[n]:t,u=e.style;return null==l&&u&&u[n]&&(l=u[n]),Yt.test(l)&&!zt.test(n)&&(i=u.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),u.left="fontSize"===n?"1em":l,l=u.pixelLeft+"px",u.left=i,a&&(o.left=a)),""===l?"auto":l});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=x.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=x.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=x.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=x.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=x.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function ln(e){var t=a,n=Gt[e];return n||(n=un(e,t),"none"!==n&&n||(Pt=(Pt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=un(e,t),Pt.detach()),Gt[e]=n),n}function un(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,n){x.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(x.css(e,"display"))?x.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x.support.opacity||(x.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=x.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===x.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,n){return n?x.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,n){x.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?x(e).position()[n]+"px":r):t}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!x.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||x.css(e,"display"))},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(x.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Ct.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),x.param=function(e,n){var r,i=[],o=function(e,t){t=x.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var mn,yn,vn=x.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Cn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Nn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=x.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=o.href}catch(Ln){yn=a.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(T)||[];if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(l){var u;return o[l]=!0,x.each(e[l]||[],function(e,l){var c=l(n,r,i);return"string"!=typeof c||a||o[c]?a?!(u=c):t:(n.dataTypes.unshift(c),s(c),!1)}),u}return s(n.dataTypes[0])||!o["*"]&&s("*")}function _n(e,n){var r,i,o=x.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,l=e.indexOf(" ");return l>=0&&(i=e.slice(l,e.length),e=e.slice(0,l)),x.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&x.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?x("<div>").append(x.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Cn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?_n(_n(e,x.ajaxSettings),t):_n(x.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,l,u,c,p=x.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),g=x.Callbacks("once memory"),m=p.statusCode||{},y={},v={},b=0,w="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return b||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)m[t]=[m[t],e[t]];else C.always(e[C.status]);return this},abort:function(e){var t=e||w;return u&&u.abort(t),k(0,t),this}};if(h.promise(C).complete=g.add,C.success=C.done,C.error=C.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=x.trim(p.dataType||"*").toLowerCase().match(T)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?"80":"443"))===(mn[3]||("http:"===mn[1]?"80":"443")))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=x.param(p.data,p.traditional)),qn(An,p,n,C),2===b)return C;l=p.global,l&&0===x.active++&&x.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Nn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(x.lastModified[o]&&C.setRequestHeader("If-Modified-Since",x.lastModified[o]),x.etag[o]&&C.setRequestHeader("If-None-Match",x.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&C.setRequestHeader("Content-Type",p.contentType),C.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)C.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,C,p)===!1||2===b))return C.abort();w="abort";for(i in{success:1,error:1,complete:1})C[i](p[i]);if(u=qn(jn,p,n,C)){C.readyState=1,l&&d.trigger("ajaxSend",[C,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){C.abort("timeout")},p.timeout));try{b=1,u.send(y,k)}catch(N){if(!(2>b))throw N;k(-1,N)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,N=n;2!==b&&(b=2,s&&clearTimeout(s),u=t,a=i||"",C.readyState=e>0?4:0,c=e>=200&&300>e||304===e,r&&(w=Mn(p,C,r)),w=On(p,w,C,c),c?(p.ifModified&&(T=C.getResponseHeader("Last-Modified"),T&&(x.lastModified[o]=T),T=C.getResponseHeader("etag"),T&&(x.etag[o]=T)),204===e||"HEAD"===p.type?N="nocontent":304===e?N="notmodified":(N=w.state,y=w.data,v=w.error,c=!v)):(v=N,(e||!N)&&(N="error",0>e&&(e=0))),C.status=e,C.statusText=(n||N)+"",c?h.resolveWith(f,[y,N,C]):h.rejectWith(f,[C,N,v]),C.statusCode(m),m=t,l&&d.trigger(c?"ajaxSuccess":"ajaxError",[C,p,c?y:v]),g.fireWith(f,[C,N]),l&&(d.trigger("ajaxComplete",[C,p]),--x.active||x.event.trigger("ajaxStop")))}return C},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,n){return x.get(e,t,n,"script")}}),x.each(["get","post"],function(e,n){x[n]=function(e,r,i,o){return x.isFunction(r)&&(o=o||i,i=r,r=t),x.ajax({url:e,type:n,dataType:o,data:r,success:i})}});function Mn(e,n,r){var i,o,a,s,l=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in l)if(l[s]&&l[s].test(o)){u.unshift(s);break}if(u[0]in r)a=u[0];else{for(s in r){if(!u[0]||e.converters[s+" "+u[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==u[0]&&u.unshift(a),r[a]):t}function On(e,t,n,r){var i,o,a,s,l,u={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)u[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!l&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=c.shift())if("*"===o)o=l;else if("*"!==l&&l!==o){if(a=u[l+" "+o]||u["* "+o],!a)for(i in u)if(s=i.split(" "),s[1]===o&&(a=u[l+" "+s[0]]||u["* "+s[0]])){a===!0?a=u[i]:u[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(p){return{state:"parsererror",error:a?p:"No conversion from "+l+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),x.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=a.head||x("head")[0]||a.documentElement;return{send:function(t,i){n=a.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Fn=[],Bn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Fn.pop()||x.expando+"_"+vn++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,l=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return l||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=x.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,l?n[l]=n[l].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||x.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Fn.push(o)),s&&x.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}x.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=x.ajaxSettings.xhr(),x.support.cors=!!Rn&&"withCredentials"in Rn,Rn=x.support.ajax=!!Rn,Rn&&x.ajaxTransport(function(n){if(!n.crossDomain||x.support.cors){var r;return{send:function(i,o){var a,s,l=n.xhr();if(n.username?l.open(n.type,n.url,n.async,n.username,n.password):l.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)l[s]=n.xhrFields[s];n.mimeType&&l.overrideMimeType&&l.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)l.setRequestHeader(s,i[s])}catch(u){}l.send(n.hasContent&&n.data||null),r=function(e,i){var s,u,c,p;try{if(r&&(i||4===l.readyState))if(r=t,a&&(l.onreadystatechange=x.noop,$n&&delete Pn[a]),i)4!==l.readyState&&l.abort();else{p={},s=l.status,u=l.getAllResponseHeaders(),"string"==typeof l.responseText&&(p.text=l.responseText);try{c=l.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,u)},n.async?4===l.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},x(e).unload($n)),Pn[a]=r),l.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+w+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Yn.exec(t),o=i&&i[3]||(x.cssNumber[e]?"":"px"),a=(x.cssNumber[e]||"px"!==o&&+r)&&Yn.exec(x.css(n.elem,e)),s=1,l=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do s=s||".5",a/=s,x.style(n.elem,e,a+o);while(s!==(s=n.cur()/r)&&1!==s&&--l)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=x.now()}function Zn(e,t,n){var r,i=(Qn[t]||[]).concat(Qn["*"]),o=0,a=i.length;for(;a>o;o++)if(r=i[o].call(n,t,e))return r}function er(e,t,n){var r,i,o=0,a=Gn.length,s=x.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,u.startTime+u.duration-t),r=n/u.duration||0,o=1-r,a=0,l=u.tweens.length;for(;l>a;a++)u.tweens[a].run(o);return s.notifyWith(e,[u,o,n]),1>o&&l?n:(s.resolveWith(e,[u]),!1)},u=s.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,u.opts,t,n,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(r),r},stop:function(t){var n=0,r=t?u.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)u.tweens[n].run(1);return t?s.resolveWith(e,[u,t]):s.rejectWith(e,[u,t]),this}}),c=u.props;for(tr(c,u.opts.specialEasing);a>o;o++)if(r=Gn[o].call(u,e,c,u.opts))return r;return x.map(c,Zn,u),x.isFunction(u.opts.start)&&u.opts.start.call(e,u),x.fx.timer(x.extend(l,{elem:e,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function tr(e,t){var n,r,i,o,a;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=x.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(er,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,l,u=this,c={},p=e.style,f=e.nodeType&&nn(e),d=x._data(e,"fxshow");n.queue||(s=x._queueHooks(e,"fx"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,u.always(function(){u.always(function(){s.unqueued--,x.queue(e,"fx").length||s.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(x.support.inlineBlockNeedsLayout&&"inline"!==ln(e.nodeName)?p.zoom=1:p.display="inline-block")),n.overflow&&(p.overflow="hidden",x.support.shrinkWrapBlocks||u.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Vn.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(f?"hide":"show"))continue;c[r]=d&&d[r]||x.style(e,r)}if(!x.isEmptyObject(c)){d?"hidden"in d&&(f=d.hidden):d=x._data(e,"fxshow",{}),o&&(d.hidden=!f),f?x(e).show():u.done(function(){x(e).hide()}),u.done(function(){var t;x._removeData(e,"fxshow");for(t in c)x.style(e,t,c[t])});for(r in c)a=Zn(f?d[r]:0,r,u),r in d||(d[r]=a.start,f&&(a.end=a.start,a.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}x.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),a=function(){var t=er(this,x.extend({},e),o);(i||x._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=x.timers,a=x._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=x._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,a=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=rr.prototype.init,x.fx.tick=function(){var e,n=x.timers,r=0;for(Xn=x.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||x.fx.stop(),Xn=t},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){Un||(Un=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(Un),Un=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){x.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,x.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},x.offset={setOffset:function(e,t,n){var r=x.css(e,"position");"static"===r&&(e.style.position="relative");var i=x(e),o=i.offset(),a=x.css(e,"top"),s=x.css(e,"left"),l=("absolute"===r||"fixed"===r)&&x.inArray("auto",[a,s])>-1,u={},c={},p,f;l?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),x.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(u.top=t.top-o.top+p),null!=t.left&&(u.left=t.left-o.left+f),"using"in t?t.using.call(e,u):i.css(u)}},x.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===x.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(n=e.offset()),n.top+=x.css(e[0],"borderTopWidth",!0),n.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-x.css(r,"marginTop",!0),left:t.left-n.left-x.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);x.fn[e]=function(i){return x.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?x(a).scrollLeft():o,r?o:x(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return x.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}x.each({Height:"height",Width:"width"},function(e,n){x.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){x.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return x.access(this,function(n,r,i){var o;return x.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?x.css(n,r,s):x.style(n,r,i,s)},n,a?i:t,a,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&module&&"object"==typeof module.exports?module.exports=x:(e.jQuery=e.$=x,"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}))})(window);
});
define('auth-interface/index',['require','exports','module'],function (require, exports, module) {/**
 * @fileoverview An array of all the public properties on the auth object.
 */

module.exports = ["get", "isAuthenticated", "create", "delegate", "hasDelegate", "login", "logout", "authenticate", "viewProfile", "editProfile", "on", "addListener", "once", "removeListener", "emit"];

});

define('auth-interface', ['auth-interface/index'], function (main) { return main; });

define('livefyre-auth/util/get-script',['require','exports','module'],function (require, exports, module) {module.exports = {
    req: function (url, callback) {
        var head = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement('script');
        var done = false;

        script.src = url;

        // Attach handlers for all browsers
        script.onload = script.onreadystatechange = function() {
            if ( !done && (!this.readyState ||
                    this.readyState === "loaded" || this.readyState === "complete") ) {
                done = true;

                callback();

                // Handle memory leak in IE
                script.onload = script.onreadystatechange = null;
                if ( head && script.parentNode ) {
                    head.removeChild( script );
                }
            }
        };

        // Use insertBefore instead of appendChild  to circumvent an IE6 bug.
        // This arises when a base node is used (#2709 and #4378).
        head.insertBefore( script, head.firstChild );
    }
};

});

define('mout/array/slice',[],function () {

    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    return slice;

});

define('mout/function/bind',['../array/slice'], function(slice){

    /**
     * Return a function that will execute in the given context, optionally adding any additional supplied parameters to the beginning of the arguments collection.
     * @param {Function} fn  Function.
     * @param {object} context   Execution context.
     * @param {rest} args    Arguments (0...n arguments).
     * @return {Function} Wrapped Function.
     */
    function bind(fn, context, args){
        var argsArr = slice(arguments, 2); //curried args
        return function(){
            return fn.apply(context, argsArr.concat(slice(arguments)));
        };
    }

    return bind;
});


define('livefyre-auth/contrib/auth-later-internal',['require','exports','module','auth-interface','../util/get-script','mout/function/bind'],function (require, exports, module) {/**
 * @fileoverview More than just stub! Here we check if Livefyre auth is on the page. If it is, we use it.
 * If it isn't, then we fetch Livefyre.js and in set up a proxy/queue to the incoming Livefyre auth.
 */
var authInterface = require('auth-interface');
var getScript = require('../util/get-script');
var bind = require('mout/function/bind');

exports.hazAuth = false;
exports.pendingCalls = [];
exports.auth = {};

/**
 * Has auth arrived? We check that Livefyre.js is on the page, since it haz auth.
 */
exports.authHasArrived = function() {
    return window.Livefyre && window.Livefyre['_lfjs'] === true;
};

/**
 * Flush the pending calls now that auth has arrived
 */
exports.flushPendingCalls = function() {
    var methodCall;
    for (var i = 0; i < exports.pendingCalls.length; i++) {
        methodCall = exports.pendingCalls[i];
        exports.auth[methodCall[0]].apply(exports.auth, methodCall[1]);
    }
    exports.pendingCalls = [];
};

/**
 * Proxy a call to Livefyre auth
 * @param {string} methodName
 */
exports.proxyCall = function(methodName) {
    var args = Array.prototype.slice.call(arguments, 1);
    if (exports.hazAuth) {
        return exports.auth[methodName].apply(exports.auth, args);
    }
    exports.pendingCalls.push([methodName, args]);
};

/**
 * Load Scout to Load LivefyreJS + Auth
 */
exports.getLivefyreJS = function() {
    getScript.req('//cdn.livefyre.com/Livefyre.js', function () {
        window.Livefyre.on('initialized', exports.handleAuthHasArrived);
    });
};

/**
 * Proxy all public auth methods so that they can be invoked before auth is actually on the page.
 */
exports.getAuth = function() {
    var methodName;
    for (var i = authInterface.length - 1; i >= 0; i--) {
        methodName = authInterface[i];
        exports.auth[methodName] = bind(exports.proxyCall, exports.auth, methodName);
    }

    // If we don't have auth, fetch Livefyre.js
    if (exports.authHasArrived()) {
        exports.handleAuthHasArrived();
    } else {
        exports.getLivefyreJS();
    }

    return exports.auth;
};

/**
 * Yay auth is here!
 */
exports.handleAuthHasArrived = function() {
    window.Livefyre.require(['auth'], function (authModule) {
        exports.auth = authModule;
        exports.hazAuth = true;
        exports.flushPendingCalls();
        // we need to fake a login b/c we might have a session user
        // and the event listeners just lost a race as they registered after auth initialized.
        var session = exports.auth.get();
        if (session) {
            exports.auth.login(session);
        }
    });
};

});

define('auth/main',['require','exports','module','livefyre-auth/contrib/auth-later-internal'],function (require, exports, module) {module.exports = require('livefyre-auth/contrib/auth-later-internal').getAuth();

});

define('auth', ['auth/main'], function (main) { return main; });

define('view/event-map',['require','exports','module'],function (require, exports, module) {

/**
 * An extensible object that maps event selectors to callback functions
 * @param events {Object} - Initial event mapping
 */
function EventMap (events) {
    this._factories = [];
    extend(this, [events]);
}

/**
 * Return another EventMap that has been extended with
 * the provided objects
 * @param {...object} extensions - Objects to extend from
 * @returns {EventMap} - A new EventMap, extended from this and others
 */
EventMap.prototype.extended = function () {
    var newMap = new EventMap(this);
    var extensions = [].slice.apply(arguments);
    extend(newMap, extensions);
    return newMap;
};

/**
 * Evaluate the EventMap with a particular context
 * Any ._factories will be called so that `this` is the provided context
 * @returns {object} object mapping event strings/selectors to callback functions
 */
EventMap.prototype.withContext = function (context) {
    var contextualExtensions = [];
    var factory;
    var theseEvents;
    var events = {};
    for (var i=0, numFactories=this._factories.length; i < numFactories; i++) {
        factory = this._factories[i];
        theseEvents = {};
        contextualExtensions.push(factory.call(context, theseEvents) || theseEvents);
    }
    extend(events, [this].concat(contextualExtensions));
    return events;
};

/**
 * Extend the first argument with keys from the rest, left to right
 * Only extends ownProperties (unlike $.extend)
 * @param {object} target - Target Object to extend
 * @param {object[]} extensions - Array of Objects to extend from
 */
function extend (target, extensions) {
    var copy, name, extension, extensionsLength;
    target = target || {},
    extensions = extensions || [];
    extensionsLength = extensions.length;

    for (var i=0; i < extensionsLength; i++) {
        // Only deal with non-undefined values
        if ((extension = extensions[i]) !== undefined) {
            // If it's a function, store in target._factories
            if (typeof extension === 'function') {
                target._factories.push(extension);
                continue;
            }
            // Extend the base object
            for (name in extension) {
                if ( ! extension.hasOwnProperty(name)) {
                    continue;
                }
                copy = extension[name];

                // Copy _factories array
                if (name === '_factories' && copy.slice) {
                    copy = copy.slice();
                }

                // Prevent never-ending loop
                if (target === copy) {
                    continue;
                }

                if (copy !== undefined) {
                    target[name] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
}

module.exports = EventMap;

});

define('view/delegate',['require','exports','module','jquery','view/event-map'],function (require, exports, module) {/**
 * @fileOverview Delegate utils.
 */
var $ = require('jquery');
var EventMap = require('view/event-map');

/** @const {string} */
var EVENT_ANTENNA = '.delegateEvents';

/** @const {RegExp} */
var EVENT_SPLITTER = /^(\S+)\s*(.*)$/;

/** @type {number} */
var idCounts = 0;

/**
 * Delegate events. Binds a listener for all events onto the $antenna. The
 * uniqueId is used as a way to access them later.
 * @param {jQuery} $antenna
 * @param {Object.<string, string|function>} events
 * @param {string} uniqueId
 * @param {Object} context
 */
function delegateEvents($antenna, events, uniqueId, context) {
    undelegateEvents($antenna, uniqueId);
    if (events instanceof EventMap) {
        events = events.withContext(context);
    }
    for (var key in events) {
        if (events.hasOwnProperty(key)) {
            var method = events[key];
            if (typeof method === 'string') {
                method = context[method];
            }
            if (!method) {
                throw "Undefined method for: " + key;
            }
            method = $.proxy(method, context);

            var match = key.match(EVENT_SPLITTER);
            if (!match) {
                throw "Invalid event/selector pair: " + key;
            }
            var eventName = match[1];
            var selector = match[2];
            eventName += EVENT_ANTENNA + uniqueId;
            if (selector === '') {
                $antenna.on(eventName, method);
            } else {
                $antenna.on(eventName, selector, method);
            }
        }
    }
}

/**
 * Get a unique Id
 * @return {string}
 */
function getUniqueId () {
    return ++idCounts + '';
}

/**
 * Undelegate events. Removes all events from the provided antenna jQuery
 * element. Uses the uniqueId as a way of grabbing all delegated events.
 * @param {jQuery} $antenna The antenna element.
 * @param {string} uniqueId The id that all events are using.
 */
function undelegateEvents($antenna, uniqueId) {
    $antenna.off(EVENT_ANTENNA + uniqueId);
}

module.exports = {
    delegateEvents: delegateEvents,
    getUniqueId: getUniqueId,
    undelegateEvents: undelegateEvents
};

});

define('event-emitter',[],function() {

    var slice = Array.prototype.slice;


    /**
     * Defines the base class for all event emitting objects to extend.
     * @exports streamhub-sdk/event-emitter
     * @constructor
     */
    var EventEmitter = function() {
        this._listeners = {};
    };


    EventEmitter.listenerCount = function (emitter, eventName) {
        var listeners = emitter._listeners[eventName];
        if ( ! listeners) {
            return 0;
        }
        return listeners.length;
    };


    /**
     * Binds a listener function to an event name.
     * @param name {string} The event name to bind to.
     * @param fn {function} The callback function to call whenever the event is emitted.
     * @returns {EventEmitter} Returns 'this' for chaining
     */
    EventEmitter.prototype.on = function(name, fn) {
        this._listeners[name] = this._listeners[name] || [];
        this._listeners[name].push(fn);
        return this;
    };
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;


    EventEmitter.prototype.once = function (name, fn) {
        function doAndRemoveListener () {
            this.removeListener(name, doAndRemoveListener);
            fn.apply(this, arguments);
        }
        // Store original listener
        doAndRemoveListener.listener = fn;
        return this.on(name, doAndRemoveListener);
    };


    /**
     * Removes a bound listener from the named event.
     * @param name {string} The name of the event to remove this listener from.
     * @param fn {function} The original callback function to remove.
     */
    EventEmitter.prototype.removeListener = function(name, fn) {
        if (fn && this._listeners[name]) {
            this._listeners[name].splice(indexOf(this._listeners[name], fn), 1);
        }
    };


    /**
     * Emits an event from the object this is called on. Iterates through bound
     * listeners and passes through the arguments emit was called with.
     * @param name {string} The name of the event to emit.
     * @param {...Object} Optional arguments to pass to each listener's callback.
     */
    EventEmitter.prototype.emit = function(name) {
        var listeners = this._listeners[name] || [],
            args = slice.call(arguments, 1),
            err;

        // Copy listeners in case executing them mutates the array
        // e.g. .once() listeners remove themselves
        if (listeners.length) {
            listeners = listeners.slice();
        }
        
        // Throw on error event if there are no listeners
        if (name === 'error' && ! listeners.length) {
            err = args[0];
            if (err instanceof Error) {
                throw err;
            } else {
                throw TypeError('Uncaught, unspecified "error" event');
            }
        }

        for (var i=0, numListeners=listeners.length; i < numListeners; i++) {
            try {
                listeners[i].apply(this, args); 
            } catch(err) {
                this.emit('error', err);
            }
        }
    };

    /**
     * Helper for Array.prototype.indexOf since IE8 does not have it.
     * Note this does not implement a "fromIndex" param.
     * @param {Array} arr
     * @parma {*} obj
     */
    function indexOf(arr, obj) {
        if (Array.prototype.indexOf) {
            return arr.indexOf(obj);
        }

        for (var i = 0, l = arr.length; i < l; i++) {
            if (arr[i] === obj) {
                return i;
            }
        }
        return -1;
    }

    return EventEmitter;
});

define('inherits',[], function () {


    /**
     * sub should prototypally inherit from base
     * @param sub {function} Subclass constructor
     * @param base {function} Base class constructor
     */
    function inherits (sub, base) {
        var Fn = function(){};
        Fn.prototype = base.prototype;
        sub.prototype = new Fn();
        sub.prototype.constructor = sub;
    }


    /**
     * sub should parasitically inherit from base
     * that is, we should pluck values from base.prototype onto sub.prototype
     */
    inherits.parasitically = function (sub, base) {
        var baseKeys = inherits.keys(base.prototype),
            baseKeysLength = baseKeys.length,
            methodName;
        for (var i=0; i < baseKeysLength; i++) {
            methodName = baseKeys[i];
            if ( ! sub.prototype[methodName]) {
                sub.prototype[methodName] = base.prototype[methodName];
            }
        }
    };


    /**
     * Object.keys shim
     */
    inherits.keys = Object.keys || (function () {
        var hasOwnProperty = Object.prototype.hasOwnProperty,
            hasDontEnumBug = !{toString:null}.propertyIsEnumerable("toString"),
            DontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ],
            DontEnumsLength = DontEnums.length;

        return function (o) {
            if (typeof o != "object" && typeof o != "function" || o === null)
                throw new TypeError("Object.keys called on a non-object");

            var result = [];
            for (var name in o) {
                if (hasOwnProperty.call(o, name))
                    result.push(name);
            }

            if (hasDontEnumBug) {
                for (var i = 0; i < DontEnumsLength; i++) {
                    if (hasOwnProperty.call(o, DontEnums[i]))
                        result.push(DontEnums[i]);
                }
            }

            return result;
        };
    })();

    return inherits;
});
define('annotations/controller/base',['require','exports','module','jquery','view/delegate','event-emitter','inherits'],function (require, exports, module) {/**
 * @fileOverview Base Controller
 */

var $ = require('jquery');
var delegate = require('view/delegate');
var EventEmitter = require('event-emitter');
var inherits = require('inherits');

/**
 * Base class for components that handle events but do not map to visual nodes.
 * @constructor
 * @param {Object} opts
 */
function BaseController(opts) {
    EventEmitter.call(this);

    /**
     * Element that events will be bubbled to so that they can be handled.
     * @type {jQuery}
     */
    this.$antenna = opts.antenna;

    /**
     * Global antenna to use.
     * @type {jQuery}
     */
    this.$globalAntenna = $(document.body);

    /**
     * The collection object.
     * @type {AnnotationsCollection}
     * @private
     */
    this._collection = opts.collection;

    /**
     * Config object.
     * @type {Object}
     * @private
     */
    this._config = opts.config;

    /**
     * The unique id of this controller.
     * @type {string}
     * @private
     */
    this._uid = delegate.getUniqueId();

    this.delegateEvents();
    this.delegateEvents(this.$globalAntenna, this.globalEvents);
}
inherits(BaseController, EventEmitter);

/**
 * Decorates a function, adding functionality to not call the function if the
 * message was sent from this app.
 * @param {function()} fn The function to decorate.
 * @return {function()} The wrapped function.
 */
BaseController.onlyHandleExternalMessage = function(fn) {
    return function(evt, data) {
        // Don't call the wrapped function if the message was sent from the
        // same app instance that this controller is on.
        if (evt.target === this.$antenna[0]) {
            return;
        }
        fn.call(this, evt, data);
    };
};

/** @enum {string} */
BaseController.prototype.events = {};

/** @enum {string} */
BaseController.prototype.globalEvents = {};

/**
 * Bind listeners to the root container. This will listen for all DOM events
 * that need to be handled and trigger them on the antenna.
 * @param {jQuery} $container The container element to listen for events on.
 */
BaseController.prototype.bindListeners = function ($container) {
    if (!this.containerEvents) {
        return;
    }
    var self = this;
    $container.on(this.containerEvents.join(' '), function(evt, data) {
        self.$antenna.trigger([evt.type, evt.namespace].join('.'), data);
    });
};

/**
 * Delegate the events
 */
BaseController.prototype.delegateEvents = function (antenna, events) {
    delegate.delegateEvents(antenna || this.$antenna, events || this.events,
        this._uid, this);
};

/**
 * Get the active block at any given time.
 * @return {?Block} The active block.
 * @private
 */
BaseController.prototype._getActiveBlock = function () {
    return this._collection.block;
};

/**
 * Destroy the controller.
 */
BaseController.prototype.destroy = function() {
    delegate.undelegateEvents(this.$antenna, this._uid);
    delegate.undelegateEvents(this.$globalAntenna, this._uid);
    this.$antenna = null;
};

module.exports = BaseController;

});

define('annotations/events/events',['require','exports','module'],function (require, exports, module) {var Events = {};

/** @enum {string} */
Events.block = {
    UPDATE_COUNT: 'block.update_count'
};

/** @enum {string} */
Events.comment = {
    ACTION_SUCCESS: 'comment.action_success',
    HIDDEN: 'comment.hidden',
    GET_PERMALINK: 'comment.get_permalink'
};

/** @enum {string} */
Events.content = {
    FETCH_EREFS: 'content.fetch_erefs'
};

/** @enum {string} */
Events.editor = {
    HIDE: 'editor.hide'
};

/** @enum {string} */
Events.source = {
    ADD_ANNOTATION_CLICK: 'source.add_annotation_click',
    SHARE_CLICK: 'source.share_click',
    TEXT_HIGHLIGHTED: 'source.text_highlighted',
    THREAD_BTN_CLICK: 'source.thread_btn_click',
    THREAD_BTN_MOUSEDOWN: 'source.thread_btn_mousedown'
};

/** @enum {string} */
Events.thread = {
    ACTIVATE_BLOCK: 'thread.activate_block',
    ACTIVATE_HIGHLIGHTED_TEXT: 'thread.activate_highlighted_text',
    ACTIVATE_THREAD: 'thread.activate_thread',
    CHANGE_VIEW: 'thread.change_view',
    DEACTIVATE_HIGHLIGHTED_TEXT: 'thread.deactivate_highlighted_text',
    DESTROY_THREAD: 'thread.destroy_thread',
    NAVIGATE: 'thread.navigate',
    NAVIGATE_BACK: 'thread.navigate_back',
    NAVIGATE_TO_THREAD: 'thread.navigate_to_thread',
    PERMALINK_BACK: 'thread.permalink_back',
    SHOW_QUEUED_CONTENT: 'thread.show_queued_content',
    TUCK_THREAD: 'thread.tuck',
    UNTUCK_THREAD: 'thread.untuck'
};

/** @enum {string} */
Events.user = {
    ADMIN: 'user.admin',
    EDIT_PROFILE: 'user.edit_profile',
    LOGIN: 'user.login',
    LOGOUT: 'user.logout',
    VIEW_PROFILE: 'user.view_profile'
};

/** @enum {string} */
Events.write = {
    COMMENT_FLAGGED: 'write.comment_flagged',
    COMMENT_POSTED: 'write.comment_posted',
    COMMENT_SHARED: 'write.comment_shared',
    COMMENT_VOTED: 'write.comment_voted',
    POST_ANNOTATION: 'write.post_annotation',
    POST_APPROVE: 'write.post_approve',
    POST_DELETE: 'write.post_delete',
    POST_EDIT: 'write.post_edit',
    POST_FLAG: 'write.post_flag',
    POST_HIDE: 'write.post_hide',
    POST_REPLY: 'write.post_reply',
    POST_SHARE: 'write.post_share',
    POST_VOTE: 'write.post_vote'
};

/**
 * These events are special because they have been declared to customers.
 * @enum {string}
 */
Events.external = {
    COMMENT_FLAGGED: 'sidenotes.commentFlagged',
    COMMENT_POSTED: 'sidenotes.commentPosted',
    COMMENT_SHARED: 'sidenotes.commentShared',
    COMMENT_VOTED: 'sidenotes.commentVoted',
    INITIALIZED: 'sidenotes.initialized',
    USER_LOGGED_IN: 'sidenotes.userLoggedIn',
    USER_LOGGED_OUT: 'sidenotes.userLoggedOut'
};

module.exports = Events;

});

define('annotations/events', ['annotations/events/events'], function (main) { return main; });

define('hogan',['require','exports','module'],function(require, exports, module){

// wrapped Hogan.js into an AMD module and also added pragmas to remove
// compiler after build if it isn't needed. Source code wasn't touched
// besides that.


// START WRAPPED CODE
// ===========================================================================


/*
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */



var Hogan = {};

(function (Hogan, useArrayBuffer) {
  Hogan.Template = function (renderFunc, text, compiler, options) {
    this.r = renderFunc || this.r;
    this.c = compiler;
    this.options = options;
    this.text = text || '';
    this.buf = (useArrayBuffer) ? [] : '';
  }

  Hogan.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return ''; },

    // variable escaping
    v: hoganEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // tries to find a partial in the curent scope and render it
    rp: function(name, context, partials, indent) {
      var partial = partials[name];

      if (!partial) {
        return '';
      }

      if (this.c && typeof partial == 'string') {
        partial = this.c.compile(partial, this.options);
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i < tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if (isArray(val) && val.length === 0) {
        return false;
      }

      if (typeof val == 'function') {
        val = this.ls(val, ctx, partials, inverted, start, end, tags);
      }

      pass = (val === '') || !!val;

      if (!inverted && pass && ctx) {
        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var names = key.split('.'),
          val = this.f(names[0], ctx, partials, returnFound),
          cx = null;

      if (key === '.' && isArray(ctx[ctx.length - 2])) {
        return ctx[ctx.length - 1];
      }

      for (var i = 1; i < names.length; i++) {
        if (val && typeof val == 'object' && names[i] in val) {
          cx = val;
          val = val[names[i]];
        } else {
          val = '';
        }
      }

      if (returnFound && !val) {
        return false;
      }

      if (!returnFound && typeof val == 'function') {
        ctx.push(cx);
        val = this.lv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false;

      for (var i = ctx.length - 1; i >= 0; i--) {
        v = ctx[i];
        if (v && typeof v == 'object' && key in v) {
          val = v[key];
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : "";
      }

      if (!returnFound && typeof val == 'function') {
        val = this.lv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ho: function(val, cx, partials, text, tags) {
      var compiler = this.c;
      var options = this.options;
      options.delimiters = tags;
      var text = val.call(cx, text);
      text = (text == null) ? String(text) : text.toString();
      this.b(compiler.compile(text, options).render(cx, partials));
      return false;
    },

    // template result buffering
    b: (useArrayBuffer) ? function(s) { this.buf.push(s); } :
                          function(s) { this.buf += s; },
    fl: (useArrayBuffer) ? function() { var r = this.buf.join(''); this.buf = []; return r; } :
                           function() { var r = this.buf; this.buf = ''; return r; },

    // lambda replace section
    ls: function(val, ctx, partials, inverted, start, end, tags) {
      var cx = ctx[ctx.length - 1],
          t = null;

      if (!inverted && this.c && val.length > 0) {
        return this.ho(val, cx, partials, this.text.substring(start, end), tags);
      }

      t = val.call(cx);

      if (typeof t == 'function') {
        if (inverted) {
          return true;
        } else if (this.c) {
          return this.ho(t, cx, partials, this.text.substring(start, end), tags);
        }
      }

      return t;
    },

    // lambda replace variable
    lv: function(val, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = val.call(cx);

      if (typeof result == 'function') {
        result = coerceToString(result.call(cx));
        if (this.c && ~result.indexOf("{\u007B")) {
          return this.c.compile(result, this.options).render(cx, partials);
        }
      }

      return coerceToString(result);
    }

  };

  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos =/\'/g,
      rQuot = /\"/g,
      hChars =/[&<>\"\']/;


  function coerceToString(val) {
    return String((val === null || val === undefined) ? '' : val);
  }

  function hoganEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp,'&amp;')
        .replace(rLt,'&lt;')
        .replace(rGt,'&gt;')
        .replace(rApos,'&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

  var isArray = Array.isArray || function(a) {
    return Object.prototype.toString.call(a) === '[object Array]';
  };

})(typeof exports !== 'undefined' ? exports : Hogan);





// END WRAPPED CODE
// ===========================================================================
});

define('text',{});
define('hgn',{load: function(id){throw new Error("Dynamic load not allowed: " + id);}});
define("hgn!templates/tracker-js", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<script>");_.b("\n" + i);_.b("  (function(i,s,o,g,r,a,m){i['LivefyreTrackerObject']=r;i[r]=i[r]||function(){");_.b("\n" + i);_.b("  (i[r].q=i[r].q||[]).push(arguments);};a=s.createElement(o),m=s.getElementsByTagName(o)[0];");_.b("\n" + i);_.b("  a.async=true;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script',");_.b("\n" + i);_.b("  '");_.b(_.v(_.f("cdn",c,p,0)));_.b("/libs/tracker-js/v0.1.0/tracker.js','lft');");_.b("\n" + i);_.b("</script>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('streamhub-sdk/content/annotator-extensions',[], function () {
    

    var voteEnums = {};

    /** @enum {number} */
    voteEnums.vote = {
        UNSET: 0,
        UPVOTE: 1,
        DOWNVOTE: 2
    };

    /** @enum {number} */
    voteEnums.voteToCount = {
        0: 0,
        1: 1,
        2: -1
    };

    function downVote (vote) {
        return vote.value === voteEnums.vote.DOWNVOTE ? 1 : 0;
    }

    function upVote (vote) {
        return vote.value === voteEnums.vote.UPVOTE ? 1 : 0;
    }

    function scoreVote (votesObj, vote, priorVote) {
        if (priorVote) {
            votesObj.upvotes -= upVote(priorVote);
            votesObj.downvotes -= downVote(priorVote);
        }
        if (vote) {
            votesObj.upvotes += upVote(vote);
            votesObj.downvotes += downVote(vote);
        }
        votesObj.helpfulness = votesObj.upvotes - votesObj.downvotes;
    }

    function indexOfVote (votes, vote) {
        for (var i = 0, len = votes.length; i < len; i++) {
            if (votes[i].author === vote.author) {
                return i;
            }
        }
        return -1;
    }

    function addVote (changeSet, annotation, content) {
        var vote;
        var votes = content.votes = content.votes || {};
        var list = content.votes.list = content.votes.list || [];
        votes.upvotes = votes.upvotes || 0;
        votes.downvotes = votes.downvotes || 0;
        votes.helpfulness = votes.helpfulness || 0;

        for (var i=0, len=annotation.length; i<len; i++) {
            vote = annotation[i];
            if (indexOfVote(list, vote) > -1) {
                continue;
            }
            list.push(vote);
            scoreVote(votes, vote);
        }

        changeSet.votes = votes;
    }

    function updatedVote (changeSet, annotation, content) {
        var j;
        var vote;
        var updateVote;
        var votes = content.votes;
        var list = content.votes.list;

        for (var i=0, len=list.length; i<len; i++) {
            vote = list[i];
            j = indexOfVote(annotation, vote);
            if (j !== -1) {
                updateVote = annotation[j];
                scoreVote(votes, updateVote, vote);
                list[i] = updateVote;
            }

        }

        changeSet.votes = votes;
    }

    function removedVote (changeSet, annotation, content) {
        var votes = content.votes;
        var list = content.votes.list;

        list = list.filter(function(vote) {
            if (indexOfVote(annotation, vote) !== -1) {
                scoreVote(votes, false, vote);
                return false;
            }
            return true;
        });

        content.votes.list = list;
        changeSet.votes = content.votes;
    }

    function withVotes (annotator) {
        annotator.added.vote = addVote;
        annotator.updated.vote = updatedVote;
        annotator.removed.vote = removedVote;
    }

    return {
        withVotes: withVotes,
        voteEnums: voteEnums
    };
});

define('annotations/controller/analytics',['require','exports','module','jquery','auth','annotations/controller/base','annotations/events','inherits','hgn!templates/tracker-js','streamhub-sdk/content/annotator-extensions'],function (require, exports, module) {/**
 * @fileOverview Analytics controller.
 */

var $ = require('jquery');
var auth = require('auth');
var BaseController = require('annotations/controller/base');
var events = require('annotations/events');
var inherits = require('inherits');
var trackerTemplate = require('hgn!templates/tracker-js');
var voteEnum = require('streamhub-sdk/content/annotator-extensions').voteEnums.vote;

/**
 * Analytics controller.
 * @param {Object} opts Config options.
 */
function AnalyticsController(opts) {
    BaseController.call(this, opts);
    this._initialize();
}
inherits(AnalyticsController, BaseController);

/** @enum {string} */
AnalyticsController.EVENT_TO_STAT_MAP = (function () {
    var map = {};
    // Source events
    map[events.source.ADD_ANNOTATION_CLICK] = ['button', 'click', 'selection thread'];
    map[events.source.SHARE_CLICK] = ['button', 'click', 'selection share'];
    map[events.source.THREAD_BTN_CLICK] = ['button', 'click', 'thread'];
    // User events
    map[events.user.EDIT_PROFILE] = ['button', 'click', 'edit profile'];
    map[events.user.LOGIN] = ['button', 'click', 'login'];
    map[events.user.LOGOUT] = ['button', 'click', 'logout'];
    map[events.user.VIEW_PROFILE] = ['button', 'click', 'view profile'];
    // Write events
    map[events.write.POST_ANNOTATION] = ['comment', 'post'];
    map[events.write.POST_APPROVE] = ['comment', 'approve'];
    map[events.write.POST_DELETE] = ['comment', 'delete'];
    map[events.write.POST_EDIT] = ['comment', 'edit'];
    map[events.write.POST_FLAG] = ['comment', 'flag', null];
    map[events.write.POST_HIDE] = ['comment', 'trash'];
    map[events.write.POST_REPLY] = ['comment', 'reply'];
    map[events.write.POST_SHARE] = ['comment', 'share', null];
    map[events.write.POST_VOTE] = '_handleCommentVote';
    return map;
})();

/**
 * Get the event type from the jQuery event object.
 * @param {jQuery.Event} ev
 * @return {string} The event type.
 */
function getTypeFromEvent(ev) {
    return [ev.type, ev.namespace].join('.');
}

/** @enum {string} */
AnalyticsController.prototype.events = (function () {
    var map = {};
    $.each(AnalyticsController.EVENT_TO_STAT_MAP, function (key, value) {
        map[key] = $.isArray(value) ? '_handleEvent' : value;
    });
    return map;
})();

/**
 * Default handler for events. This will use the stat map to determine what stat
 * to send and will send it.
 * @param {jQuery.Event} ev
 * @param {Object=} opt_data
 * @private
 */
AnalyticsController.prototype._handleEvent = function (ev, opt_data) {
    var data = opt_data || {};
    var stat = AnalyticsController.EVENT_TO_STAT_MAP[getTypeFromEvent(ev)];

    if (data.value === undefined) {
        this._send(stat);
        return;
    }
    this._send($.merge($.merge([], stat), [data.value]));
};

/**
 * Handle the comment vote event.
 * @param {jQuery.Event} ev
 * @param {Object} data
 * @private
 */
AnalyticsController.prototype._handleCommentVote = function (ev, data) {
    function getVoteStr(value) {
        if (value === voteEnum.UPVOTE) {
            return 'like';
        }
        if (value === voteEnum.DOWNVOTE) {
            return 'dislike';
        }
    }

    var vote;
    // If the current value is unset, figure out what it was before and prepend
    // the 'un' prefix to it. Otherwise, use the actual string.
    if (data.value === voteEnum.UNSET) {
        vote = 'un' + getVoteStr(data.lastValue);
    } else {
        vote = getVoteStr(data.value);
    }
    this._send(['comment', vote]);
};

/**
 * Handle the user login event.
 * @private
 */
AnalyticsController.prototype._handleUserLogin = function () {
    var user = auth.get('livefyre');
    var id = user ? user.get('id') : null;
    if (!id) {
        return;
    }
    window['lft']('set', 'userId', id);
    this._send(['login']);
};

/**
 * Handle the user logout event.
 * @private
 */
AnalyticsController.prototype._handleUserLogout = function () {
    window['lft']('set', 'userId', '');
    this._send(['logout']);
};

/**
 * Initialize the analytics library.
 * @private
 */
AnalyticsController.prototype._initialize = function () {
    window['lft'] || this.$antenna.append(trackerTemplate({
        cdn: this._config.servers.cdn
    }));

    var lft = window['lft'];
    lft('set', 'app', 'sidenotes');
    lft('set', 'collectionId', this._collection.id);
    lft('set', 'siteId', this._collection.siteId);
    lft('set', 'networkId', this._collection.networkId);

    auth.on('login.livefyre', $.proxy(this._handleUserLogin, this));
    auth.on('logout', $.proxy(this._handleUserLogout, this));
};

/**
 * Send an event to the tracker.
 * @param {Array.<string>} event The event array to send to the tracker.
 * @private
 */
AnalyticsController.prototype._send = function (event) {
    var lft = window['lft'];
    lft.apply(lft, $.merge(['send', 'event'], event));
};

module.exports = AnalyticsController;

});

define('annotations/models/author',['require','exports','module'],function (require, exports, module) {/**
 * @fileOverview The Author model is used for authors of comments.
 */

/**
 * Author model.
 * @constructor
 */
var Author = function(json) {
    json = json || {};
    /** @type {string} */
    this.avatar = json.avatar || '';
    /** @type {string} */
    this.displayName = json.displayName || '';
    /** @type {string} */
    this.handle = json.handle || '';
    /** @type {string} */
    this.id = json.id || '';
    /** @type {string} */
    this.profileUrl = json.profileUrl || '';
};

module.exports = Author;

});

define('streamhub-sdk/jquery',['jquery'], function($) {
    

    /**
     * Cross domain requests in IE8/9 fail. Here is a patch for that.
     * AJAX POST request on IE fails with error No Transport: http://stackoverflow.com/q/15418290
     */
    if (!$.support.cors && window.XDomainRequest) {
        var httpRegEx = /^https?:\/\//i;
        var getOrPostRegEx = /^get|post$/i;
        var sameSchemeRegEx = new RegExp('^'+location.protocol, 'i');
        var xmlRegEx = /\/xml/i;
        var XDomainRequest = window.XDomainRequest;
        var ActiveXObject = window.ActiveXObject;

        // ajaxTransport exists in jQuery 1.5+
        $.ajaxTransport('text html xml json', function(options, userOptions, jqXHR) {
            // XDomainRequests must be: asynchronous, GET or POST methods, HTTP or HTTPS protocol, and same scheme as calling page
            if (options.crossDomain && options.async && getOrPostRegEx.test(options.type) && httpRegEx.test(userOptions.url) && sameSchemeRegEx.test(userOptions.url)) {
                var xdr = null;
                var userType = (userOptions.dataType||'').toLowerCase();
                
                return {
                    send: function(headers, complete) {
                        xdr = new XDomainRequest();
                        
                        if (/^\d+$/.test(userOptions.timeout)) {
                            xdr.timeout = userOptions.timeout;
                        }
                        
                        xdr.ontimeout = function(){
                            complete(500, 'timeout');
                        };
                        
                        xdr.onload = function() {
                            var allResponseHeaders = 'Content-Length: ' + xdr.responseText.length + '\r\nContent-Type: ' + xdr.contentType;
                            var status = {
                                code: 200,
                                message: 'success'
                            };
                            var responses = {
                                text: xdr.responseText
                            };
    
                            try {
                                if (userType === 'json') {
                                    try {
                                        responses.json = JSON.parse(xdr.responseText);
                                    } catch(e) {
                                        status.code = 500;
                                        status.message = 'parseerror';
                                        //throw 'Invalid JSON: ' + xdr.responseText;
                                    }
                                } else if ((userType === 'xml') || ((userType !== 'text') && xmlRegEx.test(xdr.contentType))) {
                                    var doc = new ActiveXObject('Microsoft.XMLDOM');
                                    doc.async = false;
                                    try {
                                        doc.loadXML(xdr.responseText);
                                    } catch(e) {
                                        doc = undefined;
                                    }
                                    if (!doc || !doc.documentElement || doc.getElementsByTagName('parsererror').length) {
                                        status.code = 500;
                                        status.message = 'parseerror';
                                        throw 'Invalid XML: ' + xdr.responseText;
                                    }
                                    responses.xml = doc;
                                }
                            } catch(parseMessage) {
                                throw parseMessage;
                            } finally {
                                complete(status.code, status.message, responses, allResponseHeaders);
                            }
                        };
                        
                        xdr.onerror = function(){
                            complete(500, 'error', {
                                text: xdr.responseText
                            });
                        };
                        xdr.open(options.type, options.url);

                        xdr.onprogress = function () {};

                        if (userOptions.data && options.type === 'POST') {
                            var data = userOptions.data;
                            if (typeof(data) === 'object') {
                                data = $.param(data);
                            }

                            xdr.send(data);
                        } else {
                            xdr.send();
                        }
                    },
                    abort: function() {
                        if (xdr) {
                            xdr.abort();
                        }
                    }
                };
            }
        });
    }

    return $;
});

define('streamhub-sdk/storage',['streamhub-sdk/jquery', 'event-emitter'], function($, EventEmitter) {
    
    
	/**
	 * A module to use for storing Content objects.
	 * @exports streamhub-sdk/storage
	 */
    var Storage = {
        cache: {}
    };
    EventEmitter.call(Storage);
    $.extend(Storage, EventEmitter.prototype);
    
    /**
     * Gets an object from storage, using sync or async
     * @param key {String} the key lookup
     * @param callback {?function} optional callback to fire in async mode
     * @returns the value at the specified key position
     */
    Storage.get = function(key, callback) {
        var result = this.cache[key];
        if (callback) {
            callback(result);
        } else {
            return result;
        }
    };

    /**
     * Sets an object to a key in storage, using sync or async
     * @param key {String} the key to store this under
     * @param value {Object} the value to store
     * @param callback {?function} optional callback to fire in async mode when complete
     */
    Storage.set = function(key, value, callback) {
        var obj = this.cache[key];
        this.cache[key] = value;
        
        if (obj) {
            this.emit('change', obj, value);
        } else {
            this.emit('add', value);
        }
        
        if (callback) {
            callback(value);
        } else {
            return value;
        }
    };

    return Storage;
});

define('debug',['require','exports','module'],function (require, exports, module) {
/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

});

define('streamhub-sdk/debug',['require','exports','module','debug'],function (require, exports, module) {module.exports = require('debug');

});

define('streamhub-sdk/util',['streamhub-sdk/debug', 'streamhub-sdk/jquery'], function (debug, $) {
    

    var log = debug('util');

    /** 
     * A module containing utility methods.
     * @module streamhub-sdk/util
     */
    var exports = {};

    /**
     * Get outerWidth (jquery-style) of element
     * @deprecated
     */
    exports.outerWidth = function(el) {
        log('Deprecated: util.outerWidth');
        return $(el).outerWidth(true);
    };

    /**
     * Get outerHeight (jquery-style) of element
     * @deprecated
     */
    exports.outerHeight = function(el) {
        log('Deprecated: util.outerHeight');
        return $(el).outerHeight(true);
    };

    /**
     * Get innerWidth (jquery-style) of element
     * @deprecated
     */
    exports.innerWidth = function(el) {
        log('Deprecated: util.innerWidth');
        return $(el).innerWidth();
    };

    /**
     * Get innerHeight (jquery-style) of element
     * @deprecated
     */
    exports.innerHeight = function(el) {
        log('Deprecated: util.innerHeight');
        return $(el).innerHeight();
    };

    /**
     * Format a date object to be displayed to humans
     * @param date {Date} A JavaScript Date object
     * @return {string} A formatted timestamp like "5/27//06  3:26 AM"
     */
    var MONTH_STRINGS = [
        'Jan', 'Feb', 'Mar', 'Apr',
        'May', 'Jun','Jul', 'Aug',
        'Sep', 'Oct', 'Nov', 'Dec'
    ];

    exports.formatDate = function (date, relativeTo) {
        relativeTo = relativeTo || new Date();
        var diffMs = date.getTime() - relativeTo.getTime(),
            dateString;
        // Future
        if (diffMs > 0) {
            return '';
        }
        // Less than 60s ago -> 5s
        if (diffMs > -60 * 1000) {
            return Math.round( -1 * diffMs / 1000) + 's';
        }
        // Less than 1h ago -> 5m
        if (diffMs > -60 * 60 * 1000) {
            return Math.round( -1 * diffMs / (1000 * 60)) + 'm';
        }
        // Less than 24h ago -> 5h
        if (diffMs > -60 * 60 * 24 * 1000) {
            return Math.round( -1 * diffMs / (1000 * 60 * 60)) + 'h';
        }
        // >= 24h ago -> 6 Jul
        dateString = date.getDate() + ' ' + MONTH_STRINGS[date.getMonth()];
        // or like 6 Jul 2012 if the year if its different than the relativeTo year
        if (date.getFullYear() !== relativeTo.getFullYear()) {
            dateString += ' ' + date.getFullYear();
        }
        return dateString;
    };

    exports.objectKeys = Object.keys || (function () {
        var hasOwnProperty = Object.prototype.hasOwnProperty,
            hasDontEnumBug = !{toString:null}.propertyIsEnumerable("toString"),
            DontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ],
            DontEnumsLength = DontEnums.length;

        return function (o) {
            if (typeof o !== "object" && typeof o !== "function" || o === null) {
                throw new TypeError("objectKeys called on a non-object");
            }

            var result = [];
            for (var name in o) {
                if (hasOwnProperty.call(o, name)) {
                    result.push(name);
                }
            }

            if (hasDontEnumBug) {
                for (var i = 0; i < DontEnumsLength; i++) {
                    if (hasOwnProperty.call(o, DontEnums[i])) {
                        result.push(DontEnums[i]);
                    }
                }
            }

            return result;
        };
    })();

    Array.prototype.indexOf = Array.prototype.indexOf || function(val) {
        return $.inArray(val, this);
    };

    return exports;
});

define('stream/main',[
    'inherits',
    'event-emitter'],
function (inherits, EventEmitter) {
    

    /**
     * Base class for all Streams
     */
    function Stream (opts) {
        EventEmitter.call(this);
    }
    inherits(Stream, EventEmitter);

    return Stream;
});
define('stream', ['stream/main'], function (main) { return main; });

define('stream/util',[],function () {
    

    var exports = {};

    exports.nextTick = (function () {
        if (typeof setImmediate == 'function') {
            return function(f){ setImmediate(f); };
        }
        // fallback for other environments / postMessage behaves badly on IE8
        else if (typeof window == 'undefined' || window.ActiveXObject || !window.postMessage) {
            return function(f){ setTimeout(f); };
        } else {
            var q = [];

            window.addEventListener('message', function(){
                var i = 0;
                while (i < q.length) {
                    try { q[i++](); }
                    catch (e) {
                        q = q.slice(i);
                        window.postMessage('tic!', '*');
                        throw e;
                    }
                }
                q.length = 0;
            }, true);

            return function(fn){
                if (!q.length) window.postMessage('tic!', '*');
                q.push(fn);
            };
        }
    }());

    return exports;
});
define('stream/writable',['stream', 'stream/util', 'inherits'], function (Stream, util, inherits) {

    function Writable (opts) {
        this.writable = true;
        this._writableState = new WritableState(opts, this);
        Stream.call(this, opts);
    }

    inherits(Writable, Stream);


    Writable.prototype.write = function (chunk, errback) {
        var state = this._writableState,
            ret = false,
            writeAfterEndErr;

        if (typeof errback !== 'function') {
            errback = function () {};
        }

        if (state.ended) {
            writeAfterEndErr = new Error('.write() called after stream end');
            this.emit('error', writeAfterEndErr);
            util.nextTick(function () {
                errback(writeAfterEndErr);
            });
        } else {
            ret = this._writeOrBuffer(chunk, errback);
        }

        return ret;
    };


    Writable.prototype._writeOrBuffer = function (chunk, errback) {
        var state = this._writableState,
            ret = state.buffer.length < state.highWaterMark;

        state.needDrain = !ret;

        if (state.writing) {
            state.buffer.push(new WriteReq(chunk, errback));
        } else {
            this._doWrite(chunk, errback);
        }

        return ret;
    };


    Writable.prototype._write = function(chunk, errback) {
        errback(new Error('._write not implemented'));
    };


    Writable.prototype._onwrite = function (err) {
        var self = this,
            state = this._writableState,
            sync = state.sync,
            errback = state.writecb,
            finished;

        state.writing = false;
        state.writecb = null;
        state.writelen = 0;

        if (err) {
            if (sync) {
                util.nextTick(function () {
                    errback(err);
                });
            } else {
                errback(err);
            }
            this.emit('error', err);
        } else {
            finished = this._needFinish();
            if ( ! finished && ! state.bufferProcessing && state.buffer.length) {
                this._clearBuffer();
            }

            if (sync) {
                util.nextTick(function () {
                    self._afterWrite(finished, errback);
                });
            } else {
                this._afterWrite(finished, errback);
            }
        }
    };


    Writable.prototype._doWrite = function (chunk, errback) {
        var state = this._writableState;
        state.writelen = 1;
        state.writecb = errback;
        state.writing = true;
        state.sync = true;
        this._write(chunk, state.onwrite);
        state.sync = false;
    };


    Writable.prototype._afterWrite = function (finished, errback) {
        var state = this._writableState;
        if ( ! finished) {
            this._onwriteDrain();
        }
        errback();
        if (finished) {
            this._finishMaybe();
        }
    };


    Writable.prototype._onwriteDrain = function () {
        var state = this._writableState;
        if (state.buffer.length === 0 && state.needDrain) {
            state.needDrain = false;
            this.emit('drain');
        }
    };


    Writable.prototype._clearBuffer = function () {
        var state = this._writableState;

        state.bufferProcessing = true;

        for (var c = 0; c < state.buffer.length; c++) {
            var entry = state.buffer[c];
            var chunk = entry.chunk;
            var cb = entry.callback;
            var len = 1;

            this._doWrite(chunk, cb);

            // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) {
                c++;
                break;
            }
        }

        state.bufferProcessing = false;
        if (c < state.buffer.length) {
            state.buffer = state.buffer.slice(c);
        } else {
            // Clear the buffer
            state.buffer.length = 0;
        }
    };


    Writable.prototype.pipe = function () {
        this.emit('error', new Error('Cannot pipe. Not readable'));
    };


    Writable.prototype.end = function (chunk, errback) {
        var state = this._writableState;

        // If only passed an errback
        if (typeof chunk === 'function') {
            errback = chunk;
            chunk = null;
        }

        // If passed a chunk
        if (typeof chunk !== 'undefined' && chunk !== null) {
            this.write(chunk);
        }

        // Ignore extra .end() calls
        if ( ! state.ending && ! state.finished) {
            // Shut it down
            state.ending = true;
            this._finishMaybe();
            if (errback) {
                if (state.finished) {
                    util.nextTick(errback);
                } else {
                    this.once('finish', errback);
                }
            }
            state.ended = true;
        }
    };


    /**
     * @private
     */
    Writable.prototype._finishMaybe = function () {
        var state = this._writableState,
            needToFinish = this._needFinish();
        if (needToFinish) {
            state.finished = true;
            this.emit('finish');
        }
        return needToFinish;
    };


    /**
     * @private
     */
    Writable.prototype._needFinish = function () {
        var state = this._writableState;
        return (state.ending &&
                state.buffer.length === 0 &&
                ! state.finished &&
                ! state.writing);
    };


    function WriteReq(chunk, cb) {
        this.chunk = chunk;
        this.callback = cb;
    }


    /**
     * From https://github.com/isaacs/readable-stream/blob/c547457903406fdb9b5c621501c55eced48cae82/lib/_stream_writable.js#L41
     */
    function WritableState (opts, stream) {
        opts = opts || {};

        // the point at which write() starts returning false
        // Note: 0 is a valid value, means that we always return false if
        // the entire buffer is not flushed immediately on write()
        var hwm = opts.highWaterMark;
        this.highWaterMark = (hwm || hwm === 0) ? hwm : 0;

        // object stream flag to indicate whether or not this stream
        // contains buffers or objects.
        this.objectMode = !!opts.objectMode;

        // cast to ints.
        this.highWaterMark = ~~this.highWaterMark;

        this.needDrain = false;
        // at the start of calling end()
        this.ending = false;
        // when end() has been called, and returned
        this.ended = false;
        // when 'finish' is emitted
        this.finished = false;

        // should we decode strings into buffers before passing to _write?
        // this is here so that some node-core streams can optimize string
        // handling at a lower level.
        var noDecode = opts.decodeStrings === false;
        this.decodeStrings = !noDecode;

        // Crypto is kind of old and crusty.  Historically, its default string
        // encoding is 'binary' so we have to make this configurable.
        // Everything else in the universe uses 'utf8', though.
        this.defaultEncoding = opts.defaultEncoding || 'utf8';

        // not an actual buffer we keep track of, but a measurement
        // of how much we're waiting to get pushed to some underlying
        // socket or file.
        this.length = 0;

        // a flag to see when we're in the middle of a write.
        this.writing = false;

        // a flag to be able to tell if the onwrite cb is called immediately,
        // or on a later tick.  We set this to true at first, becuase any
        // actions that shouldn't happen until "later" should generally also
        // not happen before the first write call.
        this.sync = true;

        // a flag to know if we're processing previously buffered items, which
        // may call the _write() callback in the same tick, so that we don't
        // end up in an overlapped onwrite situation.
        this.bufferProcessing = false;

        // the callback that's passed to _write(chunk,cb)
        this.onwrite = function(er) {
            stream._onwrite(er);
        };

        // the callback that the user supplies to write(chunk,encoding,cb)
        this.writecb = null;

        // the amount that is being written when _write is called.
        this.writelen = 0;

        this.buffer = [];
    }

    Writable.WritableState = WritableState;
    return Writable;
});
define('streamhub-sdk/content/annotator',[
    'streamhub-sdk/storage',
    'streamhub-sdk/util',
    'stream/writable',
    'inherits'
], function (Storage, util, Writable, inherits) {
    

    /**
     * An Object that updates Content when changes are streamed.
     */
    var Annotator = function (opts) {
        opts = opts || {};
        Writable.call(this, opts);
    };

    inherits(Annotator, Writable);

    /**
     * @param content {Content}
     * @param annotationDiff {object} A set of 'added', 'updated', and 'removed' annotations.
     * @param silence [boolean] Mute any events that would be fired
     */
    Annotator.prototype.annotate = function (content, annotationDiff, silence) {
        var annotation;
        var annotations;
        var annotationType;
        var changeSet = {};
        var handleFunc;
        var verb;

        for (verb in annotationDiff) {
            if ( ! annotationDiff.hasOwnProperty(verb)) {
                continue;
            }
            annotations = annotationDiff[verb];
            if ( ! util.objectKeys(annotations).length) {
                continue;
            }

            for (annotationType in annotations) {
                if ( ! annotations.hasOwnProperty(annotationType)) {
                    continue;
                }
                annotation = annotations[annotationType];
                handleFunc = this[verb][annotationType];
                handleFunc && handleFunc(changeSet, annotation, content);
            }
        }

        content.set(changeSet, silence);
    };

    /**
     * @param opts {object}
     * @param opts.contentId [string]
     * @param opts.content {Content}
     * @param opts.annotationDiff {object} A set of 'added', 'updated', and 'removed' annotations.
     * @param opts.silence [boolean] Mute any events that would be fired
     */
    Annotator.prototype._write = function(opts) {
        var content = opts.content || Storage.get(opts.contentId);
        if (!content) {
            return;
        }
        this.annotate(content, opts.annotationDiff, opts.silence);
    };

    /**
     * AnnotationTypes
     * featuredmessage
     * moderator
     */

    /**
     * AnnotationVerbs
     */
    Annotator.prototype.added = {};
    Annotator.prototype.updated = {};
    Annotator.prototype.removed = {};

    // featuredmessage

    Annotator.prototype.added.featuredmessage = function (changeSet, annotation) {
        changeSet.featured = annotation;
    };

    Annotator.prototype.updated.featuredmessage = Annotator.prototype.added.featuredmessage;

    Annotator.prototype.removed.featuredmessage = function (changeSet, annotation, content) {
        changeSet.featured = false;
    };

    // sort order

    Annotator.prototype.added.sortOrder = function (changeSet, annotation) {
        changeSet.sortOrder = annotation;
    };

    Annotator.prototype.updated.sortOrder = function (changeSet, annotation, content) {
        changeSet.sortOrder = annotation;
    };

    Annotator.prototype.removed.sortOrder = function (changeSet, annotation, content) {
        changeSet.sortOrder = null;
    };

    // moderator

    Annotator.prototype.added.moderator = function(changeSet) {
        changeSet.moderator = true;
    };

    Annotator.prototype.removed.moderator = function(changeSet) {
        changeSet.moderator = false;
    };

    Annotator.prototype.added.geocode = function (changeSet, annotationValue) {
        changeSet.geocode = annotationValue;
    };

    return Annotator;
});

define('annotations/adapters/commentannotator',['require','exports','module','streamhub-sdk/content/annotator','streamhub-sdk/content/annotator-extensions','inherits'],function (require, exports, module) {/**
 * @fileoverview CommentAnnotator A subclass of the Content Annotator with extensions for
 * handling stream annotations that are specific to Annotations Comments.
 */

var Annotator = require('streamhub-sdk/content/annotator');
var AnnotatorExtensions = require('streamhub-sdk/content/annotator-extensions');
var inherits = require('inherits');

function addAnnotationInfo (changeSet, annotation) {
    changeSet.blockId = annotation.blockId;
    changeSet.selectedText = annotation.selectedText || null;
}

function withAnnotations (annotator) {
    annotator.added.annotation = addAnnotationInfo;
}

var CommentAnnotator = function() {
    Annotator.call(this);
    AnnotatorExtensions.withVotes(this);
    withAnnotations(this);
};
inherits(CommentAnnotator, Annotator);

module.exports = CommentAnnotator;

});

define('streamhub-sdk/content/main',[
    'streamhub-sdk/jquery',
    'event-emitter',
    'inherits'
], function($, EventEmitter, inherits, Enums) {
    

    /**
     * A piece of Web Content
     * @param body {!string|{body: string}} A string of HTML, the Content body.
     *     If an object, it should have a .body property
     * @fires Content#attachment
     * @fires Content#removeAttachment
     * @exports streamhub-sdk/content
     * @constructor
     */
    var Content = function(bodyOrObj) {
        var body = bodyOrObj;
        var obj = {};
        EventEmitter.call(this);
        if (typeof bodyOrObj === 'object') {
            body = body.body;
            obj = bodyOrObj;
        }
        this.body = body;
        var vis = (typeof obj.visibility === 'number') ? obj.visibility :
            (typeof obj.vis === 'number') ? obj.vis : 1;
        this.visibility = Content.enums.visibility[vis];
        this.attachments = obj.attachments || [];
        this.replies = obj.replies || [];
        this.opines = obj.opines || [];
    };
    inherits(Content, EventEmitter);

    Content.prototype.typeUrn = 'urn:livefyre:js:streamhub-sdk:content';

    /**
     * Attach an Oembed to the Content
     * @param obj {Oembed} An Oembed Content instance to attach
     * @fires Content#attachment
     */
    Content.prototype.addAttachment = function(obj) {
        this.attachments.push(obj);
        this.emit('attachment', obj);
    };

    /**
     * Remove an Oembed from the Content
     * @param obj {Oembed} An Oembed Content instance to attach
     * @fires Content#removeAttachment
     */
    Content.prototype.removeAttachment = function(obj) {
        this.attachments.splice(this.attachments.indexOf(obj), 1);
        this.emit('removeAttachment', obj);
    };

    /**
     * Add a reply to the Content
     * @param obj {Content} A piece of Content in reply to this one
     * @fires Content#addReply
     */
    Content.prototype.addReply = function(obj) {
        this.replies.push(obj);
        this.emit('reply', obj);
    };

    /**
     * Set some properties and emit 'change' and 'change:{property}' events
     * @param newProperties {Object} An object of properties to set on this Content
     * @param silence [boolean] Mute any events that would be fired
     * @fires Content#change
     * @fires Content#event:change:_property_
     */
    Content.prototype.set = function (newProperties, silence) {
        newProperties = newProperties || {};
        var oldProperties = {};
        var oldVal, newVal, changed;
        for (var key in newProperties) {
            if (newProperties.hasOwnProperty(key) && key.charAt(0) !== '_') {//ignore _listeners and others
                oldVal = oldProperties[key] = this[key];
                newVal = this[key] = newProperties[key];
                if (newVal !== oldVal || typeof newVal === 'object') {
                    silence || this.emit('change:'+key, newVal, oldVal);//Will emit 'change:visibility'
                    changed = true;
                }
            }
        }
        if (changed) {
            silence || this.emit('change', newProperties, oldProperties);
        }
    };

    Content.enums = {};
    /**
     * The StreamHub APIs use enumerations to define
     * the visibility of messages sent down the wire. All levels of
     * visibility should be in this enumeration.
     * @enum visibility
     * @property {string} visibility.NONE - Should not be displayed.
     * @property {string} visibility.EVERYONE - Visible to all.
     * @property {string} visibility.OWNER - Visible only to the author.
     * @property {string} visibility.GROUP - Visible to privileged users.
     */
    Content.enums.visibility = [
        'NONE',
        'EVERYONE',
        'OWNER',
        'GROUP'
    ];

    return Content;
});

define('streamhub-sdk/content', ['streamhub-sdk/content/main'], function (main) { return main; });

define('streamhub-sdk/content/types/livefyre-opine',[
    'streamhub-sdk/jquery',
    'streamhub-sdk/content',
    'inherits'
], function ($, Content, inherits) {
    

    var LivefyreOpine = function (json, opts) {
       opts = opts || {};
       Content.call(this, this);

        if (json && json.type !== 1) {
            throw new Error("Opines must be constructed with .type == 1 ");
        }

        json = json || {};

        $.extend(this, json);

        // TODO(ryanc): In v3.0 bootstrap, all opines are Likes,
        // this may change in v3.1 bootstrap
        // (https://github.com/Livefyre/lfpb/blob/master/src/lfpb/facts/content.proto#L227-L258)
        if (opts.opineType === undefined) {
            this.relType = LivefyreOpine.enums.type.indexOf('LIKE');
        }
    };
    inherits(LivefyreOpine, Content);

    LivefyreOpine.enums = {};
    LivefyreOpine.enums.type = [
        'LIKE',
        'FLAG_OFFENSIVE',
        'FLAG_SPAM',
        'FLAG_DISAGREE',
        'FLAG_OFF_TOPIC',
        'FLAG_PROFANE',
        undefined,
        undefined,
        undefined,
        undefined,
        'ANNOTATION',
        'MODERATION_REASON',
        'IS_SPAM_CONTENT',
        'IS_NOT_SPAM_CONTENT'
    ];

    return LivefyreOpine;
});

define('streamhub-sdk/content/types/livefyre-content',[
    'streamhub-sdk/jquery',
    'streamhub-sdk/content',
    'streamhub-sdk/content/annotator',
    'streamhub-sdk/content/types/livefyre-opine',
    'inherits'],
function($, Content, Annotator, LivefyreOpine, inherits) {
    

    /**
     * Base class for any piece of Livefyre content. Extracts the details of the content
     * from the json object passed in via the Livefyre stream.
     * @param json {!Object} An object obtained via a Livefyre stream that represents the
     *        state of the content.
     * @param json.body {!string}
     * @param json.id {!number}
     * @param opts {object}
     * @param opts.annotator {Annotator}
     * @exports streamhub-sdk/content/types/livefyre-content
     * @constructor
     */
    var LivefyreContent = function(json, opts) {
        opts = opts || {};
        Content.call(this);

        this._likes = 0;
        this._annotator = opts.annotator || this._createAnnotator();

        // Set state from Livefyre API JSON if provided
        if (json) {
            json.content = json.content || {};
            json.content.annotations = json.content.annotations || {};

            this.id = json.content.id || json.id;
            this.author = json.author;
            this.createdAt = new Date(1000 * json.content.createdAt);
            this.updatedAt = new Date(1000 * json.content.updatedAt);
            this.lastVisibility = Content.enums.visibility[json.lastVis];
            this.visibility = Content.enums.visibility[json.vis];
            this.parentId = json.content.parentId;
            this.meta = json;
            this._annotator.annotate(this, {
                added: json.content.annotations
            }, true);  // Silently add b/c this is new Content.
        }

        this.body = json ? json.content.bodyHtml : '';
        this.source = json ? LivefyreContent.SOURCES[json.source] : 'livefyre';
    };
    inherits(LivefyreContent, Content);

    LivefyreContent.prototype.typeUrn = 'urn:livefyre:js:streamhub-sdk:content:types:livefyre';

    /**
     * Overridable annotator instantiator
     */
    LivefyreContent.prototype._createAnnotator = function() {
        return new Annotator();
    };

    /**
     * Attach an Oembed to the Content while first checking for an existing attachment.
     * @param obj {Oembed} An Oembed Content instance to attach
     * @fires Content#attachment
     */
    LivefyreContent.prototype.addAttachment = function(obj) {
        var found = false;
        if (obj.id) {
            for (var i in this.attachments) {
                if (this.attachments[i].id === obj.id) {
                    found = true;
                }
            }
        }
        if (!found) {
            this.attachments.push(obj);
            this.emit('attachment', obj);
        }
    };

    /**
     * Add a reply to the Content while first checking for an existing reply.
     * @param obj {Content} A piece of Content in reply to this one
     * @fires Content#reply
     */
    LivefyreContent.prototype.addReply = function(obj) {
        var found = false;
        if (obj.id) {
            for (var i in this.replies) {
                if (this.replies[i].id === obj.id) {
                    found = true;
                }
            }
        }
        if (!found) {
            this.replies.push(obj);
            this.emit('reply', obj);
        }
    };

    /**
     * Add a opine to the Content while first checking for an existing opine.
     * @param obj {Content} A piece of Content in reply to this one
     * @fires Content#opine
     */
    LivefyreContent.prototype.addOpine = function(obj) {
        if (obj.vis === 0) {
            this.removeOpine(obj);
            return;
        }

        var found = false;
        if (obj.id) {
            for (var i=0; i < this.opines.length; i++) {
                if (this.opines[i].id === obj.id) {
                    found = true;
                }
            }
        } else {
            for (var i=0; i < this.opines.length; i++) {
                if (this.opines[i].content.id === obj.content.id) {
                    found = true;
                }
            }
        }

        if (!found) {
            this.opines.push(obj);
            if (obj.relType === LivefyreOpine.enums.type.indexOf('LIKE')) {
                this._likes++;
            }
            this.emit('opine', obj);
        }
    };

    /**
     * Remove an Opine from the LivefyreContent
     * @param obj {Oembed} An LivefyreOpine instance to remove
     * @fires Content#removeOpine
     */
    LivefyreContent.prototype.removeOpine = function(obj) {
        var indexToRemove = null;
        if (obj.id) {
            for (var i=0; i < this.opines.length; i++) {
                if (this.opines[i].id === obj.id) {
                    indexToRemove = i;
                    break;
                }
            }
        } else {
            for (var i=0; i < this.opines.length; i++) {
                if (this.opines[i].content.id === obj.content.id) {
                    indexToRemove = i;
                    break;
                }
            }
        }
        if (indexToRemove === null) {
            return;
        }
        this.opines.splice(indexToRemove, 1);
        this._likes--;
        this.emit('removeOpine', obj);
    };

    LivefyreContent.prototype.getLikeCount = function () {
        return this._likes;
    };

    LivefyreContent.prototype.isLiked = function (authorId) {
        for (var i=0; i < this.opines.length; i++) {
            if (authorId === this.opines[i].author.id) {
                return true;
            }
        }
        return false;
    };

    /**
     * Return whether this Content is featured in a StreamHub Collection
     * @return {boolean}
     */
    LivefyreContent.prototype.isFeatured = function () {
        return Boolean(this.featured);
    };

    /**
     * Return the featured value for this Content, if it is featured
     * @return {Number|undefined} The featured value, if featured, else undefined
     */
    LivefyreContent.prototype.getFeaturedValue = function () {
        if (!this.isFeatured()) {
            return undefined;
        }
        return this.featured.value;
    };

    /**
     * The set of sources as defined by Livefyre's Stream API
     */
    LivefyreContent.SOURCES = [
        "livefyre",    // 0
        "twitter",     // 1
        "twitter",     // 2
        "facebook",    // 3
        "livefyre",    // 4
        "livefyre",    // 5
        "facebook",    // 6
        "twitter",     // 7
        "livefyre",    // 8
        "unknown",
        "unknown",
        "unknown",
        "unknown",
        "feed",        // 13
        "facebook",    // 14
        "unknown",
        "unknown",
        "unknown",
        "unknown",
        "instagram",   // 19
        "twitter",     // 20
        "facebook"     // 21
    ];

    return LivefyreContent;
});

define('annotations/enums',['require','exports','module','streamhub-sdk/content'],function (require, exports, module) {var visibilityEnum = require('streamhub-sdk/content').enums.visibility;

/** @type {Object} */
var enums = {};

/**
 * Comment visibility enum.
 * @enum {string}
 */
enums.commentVisibility = {
    NONE: visibilityEnum[0],        // Deleted
    EVERYONE: visibilityEnum[1],    // Visible
    OWNER: visibilityEnum[2],       // Bozo
    GROUP: visibilityEnum[3]        // Pending
};

/**
 * Navigable views enum. These are all of the possible navigation options.
 * @enum {string}
 */
enums.navigableViews = {
    AUTH: 'auth',
    CONFIRM: 'confirm',
    EDIT: 'edit',
    EDITOR: 'editor',
    ETC: 'etc',
    FLAG: 'flag',
    INFO: 'info',
    REPLIES: 'commentreplies',
    SHARE: 'share',
    THREAD: 'thread',
    USER: 'user'
};

module.exports = enums;

});

define('annotations/models/comment',['require','exports','module','auth','annotations/adapters/commentannotator','inherits','streamhub-sdk/content/types/livefyre-content','annotations/enums'],function (require, exports, module) {/**
 * @fileOverview The comment model for thread comments.
 */

var auth = require('auth');
var CommentAnnotator = require('annotations/adapters/commentannotator');
var inherits = require('inherits');
var LivefyreContent = require('streamhub-sdk/content/types/livefyre-content');
var visEnums = require('annotations/enums').commentVisibility;

/**
 * Comment model.
 * @constructor
 * @extends {LivefyreContent}
 * @param {Object} opts
 */
function Comment (opts) {
    opts = opts || {};
    /** @type {?string} */
    this.blockId = null;
    /** @type {?string} */
    this.collectionId = opts.collectionId;
    /** @type {boolean} */
    this.hasBeenRendered = false;
    /** @type {number} */
    this.lastCount = 0;
    /** @type {enums.origin} */
    this.origin = opts.origin || Comment.ORIGIN.UNKNOWN;
    /** @type {?string} */
    this.permalink = null;
    /** @type {?string} */
    this.selectedText = null;
    /** @type {?Array} */
    this.votes = {
        /** @type {number} */
        upvotes: 0,
        /** @type {number} */
        downvotes: 0,
        /** @type {number} */
        helpfulness: 0,
        /** @type {Array.<Vote>} */
        list: []
    };
    /** @type {?Array} */
    this.erefs = opts.erefs || null;
    /** @type {number} */
    this.replyCount = 0;
    LivefyreContent.call(this, opts);
}
inherits(Comment, LivefyreContent);

/** @enum {number} */
Comment.ORIGIN = {
    UNKNOWN: 0,
    BOOTSTRAP: 1,
    STREAM: 2
};

/**
 * Calculate whether the vis argument is visible for the current user.
 * @param {string} vis
 * @return {boolean}
 */
Comment.prototype._calculateVisibility = function (vis) {
    var user = auth.get('livefyre');
    var isAuthor = this.isUserAuthor();
    var isMod = user && user.isMod({ collectionId: this.collectionId });
    switch (vis) {
        case visEnums.EVERYONE:
            return true;
        case visEnums.OWNER:
            return isAuthor;
        case visEnums.GROUP:
            return isAuthor || isMod;
        default:
            return false;
    }
};

/** @override */
Comment.prototype._createAnnotator = function () {
    return new CommentAnnotator();
};

/**
 * Calculate the increment number for block counts. This is calculated based
 * on the lastVis and vis of the comment.
 * @return {number} Increment amount.
 */
Comment.prototype.calculateCountIncrement = function () {
    var isVisible = this._calculateVisibility(this.visibility);
    var wasVisible = this._calculateVisibility(this.lastVisibility);
    var notVisToVis = !wasVisible && isVisible;
    var visToNotVis = wasVisible && !isVisible;
    var count = notVisToVis ? 1 : visToNotVis ? -1 : 0;
    var inc = count === this.lastCount ? 0 : count;

    // Since we're trying to match the current increment to the last increment
    // to avoid dupes, setting the lastCount to 0 would mean that there was no
    // last count, which would allow dupes in the future. Should only use 1 or
    // -1 as values.
    if (inc !== 0) {
        this.lastCount = inc;
    }
    return inc;
};

/** @returns {boolean} */
Comment.prototype.isPending = function () {
    return this.visibility === visEnums.GROUP;
};

/**
 * Is the user the author of the comment?
 * @param {Author|LivefyreUser=} opt_author
 * @return {boolean}
 */
Comment.prototype.isUserAuthor = function (opt_author) {
    var user = auth.get('livefyre');
    var authorId = opt_author ? opt_author.id : user ? user.get('id') : null;
    return this.author.id === authorId;
};

/** @returns {boolean} */
Comment.prototype.isVisible = function () {
    return this._calculateVisibility(this.visibility);
};

module.exports = Comment;

});

define('annotations/util/internals',['require','exports','module'],function (require, exports, module) {/** @type {Object} */
var util = {};

/**
 * Abstract method
 */
util.abstractMethod = function () {
    throw 'This function must be overridden';
};

/**
 * Debounce a function. That is, don't allow it to fire on every single request.
 * @param {function()} fn The function to debounce.
 * @param {number} delay The amount of time to let it sit between calls.
 * @param {boolean} initialDelay Invoke immediately or have a delay before the first invocation.
 */
util.debounce = function (fn, delay, initialDelay) {
    var skip = false;
    return function () {
        if (skip) return;
        skip = true;
        setTimeout(function () {
            skip = false;
            initialDelay && fn.call(this);
        }, delay);
        !initialDelay && fn.call(this);
    };
};

/**
 * Memoize a function. That is, only run the function once and cache the result
 * so that it doesn't have to keep calculating it.
 * @param {function()} fn The function to memoize.
 * @return {function()} The memoized function.
 */
util.memoize = function (fn) {
    return function() {
        var value = fn.call(this);
        fn = function () {
            return value;
        };
        return value;
    };
};

/**
 * Null function.
 */
util.nullFunction = function () {};

module.exports = util;

});

define('streamhub-sdk/content/types/twitter-content',['streamhub-sdk/content', 'inherits'], function(Content, inherits) {
    
    
    /**
     * A base class that represents any piece of twitter content. This constructor saves the
     * "tweetId" property of the json object to "this".
     * @param json {Object} An object obtained via a Livefyre stream that represents the
     *        state of the content.
     * @exports streamhub-sdk/content/types/twitter-content
     * @constructor
     */
    var TwitterContent = function (json) {
        Content.call(this, this);
        json = json || {};
        this.tweetId = json.tweetId;
    };
    inherits(TwitterContent, Content);

    return TwitterContent;
});

define('streamhub-sdk/content/types/livefyre-twitter-content',[
    'streamhub-sdk/jquery',
    'streamhub-sdk/content/types/twitter-content',
    'streamhub-sdk/content/types/livefyre-content',
    'inherits'
], function($, TwitterContent, LivefyreContent, inherits) {
    

    /**
     * A tweet constructed from a StreamHub state response from a twitter source
     * @param json {Object} A state response from a StreamHub API
     * @param json.id {String} A Livefyre Message ID for this Content
     * @param [json.author.id] {String} A Livefyre Author ID for the tweeter
     * @exports streamhub-sdk/content/types/livefyre-twitter-content
     * @constructor
     */
    var LivefyreTwitterContent = function (json) {
        LivefyreContent.call(this, json);
        this.tweetId = LivefyreTwitterContent.tweetIdFromLivefyreId(this.id);
        if (this.author) {
            this.author.twitterUserId = LivefyreTwitterContent.twitterUserIdFromLivefyreAuthorId(this.author.id);
        }
        this.twitterVerified = LivefyreTwitterContent.isVerified(this.meta);
    };
    inherits(LivefyreTwitterContent, LivefyreContent);

    LivefyreTwitterContent.prototype.typeUrn = 'urn:livefyre:js:streamhub-sdk:content:types:livefyre-twitter';

    /**
     * Determine if the author of the content is verified by Twitter.
     * @param {Object} json The content to look through for the verified status.
     * @return {Boolean} Whether the author is verified or not.
     */
    LivefyreTwitterContent.isVerified = function (json) {
        var tweetMeta = json.content.annotations.tweetMeta || {};
        return tweetMeta.verified_user || false;
    };

    /**
     * Transform a Livefyre Message ID to a Twitter tweet id
     * @param livefyreId {String} A Livefyre Message ID
     * @throws {Error} If livefyreId cannot be parsed
     * @return {String} A tweet ID
     */
    LivefyreTwitterContent.tweetIdFromLivefyreId = function (livefyreId) {
        var pattern = /tweet-(\d+)@twitter.com/,
            match = livefyreId.match(pattern);
        if ( ! match) {
            throw new Error("Can't parse tweet ID from Livefyre ID");
        }
        return match[1];
    };

    /**
     * Transform a Livefyre authorId to a Twitter user id
     * @param authorId {String} A Livefyre authorId
     * @throws {Error} If authorId cannot be parsed
     * @return {String} A Twitter user id if parseable
     */
    LivefyreTwitterContent.twitterUserIdFromLivefyreAuthorId = function (authorId) {
        var pattern = /([^@]+)@twitter.com/,
            match = authorId.match(pattern);
        if ( ! match) {
            throw new Error("Can't parse twitterUserId from Livefyre authorId");
        }
        return match[1];
    };

    return LivefyreTwitterContent;
 });

define('streamhub-sdk/content/types/livefyre-facebook-content',[
    'streamhub-sdk/jquery',
    'streamhub-sdk/content/types/livefyre-content',
    'inherits'
], function($, LivefyreContent, inherits) {
    

    /**
     * Represents a piece of Livefyre's content curated from Facebook.
     * @param json {Object} An object obtained via a Livefyre stream that represents the
     *        state of the content.
     * @exports streamhub-sdk/content/types/livefyre-facebook-content
     * @constructor
     */
    var LivefyreFacebookContent = function (json) {
        var bodyEl;

        LivefyreContent.call(this, json);

        // There may be times when Facebook content is just a string with no HTML.
        // Sizzle may throw an error, so wrap any parsing to avoid these errors.
        try {
            var bodyEl = $(this.body);
        } catch(e) {
            // This will happen a lot. Pass
        }

        if (bodyEl && bodyEl.length) {
            bodyEl.find('.fyre-image, .fyre-link').remove();
            this.body = outerHtml(bodyEl);
        }
    };
    inherits(LivefyreFacebookContent, LivefyreContent);

    LivefyreFacebookContent.prototype.typeUrn = 'urn:livefyre:js:streamhub-sdk:content:types:livefyre-facebook';

    /**
     * Get a jQuery Element as HTML
     */
    function outerHtml ($el) {
        var $tmp = $('<div></div>');
        $tmp.append($el);
        return $tmp.html();
    }

    return LivefyreFacebookContent;
});

define('streamhub-sdk/content/types/oembed',[
    'streamhub-sdk/jquery',
    'streamhub-sdk/content',
    'inherits'],
function($, Content, inherits) {
    

    /**
     * An Oembed Object. As specified by http://oembed.com/
     * @param json {Object} An Oembed-valid Object
     * @exports streamhub-sdk/content/types/oembed
     * @constructor
     */
    var Oembed = function(json) {
        Content.call(this, this);
        // @todo set a .body property that can be used to embed standard HTML easily

        if (json && Oembed.types.indexOf(json.type) === -1) {
            throw new Error("Oembeds must be constructed with .type in "+Oembed.types);
        }

        json = json || {};

        $.extend(this, json);

        if (typeof this.html !== 'undefined' && $.trim(this.html) === "") {
            this.html = null;
        }
    };
    inherits(Oembed, Content);

    Oembed.types = ['photo', 'video', 'link', 'rich'];
    Oembed.properties = ['type', 'version', 'title', 'author_name', 'author_url',
        'provider_name', 'provider_url', 'cache_age', 'thumbnail_url', 'thumbnail_width',
        'thumbnail_height', 'url', 'width', 'height', 'html'];

    /**
     * Get a raw JSON Object that is valid oEmbed v1.0
     * It will not be an instance of Oembed
     */
    Oembed.prototype.toJSON = function () {
        var self = this,
            oembedJson = {};
        $.each(Oembed.properties, function (index, property) {
            if (typeof self[property] !== 'undefined') {
                oembedJson[property] = self[property];
            }
        });
        return oembedJson;
    };

    return Oembed;
 });

define('streamhub-sdk/content/types/livefyre-oembed',[
    'streamhub-sdk/jquery',
    'streamhub-sdk/content/types/oembed',
    'streamhub-sdk/content/types/livefyre-content',
    'inherits'],
function($, Oembed, LivefyreContent, inherits) {
    

    /**
     * An Oembed constructed from a StreamHub state of oEmbed type
     * @param json {Object} A state object from StreamHub APIs
     * @param json.content.oembed {Object} An Object conforming to the oEmbed spec
     * @exports streamhub-sdk/content/types/livefyre-oembed
     * @constructor
     */
    var LivefyreOembed = function(json) {
        LivefyreContent.call(this, json);
        Oembed.call(this, json.content.oembed);
        
        if (this.provider_name === "Facebook" && this.url &&
            this.thumbnail_url && (this.html === "" || this.html === null)) {
            this.html = "<a href='"+this.url+"' target='_blank'/><img src='"+this.thumbnail_url+"'/></a>";
        }
    };
    inherits(LivefyreOembed, Oembed);
    $.extend(LivefyreOembed.prototype, LivefyreContent.prototype);

    return LivefyreOembed;
});

define('streamhub-sdk/content/types/livefyre-instagram-content',[
    'streamhub-sdk/content/types/livefyre-content', 'inherits'],
function(LivefyreContent, inherits) {
    

    /**
     * An instagram Content constructed from a StreamHub state of of 'feed' type
     *     that was transformed by lfcore.v2.procurement.feed.transformer.instagram
     * @param json {Object} A state object from StreamHub APIs
     * @exports streamhub-sdk/content/types/livefyre-instagram-content
     * @constructor
     */
    var LivefyreInstagramContent = function(json) {
        LivefyreContent.call(this, json);
    };
    inherits(LivefyreInstagramContent, LivefyreContent);

    LivefyreInstagramContent.prototype.typeUrn = 'urn:livefyre:js:streamhub-sdk:content:types:livefyre-instagram';

    return LivefyreInstagramContent;
});

define('stream/readable',['stream', 'stream/util', 'event-emitter', 'inherits'],
function (Stream, util, EventEmitter, inherits) {
    

    /**
     * Base class for Readable Streams
     * @constructor
     * @param [opts] {object} Configuration options
     * @param [opts.highWaterMark=0] {number} The maximum number of objects to
     *     store in the internal buffer before ceasing to read from upstream
     */
    function Readable (opts) {
        opts = opts || {};
        // This Readable implementation only supports objectMode
        opts.objectMode = true;
        this._readableState = new ReadableState(opts, this);

        this.readable = true;
        Stream.call(this);
    }
    inherits(Readable, Stream);


    /**
     * Pulls all the data out of this readable stream, and writes it to the
     * supplied destination, automatically managing the flow so that the
     * destination is not overwhelmed by a fast readable stream.
     * @param dest {Writable} A writable stream that should be written to
     * @param [pipeOpts] {object} Pipe options
     * @param [pipeOpts.end=true] {boolean} Whether the writer should be ended
     *     when the reader ends
     */
    Readable.prototype.pipe = function (dest, pipeOpts) {
        var src = this,
            state = this._readableState,
            doEnd,
            endFn;

        state.pipes.push(dest);

        doEnd = ( ! pipeOpts || pipeOpts.end !== false );

        endFn = doEnd ? onend : cleanup;

        if (state.endEmitted) {
            util.nextTick(endFn);
        } else {
            src.once('end', endFn);
        }

        dest.on('unpipe', onunpipe);
        function onunpipe (readable) {
            // Only if the unpipe was for this readable
            if (readable === src) {
                // Cleanup listeners when unpiped
                cleanup();
            }
        }

        // End the writable destination
        function onend () {
            dest.end();
        }

        // when the dest drains, it reduces the awaitDrain counter
        // on the source.  This would be more elegant with a .once()
        // handler in flow(), but adding and removing repeatedly is
        // too slow.
        var ondrain = this._pipeOnDrain();
        dest.on('drain', ondrain);

        function cleanup() {
            // cleanup event handlers once the pipe is broken
            dest.removeListener('close', onclose);
            dest.removeListener('finish', onfinish);
            dest.removeListener('drain', ondrain);
            dest.removeListener('error', onerror);
            dest.removeListener('unpipe', onunpipe);
            src.removeListener('end', onend);
            src.removeListener('end', cleanup);
            src.removeListener('data', ondata);

            // if the reader is waiting for a drain event from this
            // specific writer, then it would cause it to never start
            // flowing again.
            // So, if this is awaiting a drain, then we just call it now.
            // If we don't know, then assume that we are waiting for one.
            if (state.awaitDrain &&
               (!dest._writableState || dest._writableState.needDrain)) {
                ondrain();
            }
        }

        src.on('data', ondata);
        function ondata (chunk) {
            var ret = dest.write(chunk);
            if (ret === false) {
                // We should stop writing, so pause the source readable
                src._readableState.awaitDrain++;
                src.pause();
            }
        }

        // Unpipe when there is an error in the destination writable
        function onerror (err) {
            unpipe();
            if (EventEmitter.listenerCount(dest, 'error') === 0) {
                dest.emit('error', err);
            }
        }
        dest.once('error', onerror);


        // Both close and finish should trigger unpipe, but only once
        function onclose () {
            dest.removeListener('finish', onfinish);
            unpipe();
        }
        dest.once('close', onclose);
        function onfinish () {
            dest.removeListener('close', onclose);
            unpipe();
        }
        dest.once('finish', onfinish);


        function unpipe () {
            src.unpipe(dest);
        }

        // writables should emit 'pipe' when they're being piped to
        dest.emit('pipe', src);

        if ( ! state.flowing) {
            // Start the flow so pipe works
            src.resume();
        }

        return dest;
    };


    /**
     * This method will remove the hooks set up for a previous pipe() call.
     * If the destination is not specified, then all pipes are removed.
     * If the destination is specified, but no pipe is set up for it, then
     * this is a no-op.
     */
    Readable.prototype.unpipe = function (dest) {
        var state = this._readableState;

        // If there are no pipes, don't do anything
        if (state.pipes.length === 0) {
            return this;
        }

        // Only one pipe
        if (state.pipes.length === 1) {
            if (dest && dest !== state.pipes[0]) {
                // passed a dest we're not piping to
                return this;
            }

            if (!dest) {
                dest = state.pipes[0];
            }

            state.pipes = [];
            state.flowing = false;

            if (dest) {
                dest.emit('unpipe', this);
            }

            return this;
        }

        // Multiple Pipes

        // If dest not passed, unpipe all of them
        if ( ! dest) {
            var dests = state.pipes,
                numDests = dests.length;

            state.pipes = [];
            state.flowing = false;

            for (var i=0; i < numDests; i++) {
                dests[i].emit('unpipe', this);
            }

            return this;
        }

        // Dest was passed, only unpipe that one
        var indexOfDest = state.pipes.indexOf(dest);
        if (indexOfDest === -1) {
            return this;
        }

        state.pipes.splice(indexOfDest, 1);
        dest.emit('unpipe', this);

        return this;
    };


    /**
     * Get a function that will be excuted by a pipe destination
     * so that this readable continues piping when the writable drains
     */
    Readable.prototype._pipeOnDrain = function () {
        var src = this;
        return function () {
            var dest = this,
                state = src._readableState;
            if (state.awaitDrain) {
                state.awaitDrain--;
            }
            if (state.awaitDrain === 0 &&
                EventEmitter.listenerCount(src, 'data')) {
                state.flowing = true;
                src._flow();
            }
        };
    };


    /**
     * Continually .read() this Readable until there is nothing
     * more to read. Calling .read() will emit 'data'
     */
    Readable.prototype._flow = function () {
        var state = this._readableState,
            chunk;
        if (state.flowing) {
            do {
                chunk = this.read();
            } while (chunk !== null && state.flowing);
        }
    };


    /**
     * Push a chunk onto the end of the internal buffer
     * The _read() function will not be called again until at least one
     *     push(chunk) call is made.
     * The Readable class works by putting data into a read queue to be pulled
     *     out later by calling the read() method when the 'readable' event fires.
     * @param chunk {...object} Chunk of data to push into the read queue.
     *     if chunk === null, that signals the end of data
     * @returns {boolean} Whether or not more pushes should be performed
     */
    Readable.prototype.push = function (chunk) {
        var chunks = Array.prototype.slice.call(arguments);
        return this._addToBuffer.apply(this, [false].concat(chunks));
    };


    /**
     * Push a chunk onto the front of the internal buffer.
     * This is useful in certain cases where a stream is being consumed by a
     * parser, which needs to "un-consume" some data that it has optimistically pulled out of the source, so that the stream can be passed on to some other party.
     * @param chunk {...object} Chunk of data to unshift onto the read queue
     * @returns {boolean} Whether or not more pushes should be performed
     */
    Readable.prototype.unshift = function (chunk) {
        var chunks = Array.prototype.slice.call(arguments);
        return this._addToBuffer.apply(this, [true].concat(chunks));
    };


    /**
     * @private
     * Common implementation shared between .push and .unshift
     * Both methods mutate to read buffer
     * @param addToFront {boolean} Whether to add to the front or back of the
     *     buffer
     * @param chunk {...object} Chunk of data to add to the read queue
     * @returns {boolean} Whether this stream should have more data pushed
     *     to it
     */
    Readable.prototype._addToBuffer = function (addToFront, firstChunk) {
        var chunks = Array.prototype.slice.call(arguments, 1),
            state = this._readableState;
        if (firstChunk === null) {
            // End of file.
            state.reading = false;
            // Start wrapping up if we haven't before
            if ( ! state.ended) {
                this._endReadable();
            }
        } else {
            if (state.ended && ! addToFront) {
                this.emit('error', new Error("readable.push() called after EOF"));
            } else if (state.endEmitted && addToFront) {
                this.emit('error', new Error("readable.unshift() called after end event"));
            } else {
                if (addToFront) {
                    state.buffer.unshift.apply(state.buffer, chunks);
                } else {
                    state.reading = false;
                    state.buffer.push.apply(state.buffer, chunks);
                }
                // If we've pushed data to the buffer,
                // let listeners know we're readable
                if (firstChunk && state.needReadable) {
                    this._emitReadable();
                }
                this._maybeReadMore();
            }
        }
        
        // Return whether
        return ! state.ended && 
               ( state.needReadable ||
                 state.buffer.length < state.highWaterMark ||
                 state.buffer.length === 0);
    };


    /**
     * @private
     * _read() more data from upstream until the buffer length is greater than
     *     the highWaterMark. It triggers this by calling .read(0);
     * This executes on nextTick, not synchronously
     */
    Readable.prototype._maybeReadMore = function () {
        var self = this,
            state = self._readableState;

        if (state.readingMore) {
            return;
        }
        state.readingMore = true;

        util.nextTick(_readMore);

        function _readMore () {
            var len = state.buffer.length;
            while ( ! state.reading && ! state.ended &&
                    state.buffer.length < state.highWaterMark ) {
                // Trigger ._read()
                self.read(0);
                if (len === state.buffer.length) {
                    // self.read(0) didn't add any data
                    break;
                } else {
                    len = state.buffer.length;
                }
            }
            state.readingMore = false;
        }
    };


    /**
     * Resume emitting data events.
     * This method will switch the stream into flowing-mode. If you do not want
     * to consume the data from a stream, but you do want to get to its end
     * event, you can call readable.resume() to open the flow of data.
     */
    Readable.prototype.resume = function () {
        var state = this._readableState;
        if ( ! state.flowing) {
            state.flowing = true;
            // Make sure there's data coming from upstream
            if ( ! state.reading) {
                this.read(0);
            }
            this._scheduleResume();
        }
    };


    /**
     * @private
     * If not already scheduled, schedule _doResume to execute
     * on nextTick
     */
    Readable.prototype._scheduleResume = function () {
        var self = this,
            state = this._readableState;
        if ( ! state.resumeScheduled) {
            state.resumeScheduled = true;
            util.nextTick(function () {
                self._doResume();
            });
        }
    };


    Readable.prototype._doResume = function () {
        var state = this._readableState;
        state.resumeScheduled = false;
        this.emit('resume');
        this._flow();
        // Make sure we're getting data from upstream
        if (state.flowing && ! state.reading) {
            this.read(0);
        }
    };


    /**
     * Stop emitting data events. Any data that becomes available will remain
     * in the internal buffer.
     */
    Readable.prototype.pause = function () {
        if (this._readableState.flowing !== false) {
            this._readableState.flowing = false;
            this.emit('pause');
        }
    };


    /**
     * Bind an event listener to an event on this stream
     * Readable adds some extra functionality so that binding a listener
     *     to 'readable' marks ._readableState.needReadable=true
     * @param eventName {string} The Event name to listen for
     * @param cb {function} Callback function to call when eventName fires
     */
    Readable.prototype.on = function (eventName, cb) {
        var ret = Stream.prototype.on.call(this, eventName, cb),
            state = this._readableState;

        if (eventName === 'data' && (state.flowing !== false)) {
            this.resume();
        }

        if (eventName === 'readable' && this.readable) {
            // Start reading on the first readable listener
            if ( ! state.readableListening) {
                state.readableListening = true;
                state.emittedReadable = false;
                state.needReadable = true;
                if ( ! state.reading) {
                    this.read(0);
                } else if (state.buffer.length) {
                    this._emitReadable();
                }
            }
        }
    };


    /**
     * Read data from the read buffer
     * @param [size] {number} The number of items to read from the buffer.
     *     If not provided, all data will be returned.
     *     If 0, There are some cases where you want to trigger a refresh of the
     *     underlying readable stream mechanisms, without actually consuming any
     *     data. In that case, you can call stream.read(0), which will always
     *     return null.
     *     If the internal read buffer is below the highWaterMark, and the
     *     stream is not currently reading, then calling read(0) will trigger a
     *     low-level _read call.
     *     There is almost never a need to do this externally.
     * @returns {object|null} An object from the read buffer, or null
     */
    Readable.prototype.read = function (size) {
        var state = this._readableState,
            originalSize = size,
            doRead,
            ret;

        state.calledRead = true;
        
        if (typeof size !== 'number' || size > 0) {
            // User wants data. We'll need to emit readable
            state.emittedReadable = false;
        }

        if (size === 0 && state.needReadable &&
           (state.buffer.length >= state.highWaterMark || state.ended)) {
            if (state.buffer.length === 0 && state.ended) {
                this._endReadable();
            } else {
                this._emitReadable();
            }
            return null;
        }

        size = this._getSizeToRead(size);

        // If called with 0 once end has been emitted, return null
        if (size === 0 && state.ended) {
            if (state.buffer.length === 0) {
                this._endReadable();
            }
            return null;
        }

        // Determine whether ._read needs to be called to fill up the buffer
        doRead = state.needReadable;

        // We need to read if this read will lower the buffer size
        // below the highWaterMark
        if (state.buffer.length === 0 ||
            state.buffer.length - size < state.highWaterMark) {
            doRead = true;
        }

        // Never read if already reading or the stream has ended
        if (state.reading || state.ended) {
            doRead = false;
        }

        if (doRead) {
            state.reading = true;
            state.sync = true;
            if (state.buffer.length === 0) {
                state.needReadable = true;
            }
            // Go get more data!
            this._read(state.highWaterMark);
            state.sync = false;
            // state.reading will be falsy if _read executed synchronously
            // This could change the buffer so we recalc size
            if ( ! state.reading) {
                size = this._getSizeToRead(originalSize);
            }
        }

        if (size > 0) {
            ret = this._readFromBuffer(size);
        } else {
            ret = null;
        }

        if (ret === null) {
            state.needReadable = true;
            size = 0;
        }

        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (state.buffer.length === 0 && !state.ended) {
            state.needReadable = true;
        }

        // If we happened to read() exactly the remaining amount in the
        // buffer, and the EOF has been seen at this point, then make sure
        // that we emit 'end' on the very next tick.
        if (state.ended && !state.endEmitted && state.buffer.length === 0) {
            this._endReadable();
        }

        if (ret !== null) {
            this.emit('data', ret);
        }

        return ret;
    };


    /**
     * @private
     * Fetch data asynchronously from an upstream source.
     * Implement this function, but do NOT call it directly.
     * When data is available, put it into the read queue by calling
     *     readable.push(chunk). If push returns false, then you should stop
     *     pushing. When _read is called again, you should start pushing more.
     */
    Readable.prototype._read = function () {
        this.emit('error', new Error('._read() not implemented'));
    };


    /**
     * @private
     * Get data from the internal read buffer
     * @returns {object|null} An object from the internal read buffer, or null
     *     if there is no more on the buffer
     */
    Readable.prototype._readFromBuffer = function () {
        var state = this._readableState,
            buffer = state.buffer;
        if (buffer.length === 0) {
            return null;
        } else {
            return buffer.shift();
        }
    };


    /**
     * @private
     * Get the appropriate number of objects to read from the buffer.
     * @param sizeAskedFor {number} The Number of items asked for by the user
     * @returns {number} The number of objects that should be returned from
     *     .read()
     */
    Readable.prototype._getSizeToRead = function (sizeAskedFor) {
        var state = this._readableState;
        // Don't read anything if there's nothing to read
        if (state.buffer.length === 0 && state.ended) {
            return 0;
        }
        // Assuming objectMode. Return at most one item
        return sizeAskedFor === 0 ? 0 : 1;
    };


    /**
     * @private
     * Cause the stream to emit 'readable'
     */
    Readable.prototype._emitReadable = function () {
        var self = this,
            state = this._readableState;

        state.needReadable = false;

        if ( ! state.emittedReadable) {
            state.emittedReadable = true;
            if (state.sync) {
                util.nextTick(emitReadable);
            } else {
                emitReadable();
            }
        }

        function emitReadable () {
            self.emit('readable');
            self._flow();
        }
    };


    /**
     * @private
     * Mark the stream as closed and that it should not be readable again.
     * Often this happens after this.push(null);
     */
    Readable.prototype._endReadable = function () {
        var state = this._readableState;
        state.ended = true;
        if (state.buffer.length) {
            this._emitReadable();
        } else {
            this._emitEnd();
        }
    };


    /**
     * @private
     * Emit the end event if it hasn't been emitted yet
     */
    Readable.prototype._emitEnd = function () {
        var self = this,
            state = this._readableState;
        if (state.buffer.length > 0) {
            throw new Error("Tried to emit end event on a non-empty Readable");
        }
        if ( ! state.endEmitted && state.calledRead) {
            state.ended = true;
            util.nextTick(function () {
                // Check that we didn't get one last unshift.
                if (!state.endEmitted && state.buffer.length === 0) {
                    state.endEmitted = true;
                    self.readable = false;
                    self.emit('end');
                }
            });
        }
    };


    /**
     * The state objects contain other useful information for debugging the
     * state of streams in your programs. It is safe to look at them, but beyond
     * setting option flags in the constructor, it is not safe to modify them.
     * Copied from http://bit.ly/16eA5K7
     */
    function ReadableState(opts, stream) {
        opts = opts || {};

        // the point at which it stops calling _read() to fill the buffer
        // Note: 0 is a valid value, means "don't call _read preemptively ever"
        var hwm = opts.highWaterMark;
        this.highWaterMark = (hwm || hwm === 0) ? hwm : 0;

        // cast to ints.
        this.highWaterMark = ~~this.highWaterMark;

        this.buffer = [];
        this.pipes = [];
        this.pipesCount = 0;
        this.flowing = null;
        this.ended = false;
        this.endEmitted = false;
        this.reading = false;

        // In streams that never have any data, and do push(null) right away,
        // the consumer can miss the 'end' event if they do some I/O before
        // consuming the stream.  So, we don't emit('end') until some reading
        // happens.
        this.calledRead = false;

        // a flag to be able to tell if the onwrite cb is called immediately,
        // or on a later tick.  We set this to true at first, becuase any
        // actions that shouldn't happen until "later" should generally also
        // not happen before the first write call.
        this.sync = true;

        // whenever we return null, then we set a flag to say
        // that we're awaiting a 'readable' event emission.
        this.needReadable = false;
        this.emittedReadable = false;
        this.readableListening = false;


        // object stream flag. Used to make read(n) ignore n and to
        // make all the buffer merging and length checks go away
        this.objectMode = !!opts.objectMode;

        // Crypto is kind of old and crusty.  Historically, its default string
        // encoding is 'binary' so we have to make this configurable.
        // Everything else in the universe uses 'utf8', though.
        this.defaultEncoding = opts.defaultEncoding || 'utf8';

        // when piping, we only care about 'readable' events that happen
        // after read()ing all the bytes and not getting any pushback.
        this.ranOut = false;

        // the number of writers that are awaiting a drain event in .pipe()s
        this.awaitDrain = 0;

        // if true, a maybeReadMore has been scheduled
        this.readingMore = false;

        this.decoder = null;
        this.encoding = null;
    }

    return Readable;
});
define('stream/duplex',['stream/readable', 'stream/writable', 'stream/util', 'inherits'],
function (Readable, Writable, util, inherits) {

	function Duplex (opts) {
		Readable.call(this, opts);
		Writable.call(this, opts);

		if (opts && opts.readable === false) {
			this.readable = false;
		}

		if (opts && opts.writable === false) {
			this.writable = false;
		}

		this.allowHalfOpen = true;
		if (opts && opts.allowHalfOpen === false) {
			this.allowHalfOpen = false;
		}

		this.once('end', onend);
	}

	inherits(Duplex, Readable);
	inherits.parasitically(Duplex, Writable);

	// Enforce noHalfOpen
	function onend () {
		var self = this;

		if (this.allowHalfOpen || this._writableState.ended) {
			return;
		}

		// No more data can be written.
		// But more writes can happen in this tick
		util.nextTick(function () {
			self.end();
		});
	}

	return Duplex;
});
define('stream/transform',['stream/duplex', 'inherits'],
function (Duplex, inherits) {

    function Transform (opts) {
        var stream = this,
            ts;
        Duplex.call(this, opts);
        ts = this._transformState = new TransformState(opts, this);

        // start out asking for a readable event once data is transformed.
        this._readableState.needReadable = true;
        // we have implemented the _read method, and done the other things
        // that Readable wants before the first _read call, so unset the
        // sync guard flag.
        this._readableState.sync = false;

        this.once('finish', function () {
            if (typeof stream._flush === 'function') {
                stream._flush(function (errback) {
                    stream._doneTransforming(err);
                });
            } else {
                stream._doneTransforming();
            }
        });
    }

    inherits(Transform, Duplex);


    /**
     * Transform subclasses should implement this
     * Call `.push(data)` to pass data to the Readable side.
     * Call `errback(err)` when you are done with this chunk. If you pass an
     *     err, then it will be emitted. If you never call `errback`, then
     *     you'll never get another chunk.
     */
    Transform.prototype._transform = function (chunk, errback) {
        this.emit('error', new Error('_transform not implemented!'));
    };


    Transform.prototype.push = function (chunk) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.apply(this, arguments);
    };


    /**
     * Must be implemented here because Transform is a Readable
     */
    Transform.prototype._read = function () {
        var ts = this._transformState;

        if (ts.writechunk !== null && ts.writecb && ! ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.afterTransform);
        } else {
            // mark that we need a transform, so that any data that comes in
            // will get processed, now that it's been asked for
            ts.needTransform = true;
        }
    };


    /**
     * Must be implemented here because Transform is Writable
     */
    Transform.prototype._write = function (chunk, errback) {
        var ts = this._transformState,
            rs = this._readableState;
        ts.writecb = errback;
        ts.writechunk = chunk;
        if ( ! ts.transforming ) {
            if (ts.needTransform ||
                rs.needReadable ||
                rs.buffer.length < rs.highWaterMark) {
                this._read(rs.highWaterMark);
            }
        }
    };


    Transform.prototype._afterTransform = function (err, data) {
        var ts = this._transformState,
            rs = this._readableState,
            errback = ts.writecb;

        ts.transforming = false;

        if ( ! errback) {
            return this.emit('error', new Error('no writecb in Transform class'));
        }

        ts.writechunk = null;
        ts.writecb = null;

        if (data !== null && data !== undefined) {
            this.push(data);
        }

        if (errback) {
            errback(err);
        }

        rs.reading = false;

        if (rs.needReadable || rs.buffer.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
        }
    };


    Transform.prototype._doneTransforming = function (err) {
        if (err) {
            this.emit('error', err);
        }

        // if there's nothing in the write buffer, then that means
        // that nothing more will ever be provided
        var ws = this._writableState,
            ts = this._transformState;

        if (ws.buffer.length) {
            throw new Error('Calling Transform#_doneTransforming when writable buffer not empty');
        }

        if (ts.transforming) {
            throw new Error('Calling Transform#_doneTransforming when still transforming');
        }

        return this.push(null);
    };


    function TransformState (opts, stream) {
        this.afterTransform = function (err, data) {
            return stream._afterTransform(err, data);
        };

        this.needTransform = false;
        this.transforming = false;
        this.writecb = null;
        this.writechunk = null;
    }


    return Transform;
});
define('streamhub-sdk/content/state-to-content',[
    'streamhub-sdk/content/types/livefyre-content',
    'streamhub-sdk/content/types/livefyre-twitter-content',
    'streamhub-sdk/content/types/livefyre-facebook-content',
    'streamhub-sdk/content/types/oembed',
    'streamhub-sdk/content/types/livefyre-oembed',
    'streamhub-sdk/content/types/livefyre-opine',
    'streamhub-sdk/content/types/livefyre-instagram-content',
    'streamhub-sdk/storage',
    'streamhub-sdk/debug',
    'stream/transform',
    'inherits'
], function (LivefyreContent, LivefyreTwitterContent, LivefyreFacebookContent,
Oembed, LivefyreOembed, LivefyreOpine, LivefyreInstagramContent, Storage, debug, Transform,
inherits) {
    


    var log = debug('streamhub-sdk/content/state-to-content');


    /**
     * An Object that transforms state objects from Livefyre APIs
     * into streamhub-sdk Content instances
     * @param authors {object} A mapping of authorIds to author information
     * @param [replies=false] {boolean} Whether to read out reply Content
     * @param storage {Storage} A storage mechanism that supports get/set functions.
     */
    var StateToContent = function (opts) {
        opts = opts || {};
        this._authors = opts.authors || {};
        this._replies = opts.replies;
        this._collection = opts.collection;
        this._storage = opts.storage || Storage;
        Transform.call(this, opts);
    };

    inherits(StateToContent, Transform);


    StateToContent.prototype._transform = function (state, done) {
        var contents;
        try {
            contents = this.transform(state, this._authors, {
                replies: this._replies,
                collection: this._collection
            });
        } catch (err) {
            this.emit('error transforming state-to-content', err);
            log('StateToContent.transform threw', err);
        }
        if (contents && contents.length) {
            this.push.apply(this, contents);
        }
        done();
    };

    /**
     * Creates the correct content type given the supplied "state".
     * @param state {Object} The livefyre content "state" as received by the
     *     client.
     * @param authors {Object} A mapping of authorIds to author information
     * @param opts {Object}
     * @param opts.createContent {Function}
     * @return {LivefyreContent[]} An Array containing a Content that represents
     *     the passed state, if it was top-level. If opts.replies, then any
     *     reply Content that was transformed will be returned
     *     (including potentially many descendants)
     */
    StateToContent.prototype.transform = function (state, authors, opts) {
        opts = opts || {};
        var isPublic = (typeof state.vis === 'undefined') || (state.vis === 1),
            isReply = state.content.parentId,
            type = StateToContent.enums.type[state.type],
            isAttachment = ('OEMBED' === type),
            isContent = ('CONTENT' === type),
            isOpine = ('OPINE' === type),
            childStates = state.childContent || [],
            content,
            childContent = [],
            descendantContent = [];

        if ( ! (isAttachment || isContent || isOpine)) {
            return;
        }

        content = this._createContent(state, authors);

        if (content && opts.collection) {
            content.collection = opts.collection;
        }

        // Store content with IDs in case we later get
        // replies or attachments targeting it
        if (content && content.id) {
            var stored = this._storage.get(content.id);
            if (stored) {
                // If existing content, update properties on existing instance
                if (isContent) {
                    // This could be a delete state, so only update
                    // properties that are actually set
                    stored.set(this._getUpdatedProperties(content));
                }
                // Use the stored object, now that its properties have been
                // updated
                content = stored;
                // Don't handle attachment updating.
            } else {
                this._storage.set(content.id, content);
            }
            childContent = this._storage.get('children_'+content.id) || [];
        }

        // Get child states (replies and attachments)
        childStates = state.childContent || [];
        // Transform child states (replies and attachments)
        // This will put them in Storage
        for (var i=0, numChildren=childStates.length; i < numChildren; i++) {
            var thisReplyAndDescendants = this.transform(childStates[i], authors, opts);
            descendantContent.push.apply(descendantContent, thisReplyAndDescendants || []);
        }

        // Add any children that are awaiting the new content
        if (childContent.length) {
            this._addChildren(content, childContent);
        }

        // At this point, all content and children (recursively)
        // Are stored by ID
        // Attach attachments to their target, or store for later
        if (isAttachment) {
            this._attachOrStore(content, state.content.targetId);
        }
        // Add replies to their parent, or store for later
        if (isReply) {
            this._addReplyOrStore(content, state.content.parentId);
        }
        // Add opines to their parent, or store for later
        if (isOpine) {
            this._addOpineOrStore(content, state.content.targetId);
        }

        // Never return non-Content items or non-public items
        // But note, this is at the end of the recursive function,
        // so these items are still walked/processed, just not returned
        if ( ! isContent) {
            return this._handleNonContent(content);
        }

        if ( ! isPublic) {
            return this._handleNonPublic(content);
        }

        // Don't return replies if not explicitly specified
        if (isReply && ! opts.replies) {
            return;
        }

        if (opts.collection) {
            content.collection = opts.collection;
        }

        if (opts.replies) {
            return [content].concat(descendantContent);
        }
        return [content];
    };

    // Keep static for legacy API compatibility.
    StateToContent.transform = function (state, authors, opts) {
        var instance = new StateToContent();
        return instance.transform(state, authors, opts);
    };

    StateToContent.prototype._addChildren = function (content, children) {
        var child;
        for (var i=0, numChildren=children.length; i < numChildren; i++) {
            child = children[i];
            if (child instanceof Oembed) {
                content.addAttachment(child);
            } else if (child instanceof LivefyreContent) {
                content.addReply(child);
            } else if (child instanceof LivefyreOpine) {
                content.addOpine(child);
            }
        }
    };
    // Keep static for legacy API compatibility.
    StateToContent._addChildren = StateToContent.prototype._addChildren;


    StateToContent.prototype._createContent = function (state, authors) {
        var sourceName = StateToContent.enums.source[state.source],
            ContentType;

        state.author = authors && authors[state.content.authorId];

        if ('OEMBED' === StateToContent.enums.type[state.type]) {
            return new LivefyreOembed(state);
        } else if ('OPINE' === StateToContent.enums.type[state.type]) {
            return new LivefyreOpine(state);
        } else if (sourceName === 'twitter') {
            return new LivefyreTwitterContent(state);
        } else if (sourceName === 'facebook') {
            return new LivefyreFacebookContent(state);
        } else if (sourceName === 'instagram') {
            return new LivefyreInstagramContent(state);
        } else if (sourceName === 'feed') {
            ContentType = LivefyreContent;
            // Use specific Content type for states from instagram RSS feeds
            if (isInstagramState(state)) {
                ContentType = LivefyreInstagramContent;
            }
            return new ContentType(state);
        } else if (sourceName === 'livefyre') {
            return new LivefyreContent(state);
        } else {
            log("StateToContent could not create content for state", state);
        }
    };
    // Keep static for legacy API compatibility.
    StateToContent._createContent = StateToContent.prototype._createContent;


    function isInstagramState (state) {
        var pattern = /\/\/instagram\.com/i;
        try {
            return state.content.feedEntry.channelId.match(pattern);
        } catch (err) {
            return false;
        }
    }


    /**
     * For a piece of Content, get the the properties and values that should
     * be used to update a previous version of that piece of Content
     * @param content {Content} A new version of a piece of Content,
     *     possible generated from a delete state, so it may not have a truthy
     *     .body and .attachments
     * @return {Object} A dict containing updated properties and their new value
     */
    StateToContent.prototype._getUpdatedProperties = function(content) {
        var updatedProperties = {
            visibility: content.visibility
        };
        if (content.attachments && content.attachments.length) {
            updatedProperties.attachments = content.attachments;
        }
        if (content.body) {
            updatedProperties.body = content.body;
        }
        if (content.author) {
            updatedProperties.author = content.author;
        }
        if (content.createdAt) {
            updatedProperties.createdAt = content.createdAt;
        }
        if (content.updatedAt) {
            updatedProperties.updatedAt = content.updatedAt;
        }
        return updatedProperties;
    };
    // Keep static for legacy API compatibility
    StateToContent._getUpdatedProperties = StateToContent.prototype._getUpdatedProperties;


    StateToContent.prototype._attachOrStore = function (attachment, targetId) {
        var target = this._storage.get(targetId);
        if (target) {
            log('attaching attachment', arguments);
            target.addAttachment(attachment);
        } else {
            log('storing attachment', arguments);
            this._storeChild(attachment, targetId);
        }
    };
    // Keep static for legacy API compatibility
    StateToContent._attachOrStore = StateToContent.prototype._attachOrStore;

    StateToContent.prototype._addReplyOrStore = function (reply, parentId) {
        var parent = this._storage.get(parentId);
        if (parent) {
            log('adding reply', arguments);
            parent.addReply(reply);
        } else {
            log('storing reply', arguments);
            this._storeChild(reply, parentId);
        }
    };
    // Keep static for legacy API compatibility
    StateToContent._addReplyOrStore = StateToContent.prototype._addReplyOrStore;

    StateToContent.prototype._addOpineOrStore = function (opine, targetId) {
        var target = Storage.get(targetId);
        if (target) {
            log('attaching attachment', arguments);
            target.addOpine(opine);
        } else {
            log('storing attachment', arguments);
            this._storeChild(opine, targetId);
        }
    };

    StateToContent.prototype._storeChild = function (child, parentId) {
        //TODO (joao) Make this smart enough to not push duplicates
        var childrenKey = 'children_' + parentId,
            children = this._storage.get(childrenKey) || [];
        children.push(child);
        this._storage.set(childrenKey, children);
    };
    // Keep static for legacy API compatibility
    StateToContent._storeChild = StateToContent.prototype._storeChild;

    StateToContent.prototype._handleNonPublic = function(content) {
        return;
    };

    StateToContent.prototype._handleNonContent = function(content) {
        return;
    };

    StateToContent.enums = {};


    StateToContent.enums.source = LivefyreContent.SOURCES;


     /**
     * The StreamHub APIs use enumerations to define
     * the type of message sent down the wire. All types
     * should be in this enumeration.
     * @enum types
     * @property {string} types.CONTENT - The good stuff. Juicy Content
     * like comments
     * @property {string} types.OPINE - A user's opinion or something
     * @property {string} types.SHARE - TODO: I don't know yet.
     * @property {string} types.OEMBED - A new attachment
     */
    StateToContent.enums.type = [
        'CONTENT',
        'OPINE',
        'SHARE',
        'OEMBED'
    ];


    StateToContent.Storage = Storage;
    return StateToContent;
});

define('annotations/util/storage',['require','exports','module','jquery','annotations/models/comment','streamhub-sdk/storage'],function (require, exports, module) {/**
 * @fileOverview Content StorageWrapper that keeps track of all comments and
 * maps them to blocks.
 */

var $ = require('jquery');
var Comment = require('annotations/models/comment');
var Storage = require('streamhub-sdk/storage');

/** @type {Object} */
var StorageWrapper = {};

/**
 * Map of block ID to list of comments. Useful for caching all of the comments
 * that a block has.
 * @type {Object.<string, Array.<string>>}
 */
StorageWrapper.blockToCommentMap = {};

/**
 * Add a comment to a map, both of which are provided.
 * @param {string} key The key in the map.
 * @param {string} commentId The ID of the comment to add.
 * @param {Object} map The map to add the commentId to.
 */
function addCommentToMap (key, commentId, map) {
    if (!map[key]) {
        map[key] = [];
    }
    if ($.inArray(commentId, map[key]) > -1) {
        return;
    }
    map[key].push(commentId);
}

/**
 * Pass-through to streamhub-sdk/storage/get
 */
StorageWrapper.get = function (key, callback) {
    return Storage.get(key, callback);
};

/**
 * Get all comments for a block.
 * @param {string} blockId The ID of the block to retrieve comments for.
 * @return {Array.<Comment>}
 */
StorageWrapper.getCommentsForBlock = function (blockId) {
    return $.map(StorageWrapper.blockToCommentMap[blockId] || [], function (commentId) {
        return Storage.get(commentId);
    });
};

/**
 * Get the number of visible comments for a given block ID.
 * @param {string} blockId The ID of the block to get the number of comments for.
 * @return {number} The number of comments.
 */
StorageWrapper.getNumCommentsForBlock = function (blockId) {
    var comment;
    var comments = [];
    $.each(StorageWrapper.blockToCommentMap[blockId] || [], function (i, commentId) {
        comment = Storage.get(commentId);
        comment && comment.isVisible() && comments.push(commentId);
    });
    return comments.length;
};

/**
 * Pass-through to streamhub-sdk/StorageWrapper/set
 * @override
 */
StorageWrapper.set = function (key, value, callback) {
    // Don't save a premoderated comment.
    Storage.set(key, value, callback);
    // Do comment-specific processing here.
    if (value instanceof Comment) {
        addCommentToMap(value.blockId, value.id, StorageWrapper.blockToCommentMap);
    }
    return value;
};

/**
 * Reset all caches.
 */
StorageWrapper.reset = function () {
    Storage.cache = {};
    StorageWrapper.blockToCommentMap = {};
};

module.exports = StorageWrapper;

});

define('annotations/adapters/adapters',['require','exports','module','jquery','annotations/models/author','auth','annotations/models/comment','inherits','annotations/util/internals','streamhub-sdk/content/state-to-content','annotations/util/storage','annotations/enums'],function (require, exports, module) {var $ = require('jquery');
var Author = require('annotations/models/author');
var auth = require('auth');
var Comment = require('annotations/models/comment');
var inherits = require('inherits');
var nullFunction = require('annotations/util/internals').nullFunction;
var StateToContent = require('streamhub-sdk/content/state-to-content');
var Storage = require('annotations/util/storage');
var visEnums = require('annotations/enums').commentVisibility;

var BootstrapKeys = {
    ANCHORS: 'anchors',
    ANNOTATION: 'annotation',
    AUTHORS: 'authors',
    AUTHOR_ID: 'authorId',
    BLOCK_ID: 'blockId',
    BODY_HTML: 'bodyHtml',
    CONTENT: 'content',
    CREATED_AT: 'createdAt',
    DATA: 'data',
    EREFS: 'erefs',
    HINTS: 'hints',
    ID: 'id',
    INDEX: 'index',
    MESSAGES: 'messages',
    META: 'meta',
    MODERATOR: 'moderator',
    NUM_ANNOTATIONS: 'num_annotations',
    NUM_VISIBLE: 'numVisible',
    PARENT_ID: 'parentId',
    SIMHASH: 'simhash',
    STATES: 'states',
    URL: 'url',
    VOTE: 'vote'
};

/**
 * @extends {StateToContent}
 * @constructor
 */
var AnnotationsStateToContent = function (opts) {
    opts = opts || {};
    this._erefProcessor = opts.erefProcessor;
    opts.replies = true;
    opts.storage = Storage;
    StateToContent.call(this, opts);
};
inherits(AnnotationsStateToContent, StateToContent);

/**
 * The add reply functionality does not suit our needs...
 * @override
 */
AnnotationsStateToContent.prototype._addReplyOrStore = nullFunction;

/** @override */
AnnotationsStateToContent.prototype._createContent = function (state, authors) {
    var author = authors[state.content.authorId];
    if (!(author instanceof Author)) {
        author = new Author(author);
    }

    state.author = author;
    return new Comment(state);
};

/** @override */
AnnotationsStateToContent.prototype._getUpdatedProperties = function (content) {
    var stored = Storage.get(content.id);
    // Do not want to update content properties if the content has erefs
    // because it will destroy the existing model that we have with bad data.
    // Also, don't update the data if the content has been deleted, since there
    // are no useful attributes on there.
    if (content.erefs || content.visibility === visEnums.NONE) {
        return {
            lastVisibility: stored.visibility,
            visibility: content.visibility
        };
    }

    // The new content is older than the content that we already have. This
    // could happen when:
    // 1. permalink thread is newer than getThread version
    // 2. original content had erefs, but they were decoded
    // 3. content has streamed but the getThread version is old
    if (content.meta.event < stored.meta.event && !stored.erefs) {
        return {};
    }

    var updatedProperties = StateToContent.prototype._getUpdatedProperties.call(this, content);

    if (content.blockId) {
        updatedProperties.blockId = content.blockId;
    }
    if (content.parentId) {
        updatedProperties.parentId = content.parentId;
    }
    if (content.selectedText) {
        updatedProperties.selectedText = content.selectedText;
    }
    if (content.votes) {
        updatedProperties.votes = $.extend(content.votes, stored.votes);
    }

    updatedProperties.hasBeenRendered = stored.hasBeenRendered;
    updatedProperties.origin = stored.origin;

    // We shouldn't set the last visiblity of the content if it's the same as
    // the current visibility so that the block counts will work correctly.
    if (stored.visibility !== content.visibility) {
        updatedProperties.lastVisibility = stored.visibility;
    }
    stored.set(updatedProperties);
    Storage.set(stored.id, stored);

    return updatedProperties;
};

/** @override */
AnnotationsStateToContent.prototype._handleNonPublic = function (content) {
    // Premod
    if (content.visibility === visEnums.GROUP) {
        // litmus test for decryption
        if (content.body) {
            return [content];
        }
        if (this._erefProcessor) {
            this._erefProcessor.write(content.erefs);
        }
        return;
    }
    // Bozo
    if (content.visibility === visEnums.OWNER) {
        var user = auth.get('livefyre');
        if (user && user.get('id') === content.author.id) {
            return [content];
        }
    }
    // If not visible, should send through so that we can decrement counts.
    if (content.visibility === visEnums.NONE) {
        return [content];
    }
};

/**
 * Adapt permalink data, this is basically the same as `adaptThread` but
 * we need to extract the blockId from the data before returning the comments.
 * @param {Object} data
 * @return {Object}
 */
AnnotationsStateToContent.prototype.adaptPermalinkThread = function (data) {
    return {
        blockId: data[BootstrapKeys.DATA][BootstrapKeys.META].blockId,
        comments: this.adaptThread(data, true)
    };
};

/**
 * Process a thread in one batch operation
 * @param {Object} data
 * @param {boolean=} opt_bootstrap
 * @return {Array.<Comment>}
 */
AnnotationsStateToContent.prototype.adaptThread = function (data, opt_bootstrap) {
    data = data[BootstrapKeys.DATA];
    var comment;
    var comments = [];
    var dataAuthors = data[BootstrapKeys.AUTHORS];

    var contents = [];
    // Responses from bootstrap or quill.
    if (data[BootstrapKeys.CONTENT]) {
        contents = data[BootstrapKeys.CONTENT];
    } else if (data[BootstrapKeys.MESSAGES]) {
        contents = data[BootstrapKeys.MESSAGES];
    }

    // Top level content must always be processed first and we're apparently
    // not guaranteed to get it in that order.
    contents.sort(function (comment) {
        return comment[BootstrapKeys.CONTENT][BootstrapKeys.PARENT_ID] ? 1 : -1;
    });

    var removedComments = [];
    var self = this;
    $.each(contents, function (i, content) {
        if (opt_bootstrap) {
            content.origin = Comment.ORIGIN.BOOTSTRAP;
        }
        comment = self.transform(content, dataAuthors, {
            replies: true
        });
        comment = !comment ? null : comment[0];
        // If the comment doesn't exist, it has either been deleted or is not
        // visible at the moment.
        if (!comment || comment.visibility === visEnums.NONE) {
            removedComments.push(content[BootstrapKeys.CONTENT][BootstrapKeys.ID]);
            return;
        }
        // If the parent of a comment has been removed, we won't show it on the
        // page, so lets get rid of it.
        if (comment.parentId && removedComments.indexOf(comment.parentId) > -1) {
            return;
        }
        comments.push(comment);
    });

    return comments;
};

/**
 * Update the authors cache that the adapter knows about.
 * @param {Object.<string, Object>} authors
 */
AnnotationsStateToContent.prototype.updateAuthors = function (authors) {
    $.extend(this._authors, authors);
};

/**
 * @param {Object=} opt_data
 * @return {?string}
 */
function adaptPermalink(opt_data) {
    if (!opt_data) {
        return null;
    }
    var permalink = opt_data[BootstrapKeys.DATA][BootstrapKeys.URL];
    if (permalink.indexOf('http://') !== 0) {
        permalink = 'http://' + permalink;
    }
    return permalink;
}

/** @type {Array} */
var SCOPE_CHAIN = ['collectionSettings', 'siteSettings', 'networkSettings'];

/**
 * Pluck settings, collection level takes precedence over network level.
 * @param {AnnotationsCollection} collection
 * @param {Object} data
 */
function adaptSettings(collection, data) {
    collection.settings = collection.settings || {};
    var editMode = false;
    var editCommentInterval;
    var scope;
    for (var i = SCOPE_CHAIN.length - 1; i >= 0; i--) {
        scope = data[SCOPE_CHAIN[i]];
        if (!scope) {
            continue;
        }
        // collection settings are not at the top level
        if (i === 0) {
            scope = scope.config;
        }
        if (typeof scope.editMode === 'number') {
            editMode = scope.editMode === 1;
        }
        editCommentInterval = scope.editCommentInterval || editCommentInterval;
    }
    collection.settings.allowEditComments = editMode;
    collection.settings.editCommentInterval = editCommentInterval || 5;
    collection.maxEventId = (data.headDocument || {}).event || 0;
}

/**
 * Make avatar https friendly.
 * @param {string=} avatar
 * @return {string}
 */
function adaptAvatar(avatar) {
    if (avatar && adaptAvatar.IS_SECURE) {
        return avatar.replace('http://avatars.fyre.co', 'https://lfavatar-a.akamaihd.net');
    }
    return avatar;
}
adaptAvatar.IS_SECURE = location.protocol === 'https:';

module.exports = {
    adaptPermalink: adaptPermalink,
    adaptSettings: adaptSettings,
    AnnotationsStateToContent: AnnotationsStateToContent,
    BootstrapKeys: BootstrapKeys,
    adaptAvatar: adaptAvatar
};

});

define('annotations/adapters', ['annotations/adapters/adapters'], function (main) { return main; });

define('base64',['require','exports','module'],function (require, exports, module) {var base64 = {};
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function InvalidCharacterError(message) {
  this.message = message;
}
InvalidCharacterError.prototype = new Error;
InvalidCharacterError.prototype.name = 'InvalidCharacterError';

// encoder
// [https://gist.github.com/999166] by [https://github.com/nignag]
base64.btoa = window.btoa ? function(input) { return window.btoa(input); } : function (input) {
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars, output = '';
    // if the next input index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    input.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = input.charCodeAt(idx += 3/4);
    if (charCode > 0xFF) {
      throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
    }
    block = block << 8 | charCode;
  }
  return output;
};

// decoder
// [https://gist.github.com/1020396] by [https://github.com/atk]
base64.atob = window.atob ? function(input) { return window.atob(input); } : function (input) {
  input = input.replace(/=+$/, '')
  if (input.length % 4 == 1) {
    throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
  }
  for (
    // initialize result and counters
    var bc = 0, bs, buffer, idx = 0, output = '';
    // get next character
    buffer = input.charAt(idx++);
    // character found in table? initialize bit storage and add its ascii value;
    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
      // and if not first of each 4 characters,
      // convert the first 8 bits to one ascii character
      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
  ) {
    // try to find character in table (0-63, not found => -1)
    buffer = chars.indexOf(buffer);
  }
  return output;
};

base64.url = {
  btoa: function(input) {
    var output = base64.btoa(input);
    output = output.replace(/\+/g, '-');
    output = output.replace(/\//g, '_');
    return output;
  },
  atob: function(input) {
    var output = input;
    output = output.replace(/-/g, '+');
    output = output.replace(/_/g, '/');
    return base64.atob(output);
  }
};

module.exports = base64;

});

define('streamhub-sdk/collection/clients/http-client',['streamhub-sdk/jquery'], function($) {
    

    /**
     * A Client for requesting Livefyre web services
     * This is private and should not be used or imported directly
     * @private
     * @param opts {object}
     * @param opts.serviceName {string} The StreamHub web service to request
     * @param opts.protocol {string} 'http:' or 'https:'
     */
    var LivefyreHttpClient = function (opts) {
        opts = opts || {};
        this._serviceName = opts.serviceName;
        this._protocol = opts.protocol || document.location.protocol;
        if (this._protocol.slice(-1) !== ':') {
            this._protocol += ':';
        }
    };

    /**
     * Make an HTTP Request
     * @private
     * @param opts {object}
     * @param [opts.method=GET] {string} HTTP Method
     * @param opts.url {string} URL to request
     * @param opts.dataType {string} Data type to expect in response
     * @param callback {function=} A callback to pass (err, data) to
     */
    LivefyreHttpClient.prototype._request = function (opts, callback) {
        callback = callback || function() {};
        var xhr = $.ajax({
            type: opts.method || 'GET',
            url: opts.url,
            data: opts.data,
            dataType: opts.dataType || this._getDataType()
        });

        xhr.done(function(data, status, jqXhr) {
            // todo: (genehallman) check livefyre stream status in data.status
            callback(null, data);
        });

        xhr.fail(function(jqXhr, status, err) {
            if (windowIsUnloading) {
                // Error fires when the user reloads the page during a long poll,
                // But we don't want to throw an exception if the page is
                // going away anyway.
                return;
            }
            var errorMessage = err || 'LivefyreHttpClient Error';
            var httpError = createHttpError(
                errorMessage, jqXhr.status, jqXhr.responseJSON);
            callback(httpError);
        });

        return xhr;
    };

    /**
     * Get the $.ajax dataType to use
     */
    LivefyreHttpClient.prototype._getDataType = function () {
        if ($.support.cors) {
            return 'json';
        }
        return 'jsonp';
    };

    /**
     * Get the base of the URL (protocol and hostname)
     * @param opts {object}
     * @param opts.network {string} StreamHub Network
     * @param opts.environment {string=} StreamHub environment
     */
    LivefyreHttpClient.prototype._getUrlBase = function (opts) {
        return [
            this._protocol,
            '//',
            this._getHost(opts)
        ].join('');
    };

    /**
     * Get the host of the URL
     * @param opts {object}
     * @param opts.network {string} StreamHub Network
     * @param opts.environment {string=} StreamHub environment
     */
    LivefyreHttpClient.prototype._getHost = function (opts) {
        var isLivefyreNetwork = (opts.network === 'livefyre.com');
        var environment = opts.environment || 'livefyre.com';
        var host = this._serviceName + '.' + (isLivefyreNetwork ? environment : opts.network);
        var hostParts;
        if ( ! isLivefyreNetwork && this._protocol === 'https:') {
            hostParts = opts.network.split('.');
            // Make like 'customer.bootstrap.fyre.co'
            hostParts.splice(1, 0, this._serviceName);
            host = hostParts.join('.');
        }
        return host;
    };

    function createHttpError (message, statusCode, body) {
        var err = new Error(message);
        err.statusCode = statusCode;
        err.body = body;
        return err;
    }

    // Keep track of whether the page is unloading, so we don't throw exceptions
    // if the XHR fails just because of that.
    var windowIsUnloading = false;
    $(window).on('beforeunload', function () {
        windowIsUnloading = true;
    });

    return LivefyreHttpClient;

});

define('annotations/clients/annotationshttpclient',['require','exports','module','jquery','base64','inherits','streamhub-sdk/collection/clients/http-client'],function (require, exports, module) {/**
 * @fileoverview The AnnotationsHttpClient is responsible for getting/setting remote data.
 * It does *not* handle streamed events.
 */

var $ = require('jquery');
var base64 = require('base64');
var inherits = require('inherits');
var LivefyreHttpClient = require('streamhub-sdk/collection/clients/http-client');

/**
 * @override
 */
function AnnotationsHttpClient (opts) {
    LivefyreHttpClient.call(this, opts);
}
inherits(AnnotationsHttpClient, LivefyreHttpClient);

/**
 * Get a collection URL.
 * @param {Object} opts Options to help build URL.
 * @param {string} postfix Remainder of URL to add at the end.
 * @return {string}
 * @private
 */
AnnotationsHttpClient.prototype._getCollectionUrl = function (opts, postfix) {
    var url = [
        this._getUrlBase(opts),
        '/api/v3.0/collection/',
        opts.collectionId
    ].join('');
    return url + postfix;
};

/**
 * Get a content URL.
 * @param {Object} opts Options to help build URL.
 * @param {string} postfix Remainder of URL to add at the end.
 * @return {string}
 * @private
 */
AnnotationsHttpClient.prototype._getContentUrl = function (opts, postfix) {
    return [this._getUrlBase(opts), '/api/v3.0/content'].join('') + postfix;
};

/**
 * Get a message URL.
 * @param {Object} opts Options to help build URL.
 * @param {string} postfix Remainder of URL to add at the end.
 * @return {string}
 * @private
 */
AnnotationsHttpClient.prototype._getMessageUrl = function (opts, postfix) {
    var url = [
        this._getUrlBase(opts),
        '/api/v3.0/message/',
        opts.messageId
    ].join('');
    return url + postfix;
};

/**
 * Get the base url for the collection based on the provided options.
 * @param {Object} opts
 * @return {string}
 */
AnnotationsHttpClient.prototype.getUrlBase = function (opts) {
    return this._getUrlBase(opts);
};

/**
 * Fetches the annotations associated with a block.
 * @param opts {Object} The livefyre collection options.
 * @param opts.network {string} The name of the network in the livefyre platform
 * @param opts.environment {?string}
 * @param opts.collectionId {string} The livefyre collectionId for the conversation
 * @param opts.blockId {string}
 * @param callback {function} A callback that is called upon success/failure of the
 * stream request. Callback signature is "function(error, data)".
 */
AnnotationsHttpClient.prototype.getAnnotations = function (opts, callback) {
    this._request({
        url: this._getCollectionUrl(opts, '/annotation/' + opts.blockId + '/')
    }, callback);
};

/**
 * Fetches data from the livefyre bootstrap service with the arguments given.
 * @param opts {Object} The livefyre collection options.
 * @param opts.network {string} The name of the network in the livefyre platform
 * @param opts.siteId {string} The livefyre siteId for the conversation
 * @param opts.articleId {string|number} The livefyre articleId for the conversation
 * @param [opts.page] {string} Livefyre page name or number to fetch from bootstrap
 *     (default "init")
 * @param [opts.environment] {string} Optional livefyre environment to use dev/prod environment
 * @param callback {function} A callback that is called upon success/failure of the
 *     bootstrap request. Callback signature is "function(error, data)".
 */
AnnotationsHttpClient.prototype.getContent = function (opts, callback) {
    opts = opts || {};
    callback = callback || function() {};
    var environment = opts.environment = opts.environment || 'livefyre.com';
    var includeEnvironment = (environment !== 'livefyre.com') && (environment !== 'fyre')
        && (environment !== 'fy.re');

    var url = [
        this._getUrlBase(opts),
        "/bs3/v3.1/",
        includeEnvironment ? opts.environment + "/" : "",
        opts.network,
        "/",
        opts.siteId,
        "/",
        base64.btoa(opts.articleId.toString()),
        "/",
        typeof opts.page !== 'undefined' ? opts.page+'.json' : "init"
    ].join("");

    this._request({
        url: url
    }, callback);
};

/**
 * Get a permalink for a specific comment.
 * @param {Object} opts
 * @param {function()} callback
 */
AnnotationsHttpClient.prototype.getPermalink = function (opts, callback) {
    this._request({
        data: {
            collection_id: opts.collectionId
        },
        url: this._getMessageUrl(opts, '/permalink/')
    }, callback);
};

/**
 * Get an entire thread for a specific content id.
 * @param {Object} opts
 * @param {function()} callback
 */
AnnotationsHttpClient.prototype.getThread = function (opts, callback) {
    this._request({
        data: {
            collection_id: opts.collectionId,
            content_id: opts.contentId
        },
        url: this._getContentUrl(opts, '/thread/')
    }, callback);
};

/**
 * Posts an Annotation to a Livefyre collection.
 * @param opts {Object} The livefyre collection options.
 * @param opts.network {string} The name of the network in the livefyre platform
 * @param opts.environment {?string}
 * @param opts.collectionId {string} The livefyre collectionId for the conversation
 * @param opts.lftoken {string} The livefyre user auth token
 * @param opts.annotation {Annotation} The annotation
 * @param callback {function} A callback with "err/data" interface
 */
AnnotationsHttpClient.prototype.postAnnotation = function (opts, callback) {
    this._request({
        method: 'POST',
        url: this._getCollectionUrl(opts, '/post/annotation/'),
        data: opts.postData
    }, callback);
};

/**
 * Approves a comment.
 * @param {Object} opts
 * @param {function()} callback A callback with "err/data" interface
 */
AnnotationsHttpClient.prototype.postApprove = function (opts, callback) {
    this._request({
        method: 'POST',
        url: this._getMessageUrl(opts, '/approve/'),
        data: {
            lftoken: opts.lftoken,
            collection_id: opts.collectionId
        }
    }, callback);
};

/**
 * Deletes a comment.
 * @param {Object} opts
 * @param {function()} callback A callback with "err/data" interface
 */
AnnotationsHttpClient.prototype.postDelete = function (opts, callback) {
    this._request({
        method: 'POST',
        url: this._getMessageUrl(opts, '/delete/'),
        data: {
            lftoken: opts.lftoken,
            collection_id: opts.collectionId
        }
    }, callback);
};

/**
 * Edits a comment.
 * @param {Object} opts
 * @param {function()} callback A callback with "err/data" interface
 */
AnnotationsHttpClient.prototype.postEdit = function (opts, callback) {
    this._request({
        method: 'POST',
        url: this._getMessageUrl(opts, opts.model.id + '/edit/'),
        data: {
            body: opts.body,
            lftoken: opts.lftoken,
            collection_id: opts.collectionId
        }
    }, callback);
};

/**
 * Posts a flag on a comment.
 * @param {Object} opts
 * @param {function()} callback A callback with "err/data" interface
 */
AnnotationsHttpClient.prototype.postFlag = function (opts, callback) {
    this._request({
        method: 'POST',
        url: this._getMessageUrl(opts, '/flag/' + opts.value + '/'),
        data: {
            lftoken: opts.lftoken,
            collection_id: opts.collectionId
        }
    }, callback);
};

/**
 * Hides a comment.
 * @param {Object} opts
 * @param {function()} callback A callback with "err/data" interface
 */
AnnotationsHttpClient.prototype.postHide = function (opts, callback) {
    this._request({
        method: 'POST',
        url: this._getMessageUrl(opts, '/hide/'),
        data: {
            lftoken: opts.lftoken,
            collection_id: opts.collectionId
        }
    }, callback);
};

/**
 * Posts a vote on an Annotation.
 * @param {Object} opts
 * @param {function()} callback A callback with "err/data" interface
 */
AnnotationsHttpClient.prototype.postVote = function (opts, callback) {
    var postData = {
        lftoken: opts.lftoken,
        collection_id: opts.collectionId,
        message_id: opts.messageId,
        value: opts.value
    };

    this._request({
        method: 'POST',
        url: this._getMessageUrl(opts, '/vote/'),
        data: postData
    }, callback);
};

/**
 * Fetches the hydrated comments for this ref batch
 * @param opts {Object} The livefyre collection options.
 * @param opts.network {string} The name of the network in the livefyre platform
 * @param opts.environment {?string}
 * @param opts.collectionId {string} The livefyre collectionId for the conversation
 * @param opts.refs {Array.<string>}
 * @param callback {function} A callback that is called upon success/failure of the
 * stream request. Callback signature is "function(error, data)".
 */
AnnotationsHttpClient.prototype.fetchErefs = function (opts, callback) {
    callback = callback || function() {};

    var url = [
        this._getUrlBase(opts),
        '/api/v3.0/collection/',
        opts.collectionId,
        '/erefs/'
    ].join('');

    this._request({
        url: url,
        data: $.param({ 'ref': opts.refs, 'expanded': 1 }, true)  // "Traditional" style array serialization w/o "[]" symbol.
    }, callback);
};

module.exports = AnnotationsHttpClient;

});

define('streamhub-sdk/collection/clients/bootstrap-client',[
    'streamhub-sdk/collection/clients/http-client',
    'inherits',
    'base64'],
function(LivefyreHttpClient, inherits, base64) {
    

    /**
     * A Client for requesting Livefyre's Bootstrap Service
     * @exports streamhub-sdk/collection/clients/bootstrap-client
     */
    var LivefyreBootstrapClient = function (opts) {
        opts = opts || {};
        opts.serviceName = 'bootstrap';
        this._version = opts.version;
        LivefyreHttpClient.call(this, opts);
    };

    inherits(LivefyreBootstrapClient, LivefyreHttpClient);

    LivefyreBootstrapClient.prototype._serviceName = 'bootstrap';

    /**
     * Fetches data from the livefyre bootstrap service with the arguments given.
     * @param opts {Object} The livefyre collection options.
     * @param opts.network {string} The name of the network in the livefyre platform
     * @param opts.siteId {string} The livefyre siteId for the conversation
     * @param opts.articleId {string|number} The livefyre articleId for the conversation
     * @param [opts.page] {string} Livefyre page name or number to fetch from bootstrap
     *     (default "init")
     * @param [opts.environment] {string} Optional livefyre environment to use dev/prod environment
     * @param [opts.version] {string} Version string to include in Bootstrap API
     *     resource paths. By default, one will not be added, which usually means '3.0'
     * @param callback {function} A callback that is called upon success/failure of the
     *     bootstrap request. Callback signature is "function(error, data)".
     */
    LivefyreBootstrapClient.prototype.getContent = function(opts, callback) {
        opts = opts || {};
        callback = callback || function() {};
        var environment = opts.environment = opts.environment || 'livefyre.com';
        var includeEnvironment = (environment !== 'livefyre.com') && (environment !== 'fyre') && (environment !== 'fy.re');
        var url = [
            this._getUrlBase(opts),
            "/bs3/",
            this._version ? this._version + '/' : '',
            includeEnvironment ? opts.environment + "/" : "",
            opts.network,
            "/",
            opts.siteId,
            "/",
            base64.url.btoa(opts.articleId.toString()),
            "/",
            typeof opts.page !== 'undefined' ? opts.page+'.json' : "init"
        ].join("");

        this._request({
            url: url
        }, callback);
    };

    return LivefyreBootstrapClient;
});

define('streamhub-sdk/collection/streams/archive',[
    'streamhub-sdk/jquery',
    'stream/readable',
    'streamhub-sdk/collection/clients/bootstrap-client',
    'streamhub-sdk/content/state-to-content',
    'streamhub-sdk/debug',
    'stream/util',
    'inherits'],
function ($, Readable, BootstrapClient, StateToContent, debug, streamUtil,
inherits) {
    


    var log = debug('streamhub-sdk/collection/streams/archive');


    /**
     * A Readable Stream that emits Content for a Livefyre Collection as
     *     sourced from StreamHub's Bootstrap APIs. This Stream emits Content
     *     in descending order by bootstrap page
     * @param opts {object} Configuration options
     * @param opts.network {string} The StreamHub Network of the Collection
     * @param opts.siteId {string} The StreamHub Site ID of the Collection
     * @param opts.articleId {string} The StreamHub Aritcle ID of the Collection
     * @param [opts.environment] {string} If not production, the hostname of the
     *     StreamHub environment the Collection resides on
     * @param [opts.bootstrapClient] {LivefyreBootstrapClient} A Client object
     *     that can request StreamHub's Bootstrap web service
     * @param [opts.replies=false] {boolean} Whether to read out reply Content
     * @param [opts.comparator] Indicate the order in which you'd like to read
     *     the archive. Default is CollectionArchive.comparators.CREATED_AT_DESCENDING
     *     (newest first). You can also pass other values of CollectionArchive.comparators
     */
    var CollectionArchive = function (opts) {
        opts = opts || {};

        this._collection = opts.collection;

        this._bootstrapClient = opts.bootstrapClient || new BootstrapClient();
        this._contentIdsInHeadDocument = [];
        this._replies = opts.replies || false;
        this._comparator = opts.comparator || CollectionArchive.comparators.CREATED_AT_DESCENDING;

        Readable.call(this, opts);
    };

    inherits(CollectionArchive, Readable);

    /**
     * Comparators that determine the order in which to get data out of the
     * archive
     */
    CollectionArchive.comparators = {
        CREATED_AT_ASCENDING: 'CREATED_AT_ASCENDING',
        CREATED_AT_DESCENDING: 'CREATED_AT_DESCENDING'
    };

    /**
     * Called by Readable base class. Do not call directly
     * Get content from bootstrap and .push() onto the read buffer
     * @private
     */
    CollectionArchive.prototype._read = function () {
        log('_read', 'Buffer length is ' + this._readableState.buffer.length);
        // The first time this is called, we first need to get Bootstrap init
        // to know what the latest page of data
        if (typeof this._nextPage === 'undefined') {
            return this._readFirstPage();
        }
        // After that, request the latest page
        // unless there are no more pages, in which case we're done
        if (this._nextPage === null) {
            return this.push(null);
        }
        if (typeof this._nextPage === 'number') {
            this._readNextPage();
        }
    };

    /**
     * Read the first page of data from the archive.
     * Depending on the comparator, this will either be the 0th page or the
     * init page
     * Then set the appropriate ._nextPage value
     * @private
     */
    CollectionArchive.prototype._readFirstPage = function () {
        var self = this;
        // If ascending, we start at page 0 and will go up from there
        if (this._comparator === CollectionArchive.comparators.CREATED_AT_ASCENDING) {
            this._nextPage = 0;
            this._readNextPage();
            return;
        }
        // Otherwise, we need to get the first page of data from the init document
        // and note the total number of pages, and work our way down to 0 from there
        return this._collection.initFromBootstrap(function (err, initData) {
            var headDocument = initData.headDocument,
                collectionSettings = initData.collectionSettings,
                archiveInfo = collectionSettings && collectionSettings.archiveInfo,
                numPages = archiveInfo && archiveInfo.nPages;

            if (numPages === 0) {
                self.push(null);
                return;
            }

            var contents = self._contentsFromBootstrapDoc(headDocument, {
                isHead: true
            });

            // Bootstrap pages are zero-based. Store the highest 
            self._nextPage = numPages - 1;

            // If we couldn't create any Content from the headDocument
            // e.g. they were all premodded, push nothing and read again
            // soon
            if ( ! contents.length) {
                // Push nothing for now.
                self.push();
                // But trigger another _read cycle ASAP
                // This gives the internals a chance to check paused state
                streamUtil.nextTick(function () {
                    self.read(0);
                });
                return;
            }
            self.push.apply(self, contents);
        });
    };

    /**
     * Read the next Page of data from the Collection
     * And make sure not to emit any state.events that were in the headDocument
     * ._push will eventually be called.
     * @private
     */
    CollectionArchive.prototype._readNextPage = function () {
        var self = this,
            bootstrapClientOpts = this._getBootstrapClientOptions();
        this._nextPage = this._getNextPageName();
        this._bootstrapClient.getContent(bootstrapClientOpts, function (err, data) {
            var requestedPage = bootstrapClientOpts.page;
            if (err && err.statusCode === 404) {
                log('404 when requesting page '+requestedPage+'. Must be end of archive');
                self._nextPage = null;
                self._read();
                return;
            }
            if (err || ! data) {
                self.emit('error', new Error('Error requesting Bootstrap page '+bootstrapClientOpts.page));
                return;
            }

            var contents = self._contentsFromBootstrapDoc(data);

            if ( ! contents.length) {
                // Everything was a duplicate... fetch next page
                return self._read();
            }
            self.push.apply(self, contents);
        });
    };

    /**
     * Get the value to pass as the `page` param to the bootstrapClient
     * To get the next page of data
     * It should increment or decrement from the last page value, depending
     * on this Archive's comparator
     */
    CollectionArchive.prototype._getNextPageName = function () {
        var curPage = this._nextPage;
        var nextPage;
        switch (this._comparator) {
            case CollectionArchive.comparators.CREATED_AT_ASCENDING:
                nextPage = curPage + 1;
                break;
            case CollectionArchive.comparators.CREATED_AT_DESCENDING:
                nextPage = curPage - 1;
                if (nextPage < 0) {
                    nextPage = null;
                }
                break;
        }
        return nextPage;
    };

    /**
     * Get options to pass to this._bootstrapClient methods to specify
     * which Collection we care about
     * @private
     */
    CollectionArchive.prototype._getBootstrapClientOptions = function () {
        return {
            environment: this._collection.environment,
            network: this._collection.network,
            siteId: this._collection.siteId,
            articleId: this._collection.articleId,
            page: this._nextPage
        };
    };


    /**
     * Convert a bootstrapDocument to an array of Content models
     * @private
     * @param bootstrapDocument {object} an object with content and authors keys
     *     e.g. http://bootstrap.livefyre.com/bs3/livefyre.com/4/NTg0/0.json
     * @return {Content[]} An array of Content models
     */
    CollectionArchive.prototype._contentsFromBootstrapDoc = function (bootstrapDoc, opts) {
        opts = opts || {};
        bootstrapDoc = bootstrapDoc || {};
        var self = this,
            states = bootstrapDoc.content || [],
            state,
            stateContentId,
            content,
            contents = [];

        if (this._collection) {
            bootstrapDoc.collection = this._collection;
        }
        var stateToContent = this._createStateToContent(bootstrapDoc);

        stateToContent.on('data', function (content) {
            if (! content ||
                self._contentIdsInHeadDocument.indexOf(content.id) !== -1) {
                return;
            }
            if (opts.isHead && content.id) {
                self._contentIdsInHeadDocument.push(content.id);
            }
            contents.push(content);
        });

        for (var i=0, statesCount=states.length; i < statesCount; i++) {
            state = states[i];
            stateContentId = state.content && state.content.id;
            // Don't write in states that we already wrote in from the
            // headDocument, as they'll cause unnecessary changes
            // and rerenders to Content in storage
            if (stateContentId && this._contentIdsInHeadDocument.indexOf(stateContentId) !== -1) {
                continue;
            }
            content = stateToContent.write(state);
        }

        contents = this._sortContents(contents);
        log("created contents from bootstrapDoc", contents);
        return contents;
    };

    /**
     * Sort an array of Contents in the ideal order for this archive's
     * comparator.
     */
    CollectionArchive.prototype._sortContents = function (contentList) {
        var contentListComparator;
        var sortedContentList;
        if (this._comparator === CollectionArchive.comparators.CREATED_AT_ASCENDING) {
            contentListComparator = function (contentA, contentB) {
                return contentA.createdAt - contentB.createdAt;
            };
        } else {
            // Must be descending. That's the default.
            // Change this if there are ever 3 comparator options
            contentListComparator = function (contentA, contentB) {
                return contentB.createdAt - contentA.createdAt;
            };
        }
        sortedContentList = contentList.sort(contentListComparator);
        return sortedContentList;
    };

    /**
     * Create a StateToContent Transform that will have states written in,
     * and should read out Content instances
     */
    CollectionArchive.prototype._createStateToContent = function (opts) {
        opts = opts || {};
        opts.replies = this._replies;
        return new StateToContent(opts);
    };


    return CollectionArchive;
});

define('streamhub-sdk/collection/clients/stream-client',[
    'streamhub-sdk/collection/clients/http-client',
    'inherits'],
function(LivefyreHttpClient, inherits) {
    

    /**
     * A Client for requesting Livefyre's Stream Service
     * @exports streamhub-sdk/collection/clients/stream-client
     */
    var LivefyreStreamClient = function (opts) {
        opts = opts || {};
        opts.serviceName = 'stream1';
        LivefyreHttpClient.call(this, opts);
    };

    inherits(LivefyreStreamClient, LivefyreHttpClient);

    LivefyreStreamClient.prototype._serviceName = 'stream1';

    /**
     * Fetches content from the livefyre conversation stream with the supplied arguments.
     * @param opts {Object} The livefyre collection options.
     * @param opts.network {string} The name of the network in the livefyre platform
     * @param opts.collectionId {string} The livefyre collectionId for the conversation stream
     * @param opts.commentId {?string} The commentId to fetch content from (default "0")
     * @param callback {function} A callback that is called upon success/failure of the
     * stream request. Callback signature is "function(error, data)".
     */
    LivefyreStreamClient.prototype.getContent = function(opts, callback) {
        opts = opts || {};
        callback = callback || function() {};

        var url = [
            this._getUrlBase(opts),
            "/v3.0/collection/",
            opts.collectionId,
            "/",
            opts.commentId || "0",
            "/"
        ].join("");

        var request = this._request({
            url: url
        }, function (err, data) {
            if (err) {
                return callback.apply(this, arguments);
            }
            if (data.timeout) {
                return callback(null, { timeout: data.timeout });
            }
            if (data.status === 'error') {
                return callback(data.msg);
            }
            callback(null, data.data);
        });

        return request;
    };

    return LivefyreStreamClient;
});
define('streamhub-sdk/collection/streams/updater',[
    'inherits',
    'stream/readable',
    'stream/util',
    'streamhub-sdk/collection/clients/bootstrap-client',
    'streamhub-sdk/collection/clients/stream-client',
    'streamhub-sdk/content/state-to-content',
    'streamhub-sdk/content/annotator',
    'streamhub-sdk/debug'],
function (inherits, Readable, streamUtil, BootstrapClient, StreamClient,
StateToContent, Annotator, debug) {
    


    var log = debug('streamhub-sdk/collection/streams/updater');


    /**
     * A Readable Stream to access streaming updates in a StreamHub Collection
     * @param opts {object}
     * @param opts.network {string} The StreamHub Network of the Collection
     * @param opts.siteId {string} The Site ID of the Collection
     * @param opts.articleId {string} The Article ID of the Collection
     * @param [opts.environment] {string} Which StreamHub Cluster the Collection
     *     resides on (e.g. t402.livefyre.com for UAT)
     * @param [opts.streamClient] {LivefyreStreamClient} A Client object that
     *     can request StreamHub's Stream web service
     * @param [opts.bootstrapClient] {LivefyreBootstrapClient} A Client object
     *     that can request StreamHub's Bootstrap web service
     * @param [opts.replies=false] {boolean} Whether to read out reply Content
     * @param [opts.createStateToContent] {function} Creates a custem Content adapter
     */
    var CollectionUpdater = function (opts) {
        opts = opts || {};
        this._collection = opts.collection;
        this._streamClient = opts.streamClient || new StreamClient();
        this._request = null;
        this._replies = opts.replies || false;
        if (opts.createStateToContent) {
            this._createStateToContent = opts.createStateToContent;
        }
        if (opts.createAnnotator) {
            this._createAnnotator = opts.createAnnotator;
        }
        Readable.call(this, opts);
    };

    inherits(CollectionUpdater, Readable);


    /**
     * Called by Readable base class on .read(). Do not call directly.
     * Get content from bootstrap and .push() onto the read buffer
     * @private
     */
    CollectionUpdater.prototype._read = function () {
        var self = this;
        log('_read', 'Buffer length is ' + this._readableState.buffer.length);

        if ( ! this._latestEvent || ! this._collection.id) {
            // Get the latest event and/or collection ID by initing
            // the collection from bootstrap
            return this._collection.initFromBootstrap(function (err, initData) {
                var collectionSettings = initData.collectionSettings;
                var headDocument = initData.headDocument;

                // Use the event value from the headDocument (new) over the
                // collectionSettings dict because it's newer. If it's not set
                // in headDocument, use the collectionSettings version.
                var latestEvent = headDocument && headDocument.event;
                latestEvent = latestEvent || collectionSettings && collectionSettings.event;

                if ( ! self._collection.id) {
                    throw new Error("Couldn't get Collection ID after initFromBootstrap");
                }
                if (latestEvent === undefined) {
                    throw new Error("Couldn't get latestEvent after initFromBootstrap");
                }
                self._latestEvent = latestEvent;
                self._stream();
            });
        }

        self._stream();
    };


    /**
     * Make the next stream request to get more data since the last seen event
     * @private
     */
    CollectionUpdater.prototype._stream = function () {
        var self = this,
            streamClient = this._streamClient,
            streamClientOpts = this._getStreamClientOptions();

        var request = streamClient.getContent(streamClientOpts, function (err, data) {
            if (err && err.message === 'abort') {
                log('stream request aborted');
                self.push();
                return;
            }
            if (err) {
                return self.emit('error', err);
            }
            if (data.timeout) {
                // Timed out on the long poll. This just means there
                // was no real-time data. So we should keep streaming
                // on the next event loop tick
                log('long poll timeout, requesting again on next tick');
                return pollAgain();
            }
            var contents = self._contentsFromStreamData(data);
            // Update _latestEvent so we only get new data
            self._latestEvent = data.maxEventId;

            if (contents.length) {
                self.push.apply(self, contents);
                // _read will get called again when more data is needed
            } else {
                return pollAgain();
            }

            function pollAgain() {
                // Push nothing for now.
                self.push();
                // But trigger another _read cycle ASAP
                // This gives the internals a chance to check paused state
                streamUtil.nextTick(function () {
                    self.read(0);
                });
            }
        });

        this._request = request;
    };


    /**
     * Pause the Updater
     * Including killing the active stream request
     */
    CollectionUpdater.prototype.pause = function () {
        if (this._request) {
            this._request.abort();
            this._request = null;
        }
        return Readable.prototype.pause.apply(this, arguments);
    };


    /**
     * Convert a response from the Stream service into Content models
     * @private
     * @param streamData {object} A response from the Stream service
     * @return {Content[]} An Array of Content models
     */
    CollectionUpdater.prototype._contentsFromStreamData = function (streamData) {
        var annotationDiff,
            annotator = this._createAnnotator(),
            annotations = streamData.annotations,
            contentId,
            contents = [],
            state,
            states = streamData.states,
            stateToContent = this._createStateToContent(streamData);

        stateToContent.on('data', function (content) {
            contents.push(content);
        });

        for (contentId in states) {
            if (states.hasOwnProperty(contentId)) {
                state = states[contentId];
                stateToContent.write(state);
            }
        }

        for (contentId in annotations) {
            if (annotations.hasOwnProperty(contentId)) {
                annotationDiff = annotations[contentId];
                annotator.write({
                    contentId: contentId,
                    annotationDiff: annotationDiff
                });
            }
        }

        return contents;
    };


    /**
     * Get an Object that can be passed to LivefyreStreamClient to get new
     * data
     * @private
     * @return {object}
     */
    CollectionUpdater.prototype._getStreamClientOptions = function () {
        return {
            collectionId: this._collection.id,
            network: this._collection.network,
            environment: this._collection.environment,
            commentId: this._latestEvent
        };
    };

    /**
     * Create a StateToContent Transform that will have states written in,
     * and should read out Content instances
     */
    CollectionUpdater.prototype._createStateToContent = function (opts) {
        opts = opts || {};
        opts.replies = this._replies;
        opts.collection = this._collection;
        return new StateToContent(opts);
    };

    /**
     * Create an Annotator that will mutate Content in Storage.
     */
    CollectionUpdater.prototype._createAnnotator = function () {
        return new Annotator();
    };

    return CollectionUpdater;
});

define('streamhub-sdk/collection/clients/write-client',[
    'streamhub-sdk/collection/clients/http-client',
    'inherits'],
function(LivefyreHttpClient, inherits) {
    

    /**
     * A Client for requesting Livefyre's Quill/Write Service
     * @exports streamhub-sdk/collection/clients/write-client
     */
    var LivefyreWriteClient = function (opts) {
        opts = opts || {};
        opts.serviceName = 'quill';
        LivefyreHttpClient.call(this, opts);
    };

    inherits(LivefyreWriteClient, LivefyreHttpClient);

    /**
     * Posts a piece of content to a Livefyre collection.
     * @param opts {Object} The livefyre collection options.
     * @param opts.network {string} The name of the network in the livefyre platform
     * @param opts.collectionId {string} The livefyre collectionId for the conversation
     * @param opts.lftoken {string} The livefyre user auth token
     * @param opts.body {string} The content's body html with the following allowed tags:
     *     a, img, span, label, p, br, strong, em, u, blockquote, ul, li, ol, pre
     * @param opts.media {array} An Array of oEmbed JSON Objects to attach to the posted Content
     * @param callback {function} A callback that is called upon success/failure of the
     *     write request. Callback signature is "function(error, data)".
     */
    LivefyreWriteClient.prototype.postContent = function (opts, callback) {
        opts = opts || {};
        callback = callback || function() {};
        var url = [
            this._getUrlBase(opts),
            "/api/v3.0/collection/",
            opts.collectionId,
            "/post/"
        ].join("");

        var postData = {
            body: opts.body,
            lftoken: opts.lftoken
        };

        if (opts.parent_id) {
            postData.parent_id = opts.parent_id;
        }

        if (opts.media) {
            postData.attachments = JSON.stringify(opts.media);
        }

        this._request({
            method: 'POST',
            url: url,
            data: postData
        }, callback);
    };

    /**
     * Posts a tweet to a Livefyre collection.
     * @param opts {Object} The livefyre collection options.
     * @param opts.network {string} The name of the network in the livefyre platform
     * @param opts.collectionId {string} The livefyre collectionId for the conversation
     * @param opts.lftoken {string} The livefyre user auth token
     * @param opts.tweetId {string} The Tweet ID of the tweet to add to the Collection
     * @param callback {function} A callback that is called upon success/failure of the
     *     write request. Callback signature is "function(error, data)".
     */
    LivefyreWriteClient.prototype.postTweet = function (opts, callback) {
        opts = opts || {};
        callback = callback || function() {};
        var url = [
            this._getUrlBase(opts),
            "/api/v3.0/collection/",
            opts.collectionId,
            "/post/tweet/"
        ].join("");

        var postData = {tweet_id: opts.tweetId, lftoken: opts.lftoken};

        this._request({
            method: 'POST',
            url: url,
            data: postData
        }, callback);
    };

    LivefyreWriteClient.prototype.follow = function (opts, callback) {
        opts = opts || {};
        callback = callback || function() {};
        var url = [
            this._getUrlBase(opts),
            "/api/v3.0/collection/",
            opts.collectionId,
            "/follow/"
        ].join("");

        var postData = {lftoken: opts.lftoken};

        this._request({
            method: 'POST',
            url: url,
            data: postData
        }, callback);
    };

    LivefyreWriteClient.prototype.unfollow = function (opts, callback) {
        opts = opts || {};
        callback = callback || function() {};
        var url = [
            this._getUrlBase(opts),
            "/api/v3.0/collection/",
            opts.collectionId,
            "/unfollow/"
        ].join("");

        var postData = {lftoken: opts.lftoken};

        this._request({
            method: 'POST',
            url: url,
            data: postData
        }, callback);
    };

    LivefyreWriteClient.prototype.like = function (opts, callback) {
        opts = opts || {};
        callback = callback || function () {};
        var url = [
            this._getUrlBase(opts),
            '/api/v3.0/message/',
            opts.contentId,
            '/like/'
        ].join("");

        var postData = {
            lftoken: opts.lftoken,
            collection_id:  opts.collectionId
        };

        this._request({
            method: 'POST',
            url: url,
            data: postData
        }, callback);
    };

    LivefyreWriteClient.prototype.unlike = function (opts, callback) {
        opts = opts || {};
        callback = callback || function () {};
        var url = [
            this._getUrlBase(opts),
            '/api/v3.0/message/',
            opts.contentId,
            '/unlike/'
        ].join("");

        var postData = {
            lftoken: opts.lftoken,
            collection_id:  opts.collectionId
        };

        this._request({
            method: 'POST',
            url: url,
            dataType: 'json',
            data: postData
        }, callback);
    };

    return LivefyreWriteClient;
});

define('streamhub-sdk/auth/main',['auth', 'inherits', 'event-emitter', 'streamhub-sdk/debug'],
function (auth, inherits, EventEmitter, debug) {
    


    var log = debug('streamhub-sdk/auth');


    /**
     * An object that knows about the authenticated user
     */
    var Auth = new EventEmitter();


    /**
     * Set the Auth token
     * This is deprecated now. You should use the `auth` module's
     * `.authenticate({ livefyre: token })` method
     * But will be supported in streamhub-sdk v2 for backward compatability
     * @param token {string} A Livefyre authentication token,
     *     as described at http://bit.ly/17SYaoT
     */
    Auth.setToken = function (token) {
        log('.setToken', token);
        this._token = token;
        this.emit('token', token);
    };


    /**
     * Get the Auth token
     * @return A token, if one has been set, else undefined
     */
    Auth.getToken = function () {
        var livefyreUser = auth.get('livefyre');
        if ( ! livefyreUser) {
            return this._token;
        }
        return livefyreUser.get('token');
    };


    /**
     * An Error that represents that an operation could not be performed
     * because the user has not been authorized. Semantics like HTTP 401
     */
    var UnauthorizedError = function (message) {
        Error.apply(this, arguments);
        this.message = message;
    };
    inherits(UnauthorizedError, Error);
    UnauthorizedError.prototype.name = "UnauthorizedError";


    Auth.UnauthorizedError = UnauthorizedError;
    return Auth;
});

define('streamhub-sdk/auth', ['streamhub-sdk/auth/main'], function (main) { return main; });

define('streamhub-sdk/collection/streams/writer',[
    'stream/writable',
    'streamhub-sdk/collection/clients/write-client',
    'streamhub-sdk/auth',
    'inherits'],
function (Writable, LivefyreWriteClient, Auth, inherits) {
    


    var CollectionWriter = function (opts) {
        this._collection = opts.collection;
        this._writeClient = opts.writeClient || new LivefyreWriteClient();
        Writable.call(this, opts);
    };

    inherits(CollectionWriter, Writable);


    CollectionWriter.prototype._write = function _write(content, done) {
        var self = this,
            collection = this._collection,
            token = Auth.getToken(),
            post = this._writeClient.postContent,
            numAttachments = content.attachments && content.attachments.length;

        if ( ! token) {
            throw new Auth.UnauthorizedError("Collection cannot write until streamhub-sdk/auth.setToken has been called");
        }

        if ( ! collection.id) {
            return collection.initFromBootstrap(function () {
                _write.call(self, content, done);
            });
        }

        var postParams = {
            body: content.body,
            collectionId: collection.id,
            environment: collection.environment,
            lftoken: Auth.getToken(),
            network: collection.network
        };

        if (numAttachments) {
            var attachment;
            postParams.media = [];
            for (var i=0; i < numAttachments; i++) {
                attachment = content.attachments[i];
                if (typeof attachment.toJSON === 'function') {
                    attachment = attachment.toJSON();
                }
                postParams.media.push(attachment);
            }
        }

        if (content.parentId) {
            postParams.parent_id = content.parentId;
        }

        // Tweets can be posted by ID via _writeClient.postTweet
        if (content.tweetId) {
            post = this._writeClient.postTweet;
            postParams.tweetId = content.tweetId;
        }

        post.call(this._writeClient, postParams, function (err, response) {
            if (err) {
                return done(err);
            }
            content.set({
                collection: this._collection,
                id: response.data.messages[0].content.id
            });
            done();
        }.bind(this));
    };


    return CollectionWriter;
});

define('streamhub-sdk/collection/streams/featured-archive',[
    'streamhub-sdk/jquery',
    'stream/readable',
    'streamhub-sdk/collection/clients/bootstrap-client',
    'streamhub-sdk/content/state-to-content',
    'streamhub-sdk/debug',
    'inherits'],
function ($, Readable, BootstrapClient, StateToContent, debug, inherits) {
    


    var log = debug('streamhub-sdk/collection/streams/featured-archive');


    /**
     * A Readable Stream that emits Featured Content for a Livefyre Collection.
     *     This Stream emits Content in descending order by featured value.
     * @param opts {object} Configuration options
     * @param opts.collection {string} The Collection to get Featured Content for
     * @param [opts.bootstrapClient] {LivefyreBootstrapClient} A Client object
     *     that can request StreamHub's Bootstrap web service
     */
    var FeaturedArchive = function (opts) {
        opts = opts || {};

        this._collection = opts.collection;
        this._fetchedHead = false;
        this._bootstrapClient = opts.bootstrapClient || new BootstrapClient();
        this._contentIdsInHeadDocument = [];

        Readable.call(this, opts);
    };

    inherits(FeaturedArchive, Readable);


    /**
     * Called by Readable base class. Do not call directly
     * Get content from bootstrap and .push() onto the read buffer
     * @private
     */
    FeaturedArchive.prototype._read = function () {
        var self = this;

        log('_read', 'Buffer length is ' + this._readableState.buffer.length);

        // The first time this is called, we first need to get Bootstrap init
        // to get the featured head and to know if there are more past that
        if ( ! this._fetchedHead) {
            return this._collection.initFromBootstrap(function (err, initData) {
                var featuredHead = initData.featured;

                if ( ! featuredHead) {
                    // There are no featured items. end
                    return self.push(null);
                }

                // If featured.isComplete is false, then there is more featured
                // content at the featured-all bootstrap page
                self._nextPage = featuredHead.isComplete ? null : 'featured-all';

                var contents = self._contentsFromBootstrapDoc(featuredHead, {
                    isHead: true
                });

                self._fetchedHead = true;

                self.push.apply(self, contents);
            });
        }
        // After that, request featured-all
        if (this._nextPage === null) {
            return this.push(null);
        }
        if (this._nextPage) {
            this._readNextPage();
        }
    };


    /**
     * Read the next Page of data from the Collection
     * And make sure not to emit any state.events that were in the headDocument
     * ._push will eventually be called.
     * @private
     */
    FeaturedArchive.prototype._readNextPage = function () {
        var self = this,
            bootstrapClientOpts = this._getBootstrapClientOptions();

        // There is only one extra page of featured content: featured-all
        this._nextPage = null;

        this._bootstrapClient.getContent(bootstrapClientOpts, function (err, data) {
            if (err || ! data) {
                self.emit('error', new Error('Error requesting Bootstrap page '+bootstrapClientOpts.page));
                return;
            }

            var contents = self._contentsFromBootstrapDoc(data);

            if ( ! contents.length) {
                // Everything was a duplicate... fetch next page
                return self._read();
            }
            self.push.apply(self, contents);
        });
    };


    /**
     * Get options to pass to this._bootstrapClient methods to specify
     * which Collection we care about
     * @private
     */
    FeaturedArchive.prototype._getBootstrapClientOptions = function () {
        return {
            environment: this._collection.environment,
            network: this._collection.network,
            siteId: this._collection.siteId,
            articleId: this._collection.articleId,
            page: this._nextPage
        };
    };


    /**
     * Convert a bootstrapDocument to an array of Content models
     * @private
     * @param bootstrapDocument {object} an object with content and authors keys
     *     e.g. http://bootstrap.livefyre.com/bs3/livefyre.com/4/NTg0/0.json
     * @return {Content[]} An array of Content models
     */
    FeaturedArchive.prototype._contentsFromBootstrapDoc = function (bootstrapDoc, opts) {
        opts = opts || {};
        bootstrapDoc = bootstrapDoc || {};
        var self = this,
            states = bootstrapDoc.content || [],
            stateToContent = new StateToContent(bootstrapDoc),
            state,
            content,
            contents = [];

        stateToContent.on('data', function (content) {
            if (! content ||
                self._contentIdsInHeadDocument.indexOf(content.id) !== -1) {
                return;
            }
            if (opts.isHead && content.id) {
                self._contentIdsInHeadDocument.push(content.id);
            }
            contents.push(content);
        });

        for (var i=0, statesCount=states.length; i < statesCount; i++) {
            state = states[i];
            content = stateToContent.write(state);
        }

        log("created contents from bootstrapDoc", contents);
        return contents;
    };


    return FeaturedArchive;
});

define('streamhub-sdk/collection/featured-contents',[
    'streamhub-sdk/collection/streams/featured-archive'],
function (FeaturedArchive) {
    

    /**
     * An Object that represents the featured Contents in a StreamHub
     * Collection
     * @param opts {object} Options
     * @param opts.collection {streamhub-sdk/collection} The Collection in which
     *     you care about featured Content
     */
    var FeaturedContents = function (opts) {
        opts = opts || {};
        this._collection = opts.collection;
    };

    /**
     * Create a readable stream that will read through the Archive of Featured
     * Contents in the Collection.
     * @param opts {object}
     * @returns {streamhub-sdk/collection/streams/featured-archive}
     */
    FeaturedContents.prototype.createArchive = function (opts) {
        opts = opts || {};
        opts.collection = this._collection;
        return new FeaturedArchive(opts);
    };

    return FeaturedContents;
});
define('streamhub-sdk/collection/clients/create-client',[
    'streamhub-sdk/collection/clients/http-client',
    'inherits'],
function(LivefyreHttpClient, inherits) {
    

    /**
     * A Client for creating a Livefyre collection
     * @exports streamhub-sdk/collection/clients/create-client
     */
    var LivefyreCreateClient = function (opts) {
        opts = opts || {};
        opts.serviceName = 'quill';
        LivefyreHttpClient.call(this, opts);
    };

    inherits(LivefyreCreateClient, LivefyreHttpClient);

    /**
     * @callback createCollectionCallback
     * @param [error] {Object|string} 
     * @param [data] {Object}
     */
    
    /**
     * @typedef CollectionMeta {(Object|string)} This is an object or a token string
     *          (per https://github.com/Livefyre/livefyre-docs/wiki/StreamHub-Integration-Guide)
     *          that contains data required for creating a collection.
     * @property [title] {string} Optional title for the new collection.
     * @property url {string} Required when not signed. URL of the page creating the collection.
     * @property [tags] {Array.<string>} Optional list of tag names.
     */
    
    /**
     * Fetches data from the livefyre bootstrap service with the arguments given.
     * @param opts {Object} The livefyre collection options.
     * @param opts.network {string} The name of the network in the livefyre platform
     * @param opts.siteId {string} The livefyre siteId for the conversation
     * @param opts.articleId {string} The livefyre articleId for the conversation
     * @param [opts.environment] {string} Optional livefyre environment to use dev/prod environment
     * @param [opts.signed] {boolean} Specified true when collectionMeta is a token string.
     * @param [opts.checksum] {string} Required if collectionMeta is a token string.
     * @param opts.collectionMeta {CollectionMeta} The required meta for creating the collection
     * @param callback {createCollectionCallback} A callback that is called upon success/failure of the
     *     bootstrap request. Callback signature is "function(error, data)".
     */
    LivefyreCreateClient.prototype.createCollection = function(opts, callback) {
        callback = callback || function() {};
        var url = [
        //api/v3.0/site/<siteId>/collection/create
            this._getUrlBase(opts),
            '/api/v3.0/site/',
            opts.siteId,
            '/collection/create'
        ].join('');
        
        var collectionMeta = opts.collectionMeta;
        if (!collectionMeta) {
            throw 'User error: Missing collectionMeta.';
        }
        
        var postData = {
                'collectionMeta': collectionMeta
            };
        if (typeof(opts.signed) === 'boolean') {
            postData.signed = opts.signed;
        }
        if (!postData.signed) {
            postData.collectionMeta.articleId = opts.articleId;
            if (opts.collectionMeta.tags) {
                postData.collectionMeta.tags = opts.collectionMeta.tags.join(',');
            }
        }
        if (opts.checksum) {
            postData.checksum = opts.checksum;
        }
        postData = JSON.stringify(postData);

        this._request({
            method: 'POST',
            url: url,
            dataType: 'json',
            data: postData
        }, callback);
    };

    return LivefyreCreateClient;
});

define('streamhub-sdk/collection/main',[
    'streamhub-sdk/collection/streams/archive',
    'streamhub-sdk/collection/streams/updater',
    'streamhub-sdk/collection/streams/writer',
    'streamhub-sdk/collection/featured-contents',
    'stream/duplex',
    'streamhub-sdk/collection/clients/bootstrap-client',
    'streamhub-sdk/collection/clients/create-client',
    'streamhub-sdk/collection/clients/write-client',
    'streamhub-sdk/auth',
    'inherits',
    'streamhub-sdk/debug'],
function (CollectionArchive, CollectionUpdater, CollectionWriter, FeaturedContents,
        Duplex, LivefyreBootstrapClient, LivefyreCreateClient, LivefyreWriteClient,
        Auth, inherits, debug) {
    


    var log = debug('streamhub-sdk/collection');


    /**
     * An Object that represents a hosted StreamHub Collection
     * @param [opts.replies=false] {boolean} Whether to stream out reply Content
     * from the Archives and Updaters
     */
    var Collection = function (opts) {
        opts = opts || {};
        this.id = opts.id;
        this.network = opts.network;
        this.siteId = opts.siteId;
        this.articleId = opts.articleId;
        this.environment = opts.environment;

        this._collectionMeta = opts.collectionMeta;
        this._signed = opts.signed;
        this._autoCreate = ('autoCreate' in opts) ? opts.autoCreate : Boolean(this._collectionMeta);
        this._maxInitAttempts = opts.maxInitAttempts || 4;
        this._replies = opts.replies || false;

        this._bootstrapClient = opts.bootstrapClient || new LivefyreBootstrapClient();
        this._createClient = opts.createClient || new LivefyreCreateClient();

        // Internal streams
        this._writer = opts.writer || null;
        this._updater = null;
        this._pipedArchives = [];

        Duplex.call(this, opts);
    };

    inherits(Collection, Duplex);


    /**
     * Create a readable stream that will read through the Collection Archive
     * The Collection Archive contains older Content in the Collection
     * @param opts {object}
     * @param [opts.bootstrapClient] {BootstrapClient} A bootstrapClient to
     *     construct the CollectionArchive with
     * @returns {streamhub-sdk/streams/collection-archive}
     */
    Collection.prototype.createArchive = function (opts) {
        opts = opts || {};
        opts.collection = this;
        opts.bootstrapClient = opts.bootstrapClient || this._bootstrapClient;
        opts.replies = opts.replies || this._replies;
        return new CollectionArchive(opts);
    };


    /**
     * Create a Readable Stream that will stream any new updates to the
     * collection like additions, removals, edits, etc.
     */
    Collection.prototype.createUpdater = function (opts) {
        opts = opts || {};
        return new CollectionUpdater({
            collection: this,
            streamClient: opts.streamClient,
            replies: this._replies,
            createStateToContent: opts.createStateToContent,
            createAnnotator: opts.createAnnotator
        });
    };


    Collection.prototype.createWriter = function (opts) {
        opts = opts || {};
        opts.collection = this;
        return new CollectionWriter(opts);
    };


    /**
     * Create a FeaturedContents object representing the featured
     * contents in this Collection
     */
    Collection.prototype.createFeaturedContents = function (opts) {
        opts = opts || {};
        opts.collection = this;
        return new FeaturedContents(opts);
    };


    /**
     * Pipe updates in the Collection the passed destination Writable
     * @param writable {Writable} The destination to pipe udpates to
     * @param opts {object}
     * @param [opts.pipeArchiveToMore=true] Whether to try to pipe
     *     a CollectionArchive to writable.more, if it is also writable
     *     This is helpful when piping to a ListView
     * @param [opts.archivePipeOpts] Options to pass to archive.pipe,
     *     if you use it (defaults to opts param)
     */
    Collection.prototype.pipe = function (writable, opts) {
        var archive;
        opts = opts || {};
        var archivePipeOpts = opts.archivePipeOpts || opts;
        if (typeof opts.pipeArchiveToMore === 'undefined') {
            opts.pipeArchiveToMore = true;
        }

        // If piped to a ListView (or something with a .more),
        // pipe an archive to .more
        if (opts.pipeArchiveToMore && writable.more && writable.more.writable) {
            archive = this.createArchive();
            archive.pipe(writable.more, archivePipeOpts);
            this._pipedArchives.push(archive);
        }

        return Duplex.prototype.pipe.apply(this, arguments);
    };

    /**
     * Pause live updates from this Collection
     */
    Collection.prototype.pause = function () {
        Duplex.prototype.pause.apply(this, arguments);
        if (this._updater) {
            this._updater.pause();
        }
    };

    /**
     * Resume live updates from this Collection
     */
    Collection.prototype.resume = function () {
        Duplex.prototype.resume.apply(this, arguments);
        if (this._updater) {
            this._updater.resume();
        }
    };

    Collection.prototype._read = function () {
        var self = this,
            content;

        // Create an internal updater the first time the Collection is piped
        if ( ! this._updater) {
            this._updater = this.createUpdater();
        }

        content = this._updater.read();

        if ( ! content) {
            // Wait for Content to be available
            return self._updater.on('readable', function readAndPush() {
                var content = self._updater.read();
                if (content) {
                    self._updater.removeListener('readable', readAndPush);
                    self.push(content);
                }
            });
        }

        return this.push(content);
    };


    Collection.prototype._write = function _write (content, done) {
        if ( ! this._writer) {
            this._writer = this.createWriter();
        }
        this._writer.write(content, done);
    };


    Collection.prototype.initFromBootstrap = function (errback) {
        var self = this;
        if (errback) {
            this.once('_initFromBootstrap', errback);
        }
        if (this._isInitingFromBootstrap) {
            return;
        }
        this._isInitingFromBootstrap = true;
        this._getBootstrapInit(function (err, initData) {
            self._isInitingFromBootstrap = false;
            if (err && err.statusCode === 404 && this._autoCreate) {
                this._createCollection(function (err) {
                    // Should always poll for init file to be created. If the
                    // collection successfullly created this time (202), then
                    // we should wait. It it's a conflict (409), then it was
                    // already created and we should wait.
                    if (!err || err.statusCode === 409) {
                        self._pollForBootstrapLoaded();
                    }
                });
                return;
            }
            this._handleInitComplete(err, initData);
        });
    };


    /**
     * Process the bootstrap init complete state. When the init file is fetched,
     * this processes and emits an event.
     * @param {string} err The error string.
     * @param {Object=} initData The data from the init file.
     * @private
     */
    Collection.prototype._handleInitComplete = function (err, initData) {
        if (!initData) {
            throw 'Fatal collection connection error';
        }
        var collectionSettings = initData.collectionSettings;
        this.id = collectionSettings && collectionSettings.collectionId;
        this.emit('_initFromBootstrap', err, initData);
    };


    /**
     * Poll the bootstrap init file to wait for it to be created. If it has
     * reached the max attempts, don't keep doing it.
     * @param {number=} opt_attempt Optional number of attempts made to fetch.
     */
    Collection.prototype._pollForBootstrapLoaded = function (opt_attempt) {
        var attempt = opt_attempt || 1;
        var self = this;
        this._getBootstrapInit(function (err, initData) {
            if (err && err.statusCode === 404) {
                attempt++;
                if (attempt < this._maxInitAttempts) {
                    setTimeout(function () {
                        self._pollForBootstrapLoaded(attempt);
                    }, attempt * 1000);
                }
                return;
            }
            this._handleInitComplete(err, initData);
        });
    };


    /**
     * Request the Bootstrap init endpoint for the Collection to learn about
     * what pages of Content there are. This gets called the first time Stream
     * base calls _read().
     * @private
     * @param errback {function} A callback to be passed (err|null, the number
     *     of pages of content in the collection, the headDocument containing
     *     the latest data)
     */
    Collection.prototype._getBootstrapInit = function (errback) {
        var self = this,
            collectionOpts;

        // Use this._bootstrapClient to request init (init is default when
        // no opts.page is specified)
        collectionOpts = {
            network: this.network,
            siteId: this.siteId,
            articleId: this.articleId,
            environment: this.environment
        };
        this._bootstrapClient.getContent(collectionOpts, function (err, data) {
            if (err) {
                log("Error requesting Bootstrap init", err, data);
            }
            errback.call(self, err, data);
        });
    };


    /**
     * @callback optionalObjectCallback
     * @param [error] {Object}
     */


    /**
     * Request the Create endpoint to create an entirely new collection. This
     * gets called when Bootstrap initialization fails.
     * @private
     * @param errback {optionalObjectCallback} Optional callback to be passed an object on
     *      error or undefined on success.
     */
    Collection.prototype._createCollection = function (errback) {
        if (this._isCreatingCollection) {
            throw 'Attempting to create a collection more than once.';
        }
        this._isCreatingCollection = true;

        var self = this;
        this._autoCreate = false;
        this.once('_createCollection', errback);
        var callback = function (err) {
            self._isCreatingCollection = false;
            if (err) {
                log("Error requesting collection creation", err);
            }
            self.emit('_createCollection', err);
        };

        // Use this._createClient to request a collection creation
        var collectionOpts = {
            network: this.network,
            siteId: this.siteId,
            articleId: this.articleId,
            environment: this.environment,
            collectionMeta: this._collectionMeta,
            signed: this._signed
        };
        this._createClient.createCollection(collectionOpts, callback);
    };


    return Collection;
});

define('streamhub-sdk/collection', ['streamhub-sdk/collection/main'], function (main) { return main; });

define('eref/arc4',['require','exports','module'],function (require, exports, module) {/**
 * @fileoverview ARC4 streamcipher implementation.  A description of the
 * algorithm can be found at:
 * http://www.mozilla.org/projects/security/pki/nss/draft-kaukonen-cipher-arcfour-03.txt.
 *
 * Original implemention found at: http://docs.closure-library.googlecode.com/git/closure_goog_crypt_arc4.js.source.html
 *
 * Usage:
 * <code>
 *   var arc4 = new Arc4();
 *   arc4.setKey(key);
 *   arc4.discard(1536);
 *   arc4.crypt(bytes);
 * </code>
 */

/**
 * ARC4 streamcipher implementation.
 * @constructor
 */
function Arc4() {
    /**
     * A permutation of all 256 possible bytes.
     * @type {Array.<number>}
     * @private
     */
    this._state = [];

    /**
     * 8 bit index pointer into this._state.
     * @type {number}
     * @private
     */
    this._index1 = 0;

    /**
     * 8 bit index pointer into this._state.
     * @type {number}
     * @private
     */
    this._index2 = 0;
}


/**
 * Initialize the cipher for use with new key.
 * @param {Array.<number>} key A byte array containing the key.
 * @param {number=} opt_length Indicates # of bytes to take from the key.
 */
Arc4.prototype.setKey = function(key, opt_length) {
    if (!opt_length) {
        opt_length = key.length;
    }

    var state = this._state;

    for (var i = 0; i < 256; ++i) {
        state[i] = i;
    }

    var j = 0;
    for (var i = 0; i < 256; ++i) {
        j = (j + state[i] + key[i % opt_length]) & 255;

        var tmp = state[i];
        state[i] = state[j];
        state[j] = tmp;
    }

    this._index1 = 0;
    this._index2 = 0;
};


/**
 * Discards n bytes of the keystream.
 * These days 1536 is considered a decent amount to drop to get the key state
 * warmed-up enough for secure usage. This is not done in the constructor to
 * preserve efficiency for use cases that do not need this.
 * NOTE: Discard is identical to crypt without actually xoring any data. It's
 * unfortunate to have this code duplicated, but this was done for performance
 * reasons. Alternatives which were attempted:
 * 1. Create a temp array of the correct length and pass it to crypt. This
 *        works but needlessly allocates an array. But more importantly this
 *        requires choosing an array type (Array or Uint8Array) in discard, and
 *        choosing a different type than will be passed to crypt by the client
 *        code hurts the javascript engines ability to optimize crypt (7x hit in
 *        v8).
 * 2. Make data option in crypt so discard can pass null, this has a huge
 *        perf hit for crypt.
 * @param {number} length Number of bytes to disregard from the stream.
 */
Arc4.prototype.discard = function(length) {
    var i = this._index1;
    var j = this._index2;
    var state = this._state;

    for (var n = 0; n < length; ++n) {
        i = (i + 1) & 255;
        j = (j + state[i]) & 255;

        var tmp = state[i];
        state[i] = state[j];
        state[j] = tmp;
    }

    this._index1 = i;
    this._index2 = j;
};


/**
 * En- or decrypt (same operation for streamciphers like ARC4)
 * @param {Array.<number>|Uint8Array} data The data to be xor-ed in place.
 * @param {number=} opt_length The number of bytes to crypt.
 */
Arc4.prototype.crypt = function(data, opt_length) {
    if (!opt_length) {
        opt_length = data.length;
    }
    var i = this._index1;
    var j = this._index2;
    var state = this._state;

    for (var n = 0; n < opt_length; ++n) {
        i = (i + 1) & 255;
        j = (j + state[i]) & 255;

        var tmp = state[i];
        state[i] = state[j];
        state[j] = tmp;

        data[n] ^= state[(state[i] + state[j]) & 255];
    }

    this._index1 = i;
    this._index2 = j;
};

module.exports = Arc4;
});

define('eref/main',['require','exports','module','eref/arc4','base64'],function (require, exports, module) {var Arc4 = require('eref/arc4');
var base64 = require('base64');

/**
 * Turns a string into an array of bytes; a "byte" being a JS number in the
 * range 0-255.
 * @param {string} str String value to arrify.
 * @return {!Array.<number>} Array of numbers corresponding to the
 *         UCS character codes of each character in str.
 */
function stringToByteArray(str) {
    var output = [], p = 0, c;
    for (var i = 0; i < str.length; i++) {
        c = str.charCodeAt(i);
        while (c > 0xff) {
            output[p++] = c & 0xff;
            c >>= 8;
        }
        output[p++] = c;
    }
    return output;
}

/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param {Array} array Array of numbers representing characters.
 * @return {string} Stringification of the array.
 */
function byteArrayToString(array) {
    return String.fromCharCode.apply(null, array);
}

function arc4Decrypt(key, data) {
    var arc4 = new Arc4();
    key = stringToByteArray(key);
    data = base64.atob(data);

    data = stringToByteArray(data);
    arc4.setKey(key);
    arc4.crypt(data);
    return byteArrayToString(data);
}

var EREF_REGEX = /^eref:\/\/([^:\/]+:[^:\/]+\/[^:\/]+)$/;

/**
 * @param {string} rawEref
 * @param {string} key
 * @return {?string}
 */
function decryptEref(rawEref, key) {
    var decryptedEref = arc4Decrypt(key, rawEref);
    var match = decryptedEref.match(EREF_REGEX);
    if (match) {
        return match[1];
    }
    return null;
}

var eref = {};

/**
 * @param {string} rawEref
 * @param {Array.<string>} keys
 * @return {string|undefined}
 */
eref.decryptEref = function(rawEref, keys) {
    var decryptedEref;
    for (var i=0, l=keys.length; i<l; i++) {
        return decryptEref(rawEref, keys[i]);
    }
};

/**
 * @param {Array.<string>} rawErefs
 * @param {Array.<string>} keys
 * @return {string|undefined}
 */
eref.decryptErefs = function(rawErefs, keys) {
    var raw, decryptedEref;
    for (var i=0, l=rawErefs.length; i<l; i++) {
        raw = rawErefs[i];
        decryptedEref = eref.decryptEref(raw, keys);
        if (decryptedEref) {
            return decryptedEref;
        }
    }
};

module.exports = eref;

});

define('eref', ['eref/main'], function (main) { return main; });

define('eref/erefprocessor',['require','exports','module','eref','inherits','stream/transform'],function (require, exports, module) {/**
 * @fileoverview
 * The eref processor is responsible for hyrdating erefs by fetching ref batches from bootstrap.
 */
var eref = require('eref');
var inherits = require('inherits');
var Transform = require('stream/transform');

/**
 * @constructor
 * @extends {Transform}
 */
function ErefProcessor(opts) {
    /**
     * @type {Array}
     * The keys used for decrytion.
     */
    this._keys = [];
    Transform.call(this, opts);
}
inherits(ErefProcessor, Transform);

/**
 * How many decrypted erefs to request in one batch.
 * @type {number}
 */
ErefProcessor.BATCH_SIZE = 20;

/**
 * The timeout to use when decrypting erefs before making a batch request.
 * @type {number}
 */
ErefProcessor.TIMEOUT = 300;

/**
 * The set of all erefs that have not been decoded
 * @type {Object}
 * @private
 */
var encryptedSet = {};  // (erefs joined to one string)

/**
 * The list of all erefs that have not been decoded
 * @type {Array}
 * @private
 */
var encrypted = [];

/**
 * The list of decoded erefs that have not yet been requested from the server.
 * @type {Array}
 * @private
 */
var buffered = [];

/**
 * The callback to call to make requests if new decoded erefs have not been added since the
 * timeout.
 * @type {?function}
 * @private
 */
var drainAfterWait = null;

function map(arr, func) {
    var mapped = [];
    for (var i = 0; i < arr.length; i++) {
        mapped.push(func(arr[i]));
    };
    return mapped;
}

/**
 * Set the keys for decrypting erefs.
 * @param {Array.<string>} The user's secret keys
 */
ErefProcessor.prototype.setKeys = function (keys) {
    // TODO(jj): not sure whose bug this really is
    var validKeys = [];
    for (var i = 0; i < keys.length; i++) {
        (keys[i] !== undefined) && validKeys.push(keys[i]);
    };
    this._keys = validKeys;
};

/**
 * Get the keys for decrypting erefs.
 * @returns {Array.<string>} The user's secret keys
 */
ErefProcessor.prototype.getKeys = function () {
    return this._keys;
};

/** @override */
ErefProcessor.prototype._transform = function (erefs, done) {
    this.handleEncrypted(erefs);
    done();
};

ErefProcessor.prototype.drainBuffer = function () {
    while (buffered.length) {
        this.push(buffered.slice(0, ErefProcessor.BATCH_SIZE));
        buffered = buffered.slice(ErefProcessor.BATCH_SIZE);
    }
};

/**
 * Remove the decrypted content ids from the processor's list of decrypted content.
 * Really bad times here algorithm-wise.
 * @param {Array.<Array>} decrypted The erefs that have been successfully decrypted.
 */
ErefProcessor.prototype.handleDecrypted = function (erefs) {
    var compCache = map(encrypted, function (arr) { return arr.join(); });
    var compDecrypted = map(erefs, function (arr) { return arr.join(); });
    var idx;
    var currDecrypted;

    for (var i = 0; i < compDecrypted.length; i++) {
        currDecrypted = compDecrypted[i];
        if (!encryptedSet[currDecrypted]) {
            continue;
        }
        idx = compCache.indexOf(currDecrypted);
        encrypted.pop(idx);
        encryptedSet[currDecrypted] = null;
    }
};

/**
 * @param {Array.<Array>} erefs
 */
ErefProcessor.prototype.handleEncrypted = function (erefs) {
    var refs = this.maybeDecrypt(erefs);
    if (!refs) {
        return;
    }
    buffered.push.apply(buffered, refs);
    if (buffered.length >= ErefProcessor.BATCH_SIZE) {
        this.drainBuffer();
    }
    var self = this;
    drainAfterWait && clearTimeout(drainAfterWait);
    drainAfterWait = setTimeout(function () {
        self.drainBuffer();
    }, ErefProcessor.TIMEOUT);
};

/**
 * Try to decrypt these erefs using the current user's keys.
 * @param {Array.<Array>} erefs
 */
ErefProcessor.prototype.maybeDecrypt = function (erefs) {
    var decryptedValue;
    var keys = this.getKeys();
    var refs = [];

    decryptedValue = eref.decryptErefs(erefs, keys);
    if (decryptedValue) {
        refs.push(decryptedValue);
        return refs;
    }
    // If we cannot decrypt it now, maybe we can decrypt it later.
    if (!encryptedSet[erefs.join()]) {
        encrypted.push(erefs);
        encryptedSet[erefs.join()] = true;
    }
};

/**
 * Scans all the eref'd content in storage to see if it can be decrypted
 */
ErefProcessor.prototype.processStorage = function () {
    for (var i = 0; i < encrypted.length; i++) {
        this.write(encrypted[i]);
    }
};

// Do not use these functions except when testing
ErefProcessor.prototype._getBuffer = function () {
    return buffered;
};

ErefProcessor.prototype._setBuffer = function (arr) {
    buffered = arr;
};

ErefProcessor.prototype._getCache = function () {
    return encrypted;
};

ErefProcessor.prototype._setCache = function (arr) {
    encrypted = arr;
};

// TODO(jj): One day, toggle back to the decrypted state on user logout or w/e

module.exports = ErefProcessor;

});

define('observer',[],function() {

    var listenIds = 0;

    /**
     * An Observable mixin for use with EventEmitter
     * @param {Object} that
     * @exports streamhub-sdk/observer
     */
    function Observer(that) {
        that = that || {};
        that._listeningTo = {};
        that.listenTo = listenTo;
        that.stopListening = stopListening;
        return that;
    };

    /**
     * Listen to the event on the provided object
     * @param {EventEmitter} obj
     * @param {string} name
     * @param {function()} callback
     */
    function listenTo(obj, name, callback) {
        var id = obj._listenId || (obj._listenId = listenIds++ + '');

        // TODO: simplify
        this._listeningTo[id] = this._listeningTo[id] || {};
        this._listeningTo[id].obj = obj;
        this._listeningTo[id].listeners = this._listeningTo[id].listeners || {};
        this._listeningTo[id].listeners[name] = this._listeningTo[id].listeners[name] || [];
        this._listeningTo[id].listeners[name].push(callback);

        obj.on(name, callback);
    }

    /**
     * Stop listening to the provided object
     * @param {?EventEmitter} obj
     */
    function stopListening(obj) {
        if (obj) {
            removeListenersForObj.call(this, obj._listenId);
            return;
        }
        // TODO: name/callback granularity
        for (var id in this._listeningTo) {
            if (!this._listeningTo.hasOwnProperty(id)) {
                continue;
            }
            removeListenersForObj.call(this, id)
        }
    }

    function removeListenersForObj(id) {
        if (!this._listeningTo[id]) {
            return;
        }

        var obj = this._listeningTo[id].obj;
        var listeners = this._listeningTo[id].listeners;
        var callbacks;
        for (var name in listeners) {
            if (!listeners.hasOwnProperty(name)) {
                continue;
            }

            callbacks = listeners[name];
            for (var i = 0; i < callbacks.length; i++) {
                obj.removeListener(name, callbacks[i]);
            }
        }
        delete this._listeningTo[id];
    }

    return Observer;
});

define('livefyre-auth/collection-authorization',['require','exports','module'],function (require, exports, module) {/**
 * An Object that holds information
 * about a user's authorization in a Collection
 * @param collection.network {string} Network of Collection
 * @param collection.siteId {string} Site ID of Collection
 * @param collection.articleId {string} Article ID of Collection
 * @param authData {object} data returned from auth API
 */
module.exports = function CollectionAuthorization(collection) {
    this.collection = collection;
    // Array of Objects, where each object is like
    // { id: 'authorId', key: 'authorKey' }
    this.authors = [];
    // If the user is a moderator of the Collection, this will be a key
    // that lets them fetch non-public Content
    this.moderatorKey = null;
};

});

define('mout/function/identity',[],function () {

    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    return identity;

});

define('mout/function/prop',[],function () {

    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    return prop;

});

define('mout/object/hasOwn',[],function () {

    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     return hasOwn;

});

define('mout/object/forIn',['./hasOwn'], function (hasOwn) {

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    return forIn;

});

define('mout/object/forOwn',['./hasOwn', './forIn'], function (hasOwn, forIn) {

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    return forOwn;

});

define('mout/lang/kindOf',[],function () {

    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    return kindOf;
});

define('mout/lang/isKind',['./kindOf'], function (kindOf) {
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    return isKind;
});

define('mout/lang/isArray',['./isKind'], function (isKind) {
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    return isArray;
});

define('mout/object/deepMatches',['./forOwn', '../lang/isArray'], function(forOwn, isArray) {

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    return deepMatches;

});

define('mout/function/makeIterator_',['./identity', './prop', '../object/deepMatches'], function(identity, prop, deepMatches) {

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    return makeIterator;

});

define('mout/array/filter',['../function/makeIterator_'], function (makeIterator) {

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    return filter;

});

define('livefyre-auth/util/jsonp',['require','exports','module'],function (require, exports, module) {/**
 * @fileoverview Very small jsonp implementation.
 */

function req(url, callback) {
    var rand = '_lfcallback_' + (+new Date()),
        script = document.createElement('script'),
        sep = url.indexOf('?') > 0 ? '&' : '?';

    function clean() {
        if (script.parentNode) {
            script.parentNode.removeChild(script);
        }
        window[rand] = undefined;
    }

    window[rand] = function(data) {
        clean();
        callback(null, data);
    };

    script.type = 'text/javascript';
    script.async = true;

    script.onerror = function() {
        clean();
        callback('error');
    };

    script.src = url + sep + 'callback=' + rand;
    document.getElementsByTagName('head')[0].appendChild(script);
}

module.exports = {
    req: req
};

});

define('mout/array/map',['../function/makeIterator_'], function (makeIterator) {

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     return map;
});

define('livefyre-auth/auth-api',['require','exports','module','base64','./collection-authorization','mout/array/filter','./util/jsonp','mout/array/map'],function (require, exports, module) {var base64 = require('base64');
var CollectionAuthorization = require('./collection-authorization');
var filter = require('mout/array/filter');
var jsonp = require('./util/jsonp');
var map = require('mout/array/map');

/**
 * An Object that can talk to Livefyre's Auth API over HTTP
 */
var authApi = module.exports = {};

/**
 * Fetch user profile information from the Livefyre Auth API
 * @param {string} opts.token
 * @param {string=} opts.serverUrl
 * @param {string=} opts.bpChannel
 * @param {string=} opts.articleId
 * @param {string=} opts.siteId
 * @param {string=} opts.network
 * @param {function()=} callback
 */
authApi.authenticate = function (opts, errback) {
    // TODO: opts.articleId should not have to be b64-encoded
    var qsParts = [];
    var token = opts && opts.token;
    var serverUrl = opts && opts.serverUrl;
    var queryString;
    var url;

    if (token) {
        qsParts.push(qsParam('lftoken', opts.token));
    }

    if (opts.network) {
        serverUrl = serverUrlFromNetwork(opts.network);
    }

    if (! serverUrl) {
        serverUrl = token ? serverUrlFromToken(token) : 'http://livefyre.com';
    }

    if (opts.bpChannel) {
        qsParts.push(qsParam('bp_channel', opts.bpChannel));
    }
    if (opts.articleId && opts.siteId) {
        qsParts.push(
            qsParam('articleId', base64.btoa(opts.articleId)),
            qsParam('siteId', opts.siteId));
    }
    queryString = qsParts.join('&');

    url = [serverUrl, '/api/v3.0/auth/?', queryString].join('');

    // Use opts._request function if it is passed. This will make it
    // easy to mock
    this._request(url, function(err, resp) {
        if ( ! err) {
            err = jsonpError(resp);
        }
        var authData = resp && resp.data;
        errback(err, authData);
    });
};

/**
 * Make an HTTP Request to the provided url, then errback the response
 */
authApi._request = function (url, errback) {
    jsonp.req(url, errback);
};

// Since JSONP will always return 200, inspect the response
// to see if it was an error, and return an Error if so
// else return undefined
function jsonpError(resp) {
    var code = resp && resp.code;
    if (code === 200) {
        // no error
        return;
    }
    var err = new Error("Error requesting with JSONP");
    err.response = resp;
    err.code = code;
    return err;
}

/**
 * Update a user model given data from the Auth API
 * @param user {LivefyreUser} A User model
 * @param authData {object} The data object from the Auth API response
 * @param [userInfoCollection] {object} Describes the scope of the userInfo
 *     e.g. an object of collectionInfo.
 */
authApi.updateUser = function (user, userInfo, userInfoCollection) {
    var profile = userInfo.profile;
    var tokenDescriptor = userInfo.token;
    var token = tokenDescriptor && tokenDescriptor.value;
    var tokenExpiresAt = tokenDescriptor && new Date((+new Date()) + tokenDescriptor.ttl * 1000);
    var collectionId = userInfo['collection_id'];
    var collectionAuthorization;

    var attributes = extend({}, profile, {
        serverUrl: userInfo.serverUrl,
        token: token,
        tokenExpiresAt: tokenExpiresAt
    });

    user.set(attributes);

    // # Update Authorizations
    var newAuthorizations = [];
    // Collection Authorizations
    if (collectionId) {
        // Should I pass user as first param? or adapt it?
        collectionAuthorization = this.createCollectionAuthorization(userInfoCollection || {}, userInfo);
        if (collectionAuthorization) {
            newAuthorizations.push(collectionAuthorization);
        }
    }
    // Network Authorizations
    var networkAuthorizations = this.createNetworkAuthorizations(userInfo);
    if (networkAuthorizations.length > 0) {
        newAuthorizations.push.apply(newAuthorizations, networkAuthorizations);
    }

    var siteAuthorizations = this.createSiteAuthorizations(userInfo);
    if (siteAuthorizations.length > 0) {
        newAuthorizations.push.apply(newAuthorizations, siteAuthorizations);
    }

    // Add all authorizations to user
    // TODO: Don't push duplicates...
    // Filter newAuthorizations to only include those who aren't duplicates
    var uniqueAuthorizations = filter(newAuthorizations, function (authorization) {
        if (authorization.network) {
            return ! user.isMod({ network: authorization.network });
        }
        if (authorization.siteId) {
            return ! user.isMod({ siteId: authorization.siteId });
        }
        if (authorization.collection && authorization.collection.id) {
            return ! user.isMod({ collectionId: authorization.collection.id });
        }
        // If it's not one of these, don't add it
        return false;
    });
    // Add to authorizations
    if (uniqueAuthorizations.length > 0) {
        user.authorizations.push.apply(user.authorizations, uniqueAuthorizations);
    }
    return user;
};

/**
 * Create a CollectionAuthorization from
 * @param opts {object} opts passed to authApi.authenticate
 * @param userInfo {object} Response data from authApi
 */
authApi.createCollectionAuthorization = function (opts, userInfo) {
    var collection = {
        network: opts.network,
        id: userInfo.collection_id,
        siteId: opts.siteId,
        articleId: opts.articleId
    };
    var authorization = new CollectionAuthorization(collection);
    var permissions = userInfo.permissions;
    var authors = permissions && permissions.authors;
    if (authors && authors.length > 0) {
        authorization.authors.push.apply(authorization.authors, authors);
    }
    var moderatorKey = permissions && permissions.moderator_key;
    if (moderatorKey) {
        authorization.moderatorKey = moderatorKey;
    }
    return authorization;
};

/**
 * Create a set of network authorizations from
 * @param userInfo {object} Response data from authApi
 * @return Array of objects like {network: 'network', moderator: true}
 */
authApi.createNetworkAuthorizations = function (userInfo) {
    var modScopes = userInfo.modScopes;
    var networkModScopes = modScopes && modScopes.networks;
    if ( ! (networkModScopes && networkModScopes.length > 0)) {
        return [];
    }
    var networkAuthorizations = map(networkModScopes, function (network) {
        var authorization = {
            network: network,
            moderator: true
        };
        return authorization;
    });
    return networkAuthorizations;
};

/**
 * Create a set of site authorizations from
 * @param userInfo {object} Response data from authApi
 * @return Array of objects like {siteId: '125125', moderator: true}
 */
authApi.createSiteAuthorizations = function (userInfo) {
    var modScopes = userInfo.modScopes;
    var siteModScopes = modScopes && modScopes.sites;
    if ( ! (siteModScopes && siteModScopes.length > 0)) {
        return [];
    }
    var siteAuthorizations = map(siteModScopes, function (siteId) {
        var authorization = {
            siteId: siteId,
            moderator: true
        };
        return authorization;
    });
    return siteAuthorizations;
};

function extend(destination) {
    var sources = [].slice.call(arguments, 1);
    var source;
    for (var i=0, numSources=sources.length; i < numSources; i++) {
        source = sources[i];
        for (var key in source) {
            if ( ! source.hasOwnProperty(key)) {
                continue;
            }
            destination[key] = source[key];
        }
    }
    return destination;
}

function qsParam(key, value) {
    var qsPart = '{key}={value}'
        .replace('{key}', key)
        .replace('{value}', encodeURIComponent(value));
    return qsPart;
}

function networkFromToken (token) {
    var jwtParts = token.split('.');
    if (jwtParts.length !== 3) {
        throw new Error("The provided lftoken is not a JWT: "+token);
    }
    var tokenJSON = base64.atob(jwtParts[1]);
    var tokenData = JSON.parse(tokenJSON);
    var network = tokenData.domain;
    return network;
}

function getDomain(network) {
    return network.split('.')[0];
}

function serverUrlFromNetwork(network) {
    var domain = getDomain(network);
    var protocol = document.location.protocol;
    if (domain === 'livefyre') {
        return protocol + '//' + 'admin.' + network;
    }
    return protocol + '//' + domain + '.admin.fyre.co'
}

function serverUrlFromToken(token) {
    var network = networkFromToken(token);
    return serverUrlFromNetwork(network);
}

});

define('mout/lang/isPlainObject',[],function () {

    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    return isPlainObject;

});

define('mout/object/mixIn',['./forOwn'], function(forOwn){

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    return mixIn;
});

define('mout/lang/clone',['./kindOf', './isPlainObject', '../object/mixIn'], function (kindOf, isPlainObject, mixIn) {

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignorecase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    return clone;

});

define('mout/lang/deepClone',['./clone', '../object/forOwn', './kindOf', './isPlainObject'], function (clone, forOwn, kindOf, isPlainObject) {

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    return deepClone;

});


define('mout/array/some',['../function/makeIterator_'], function (makeIterator) {

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    return some;
});

define('livefyre-auth/user',['require','exports','module','event-emitter','inherits','mout/array/some'],function (require, exports, module) {/**
 * @fileoverview Simplified user object that looks like a Backbone model, but with only 'CHANGE'
 * and 'CLEAR' events.
 * Note that including this file will setup a global `window.livefyre.user`, but won't override
 * an existing object. Use at own risk.
 * This should be assumed to be a global singleton.
 */

var EventEmitter = require('event-emitter');
var inherits = require('inherits');
var some = require('mout/array/some');

/**
 * @param {Object} initialAttr
 * @constructor
 */
function LivefyreUser(initialAttr) {
    this._attributes = {};
    this.authorizations = [];
    EventEmitter.call(this);
}
inherits(LivefyreUser, EventEmitter);

/** @enum {string} */
LivefyreUser.EVENTS = {
    CHANGE: 'change'
};

/**
 * @param {Object|string} keyOrObj
 * @param {*=} opt_value
 */
LivefyreUser.prototype.set = function(keyOrObj, opt_value) {
    var tempKey, k, val;
    // Assume object if not string
    if (typeof(keyOrObj) === 'string') {
        tempKey = keyOrObj;
        keyOrObj = {};
        keyOrObj[tempKey] = opt_value;
    }

    for (k in keyOrObj) {
        if (keyOrObj.hasOwnProperty(k)) {
            val = keyOrObj[k];
            this._attributes[k] = val;
            this.emit(LivefyreUser.EVENTS.CHANGE + ':' + k, val);
        }
    }
    this.emit(LivefyreUser.EVENTS.CHANGE, keyOrObj);
};

/**
 * Get a particular attribute
 * @param {string} key
 * @return {*}
 */
LivefyreUser.prototype.get = function(key) {
    if (!key) {
        return this._attributes;
    }
    return this._attributes[key];
};

/**
 * @param {string} key
 */
LivefyreUser.prototype.unset = function(key) {
    if (key in this._attributes) {
        delete this._attributes[key];
        var obj = {};
        obj[key] = void 0;
        this.emit(LivefyreUser.EVENTS.CHANGE + ':' + key, obj[key]);
    }
};

/**
 * Determines if this user is authenticated or not.
 * @return {boolean}
 */
LivefyreUser.prototype.isAuthenticated = function() {
    return !!this.get('id');
};

/**
 * Check if user is known to be a moderator of provided Collection info
 * @param scope {object} An object which describes the scope you're curious
 *     about isMod. Pass .network, .siteId, .articleID for Collection
 *     or just .collectionId
 * @return {boolean}
 */
function isModByCollectionInfo(scopeObj) {
    var isMod = some(this.authorizations, function (authorization) {
        var collection = authorization.collection;
        return Boolean(collection &&
            authorization.moderatorKey &&
            collection.network === scopeObj.network &&
            collection.siteId === scopeObj.siteId &&
            collection.articleId === scopeObj.articleId);
    });
    return isMod;
}

/**
 * Check if user is known to be a moderator of a given Collection ID
 * @param collectionId {string} A Collection ID
 * @return {boolean}
 */
function isModByCollectionId(collectionId) {
    var authorization = this.getAuthorizationByCollectionId(collectionId);
    return Boolean(authorization && authorization.moderatorKey);
}

/**
 * @param collectionId {string} A Collection ID
 * @return {CollectionAuthorization}
 */
LivefyreUser.prototype.getAuthorizationByCollectionId = function(collectionId) {
    var authorization;
    var collection;
    for (var i = 0; i < this.authorizations.length; i++) {
        authorization = this.authorizations[i];
        collection = authorization.collection;
        if (collection &&
            collection.id === collectionId) {
            return authorization;
        }
    }
    return null;
};

/**
 * Check if user is known to be a moderator of a given Network
 * @param networkId {string} A Network name
 * @return {boolean}
 */
function isModByNetwork(networkId) {
    var isMod = some(this.authorizations, function (authorization) {
        var authNetwork = authorization.network;
        return authNetwork && authNetwork === networkId && authorization.moderator;
    });
    return isMod;
}

/**
 * Check if user is known to be a moderator of a given Site ID
 * @param siteId {string} A Site ID
 * @return {boolean}
 */
function isModBySiteId(siteId) {
    var isMod = some(this.authorizations, function (authorization) {
        var authSiteId = authorization.siteId;
        return authSiteId && authSiteId === siteId && authorization.moderator;
    });
    return isMod;
}

/**
 * @param scope {object} An object which describes the scope you're curious
 *     about isMod. Pass .network, .siteId, .articleID for Collection
 *     or just .collectionId
 * @return {boolean}
 */
LivefyreUser.prototype.isMod = function(scopeObj) {
    if (scopeObj.collectionId) {
        return isModByCollectionId.call(this, scopeObj.collectionId);
    }
    if (scopeObj.articleId) {
        return isModByCollectionInfo.call(this, scopeObj);
    }
    if (scopeObj.network) {
        return isModByNetwork.call(this, scopeObj.network);
    }
    if (scopeObj.siteId) {
        return isModBySiteId.call(this, scopeObj.siteId);
    }
    return;
};

/**
 * Set up singleton user object.
 */
module.exports = LivefyreUser;

});

define('livefyre-auth/util/storage',['require','exports','module'],function (require, exports, module) {/**
 * @fileoverview Storage helpers: if window.localStroage is unavailable, then defaults to cookie
 * based storage. Automatically handles expiration and JSON serialization for both types of storage.
 */

var STORAGE_AVAILABLE_KEY = '__lfstorage__',
    canUseLocalStorage = (function() {
        try {
            // Weird cases where accessing localStorage global will throw an error.
            var storage = localStorage || null;
            // setItem will throw an exception if we cannot access WebStorage (e.g.,
            // Safari in private mode).
            storage.setItem(STORAGE_AVAILABLE_KEY, '1');
            storage.removeItem(STORAGE_AVAILABLE_KEY);
            return true;
        } catch (e) {
            return false;
        }
    })();

/**
 * LocalStorage storage object.
 * Attempts to rectify the many ways that browsers can interpret the localStorage object with heavy
 * use of try-catch blocks.
 */
var html5Storage = {
    /**
     * @param {string} key
     * @param {*} value
     * @param {number=} opt_expiration In UTC time
     */
    set: function(key, value, opt_expiration) {
        var valueObj = {
            value: value,
            expiration: opt_expiration || null
        };
        try {
            localStorage.setItem(key, JSON.stringify(valueObj));
        } catch(e) {}
    },

    /**
     * @param {string} key
     * @return {*=}
     */
    get: function(key) {
        try {
            var rawItem = localStorage.getItem(key);
            var valueObj = rawItem ? JSON.parse(rawItem) : {};

            /*
             * If stored object is expired:
             * - remove it
             * - return undefined
             */
            if (valueObj.expiration && valueObj.expiration < (+new Date())) {
                html5Storage.remove(key);
                return undefined;
            }

            return valueObj.value;
        } catch(e) {
            return undefined;
        }
    },

    /**
     * @param {string} key
     */
    remove: function(key) {
        try {
            localStorage.removeItem(key);
        } catch(e) {}
    }
};

/**
 * Cookie storage object.
 * Inspired by http://docs.closure-library.googlecode.com/git/closure_goog_net_cookies.js.source.html
 */
var cookieStorage = {
    /**
     * @param {string} key
     * @param {*} value
     * @param {number=} opt_expiration In UTC time
     */
    set: function(key, value, opt_expiration) {
        function convertExpiration(exp) {
            return new Date(exp).toUTCString();
        }

        var expiration, expiresStr, oneWeekMs = 604800000;

        if (opt_expiration > 0) {
            expiration = convertExpiration(opt_expiration);
        } else if (opt_expiration === 0) {
            expiration = ';expires=' + (new Date(1970, 1 /*Feb*/, 1)).toUTCString();
        } else {
            expiration = (+new Date() + oneWeekMs);
        }

        document.cookie = key + '=' + JSON.stringify(value) + expiresStr;
    },

    /**
     * @param {string} key
     * @return {*=}
     */
    get: function(key) {
        function getParts() {
            return document.cookie.split(/\s*;\s*/);
        }
        var keyEq = key + '=',
            parts = getParts();
        for (var i = 0, part; part = parts[i]; ++i) {
            // startsWith
            if (part.lastIndexOf(keyEq, 0) === 0) {
                return part.substr(keyEq.length);
            }
            if (part === key) {
                return '';
            }
        }
        return undefined;
    },

    /**
     * @param {string} key
     */
    remove: function(key) {
        cookieStorage.set(key, '', 0);
    }
};

module.exports = canUseLocalStorage ? html5Storage : cookieStorage;

});

define('livefyre-auth/session',['require','exports','module','./auth-api','mout/lang/deepClone','./user','./util/storage'],function (require, exports, module) {var authApi = require('./auth-api');
var deepClone = require('mout/lang/deepClone');
var LivefyreUser = require('./user');
var storage = require('./util/storage');

// Used for the data from last request to auth api
var AUTH_COOKIE_KEY = 'fyre-auth';
// Used for just the token
var AUTH_CREDS = 'fyre-authentication-creds';

/**
 * The LivefyreUser session that is saved between logins and logouts
 */
var session = module.exports = {
    /**
     * Get an existing session, or null
     * @returns LivefyreUser
     */
    get: function () {
        var cookieData = storage.get(AUTH_COOKIE_KEY) || {};
        if ( ! cookieData.token) {
            return null;
        }
        var user = new LivefyreUser();
        // We save the raw data from the auth api
        authApi.updateUser(user, cookieData);
        return user;
    },
    /**
     * Save a new session for userInfo you provide
     * @param userInfo {object} The full data from the Auth API response
     * @param [user] A LivefyreUser model you've already created
     */
    save: function (userInfo, user) {
        var toCache = deepClone(userInfo);
        var tokenObj = userInfo['token'];
        var tokenExpiresAt = (+new Date()) + tokenObj['ttl'] * 1000;

        if (user) {
            toCache['mod_map'] = user.get('modMap');
        }

        storage.set(AUTH_COOKIE_KEY, toCache, tokenExpiresAt);
        // Store authentication credentials, i.e. the token used for authenticating
        var authCreds = userInfo['token'];
        if (authCreds) {
            storage.set(AUTH_CREDS, authCreds['value'], (+new Date()) + authCreds['ttl'] * 1000);
        }
    },
    /**
     * Clear the session
     */
    clear: function () {
        storage.remove(AUTH_COOKIE_KEY);
        storage.remove(AUTH_CREDS);
    }
};

});

define('livefyre-auth/permissions',['require','exports','module','./auth-api','mout/array/map','./session'],function (require, exports, module) {

var authApi = require('./auth-api');
var map = require('mout/array/map');
var session = require('./session');

var permissions = module.exports = {};


/**
 * Fetch a user's permissions for a Livefyre Collection
 * @param user {User} user
 * @param collection {Collection}
 * @param collection.network {string} Network of Collection
 * @param collection.siteId {string} Site ID of Collection
 * @param collection.articleId {string} Article ID of Collection
 * @throws Error if you didn't pass all required Collection info
 */
permissions.forCollection = function (user, collection, errback) {
    validateCollection(collection);
    var opts = {};
    opts.token = user.get('token');
    opts.serverUrl = user.get('serverUrl');
    opts.siteId = collection.siteId;
    opts.articleId = collection.articleId;

    authApi.authenticate(opts, function (err, userInfo) {
        if (err) {
            return errback(err);
        }
        // bad, duplicated from user-service
        if ( ! userInfo.profile) {
            err = new Error('fetch-user got empty auth response');
            return errback(err);
        }
        // Store the serverUrl (bad, also duplicated from user-service)
        userInfo.serverUrl = opts.serverUrl;

        errback(null, userInfo);
    });
};

/**
 * Get the eref keys for a user and for the specified collection.
 * @param user {User} user
 * @param collection {Collection}
 * @param errback {function(?Error, Array)}
 */
permissions.getKeys = function (user, collection, errback) {
    var authorization = user.getAuthorizationByCollectionId(collection.id);

    function collKeyset(authorization) {
        var authorKeys = map(authorization.authors, function(authorObj) {
            return authorObj.key;
        });
        if (authorization.moderatorKey) {
            return authorKeys.concat([authorization.moderatorKey]);
        }
        return authorKeys;
    }

    if (authorization) {
        return errback(null, collKeyset(authorization));
    }

    // user has not yet fetched permissions for this collection, get them now!11
    permissions.forCollection(user, collection, function (err, userInfo) {
        if (err) {
            return errback(err);
        }

        // update the user for the future
        authApi.updateUser(user, userInfo);

        // save the session for the far future
        session.save(userInfo, user);

        authorization = user.getAuthorizationByCollectionId(collection.id);
        errback(null, collKeyset(authorization));
    });
};

function validateCollection(collection) {
    var collectionOpts = ['siteId', 'articleId', 'network'];
    for (var i=0, numOpts=collectionOpts.length; i<numOpts; i++) {
        var optName = collectionOpts[i];
        if ( ! collection[optName]) {
            throw collectionOptError(optName, collection);
        }
    }
}

function collectionOptError(optName, collection) {
    var err = new Error("Missing Collection option "+optName);
    err.collection = collection;
    err.missingOption = optName;
    return err;
}

});

define("hgn!templates/tracking", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<iframe src=\"");_.b(_.v(_.f("trackingHost",c,p,0)));_.b("/v3/tracking/");_.b(_.v(_.f("trackingUrl",c,p,0)));_.b("?streamType=Sidenotes\"");_.b("\n" + i);_.b("        frameborder=\"0\"");_.b("\n" + i);_.b("        style=\"position: absolute; height: 1px; width: 1px; z-index: 99999; background-color: transparent;\"></iframe>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/clients/annotationscollection',['require','exports','module','jquery','annotations/adapters','annotations/clients/annotationshttpclient','auth','annotations/adapters','streamhub-sdk/collection','annotations/adapters/commentannotator','streamhub-sdk/debug','eref/erefprocessor','inherits','annotations/util/internals','observer','livefyre-auth/permissions','annotations/util/storage','hgn!templates/tracking'],function (require, exports, module) {/**
 * @fileoverview The AnnotationsCollection is responsible for handling annotation data events and
 * returning adapted objects for app use.
 */

var $ = require('jquery');
var Adapters = require('annotations/adapters');
var AnnotationsHttpClient = require('annotations/clients/annotationshttpclient');
var auth = require('auth');
var BootstrapKeys = require('annotations/adapters').BootstrapKeys;
var Collection = require('streamhub-sdk/collection');
var CommentAnnotator = require('annotations/adapters/commentannotator');
var debug = require('streamhub-sdk/debug');
var ErefProcessor = require('eref/erefprocessor');
var inherits = require('inherits');
var memoize = require('annotations/util/internals').memoize;
var Observer = require('observer');
var permissions = require('livefyre-auth/permissions');
var Storage = require('annotations/util/storage');
var trackingTemplate = require('hgn!templates/tracking');

var log = debug('annotations/clients/annotationscollection');

/**
 *  A Livefyre collection with methods for handling annotations data.
 * @constructor
 * @extends {Collection}
 */
function AnnotationsCollection (opts) {
    this.protocol = opts.protocol;

    /**
     * The active block.
     * @type {?Block}
     */
    this.block = null;

    /**
     * The app config.
     * @type {?Object}
     */
    this.config = null;

    /**
     * The current selected text.
     * @type {?string}
     */
    this.selectedText = null;

    /**
     * @type {ErefProcessor}
     * @private
     */
    var erefProcessor = this._erefProcessor = new ErefProcessor();

    /**
     * @type {AnnotationsStateToContent}
     * @private
     */
    this._annotationsSTC = new Adapters.AnnotationsStateToContent({
        erefProcessor: erefProcessor
    });


    Observer(this);
    this.listenTo(auth, 'login.livefyre', $.proxy(this.processStoredErefs, this));
    this.listenTo(auth, 'logout', function () { erefProcessor.setKeys([]); });
    // Listen for decrypted erefs
    this.listenTo(erefProcessor, 'data', $.proxy(this.fetchErefs, this));

    opts.bootstrapClient = this._getClient('bootstrap');
    opts.maxInitAttempts = 10;

    Collection.call(this, opts);
}
inherits(AnnotationsCollection, Collection);

/** @override */
AnnotationsCollection.prototype._handleInitComplete = function (err, initData) {
    this._loadTrackingIframe();
    initData && Adapters.adaptSettings(this, initData);
    Collection.prototype._handleInitComplete.call(this, err, initData);

    // need to initialize the user's eref keys if they are logged in
    this.processStoredErefs();
};

/** @override */
AnnotationsCollection.prototype.createUpdater = function (opts) {
    opts = opts || {};
    var self = this;
    var updater;

    /**
     * Create the state to content adapter.
     * @param {Object} data
     * @return {StateToContent}
     */
    opts.createStateToContent = function (data) {
        data && data.authors && self._annotationsSTC.updateAuthors(data.authors);
        return self._annotationsSTC;
    };
    opts.createAnnotator = function () {
        return new CommentAnnotator();
    };
    updater = Collection.prototype.createUpdater.call(this, opts);
    // errors should be piped to the Collection by default?
    updater.on('error', function (err) {
        log(err);
    });
    return updater;
};

/**
 * Get the base options that should go with all requests.
 * @return {Object}
 * @private
 */
AnnotationsCollection.prototype._getBaseOpts = function () {
    var user = auth.get('livefyre');
    return {
        network: this.network,
        environment: this.environment,
        collectionId: this.id,
        lftoken: user ? user.get('token') : ''
    };
};

/**
 * Get the http client.
 * @param {string} serviceName
 * @return {AnnotationsHttpClient}
 */
AnnotationsCollection.prototype._getClient = function (serviceName) {
    return new AnnotationsHttpClient({
        serviceName: serviceName
    });
};

/**
 * Remove references
 */
AnnotationsCollection.prototype.destroy = function () {
    Collection.prototype.pause.call(this);
    this.stopListening();
    this._annotationsSTC = null;
    this._erefProcessor = null;
    this._handleUpdate = null;
    this._updater = null;
};

/**
 * Using the decrypted eref value, make a request for the full content state.
 * @param {Array.<string>} refs A batch of decrypted contentIds w/ secure hashes.
 * @param {function()} opt_callback A callback with "err/data" interface
 */
AnnotationsCollection.prototype.fetchErefs = function (refs, opt_callback) {
    var client = this._getClient('bootstrap');
    var self = this;
    var opts = this._getBaseOpts();
    $.extend(opts, {
        refs: refs
    });
    client.fetchErefs(opts, getMediatedCallback(function (err, data) {
        if (err) {
            opt_callback && opt_callback(err);
            return;
        }

        // Updates are applied to the existing models.
        var commentErefs;
        var comments = self._annotationsSTC.adaptThread(data);
        var erefs = [];
        $.each(comments, function(i, comment) {
            commentErefs = comment.erefs;
            // Ensure that there are erefs and that it's not an empty array.
            if (!commentErefs || ($.isArray(commentErefs) && !commentErefs.length)) {
                return;
            }
            erefs.push(commentErefs);
        });
        self._erefProcessor.handleDecrypted(erefs);

        // Ship to stream since we don't know when these requests will be made
        self.push.apply(self, comments);
        opt_callback && opt_callback(err, comments);
    }));
};

/**
 * @param {string} blockId
 * @param {function} callback A callback with "err/data" interface
 */
AnnotationsCollection.prototype.fetchThread = function (blockId, callback) {
    var client = this._getClient('bootstrap');
    var opts = this._getBaseOpts();
    var self = this;
    opts.blockId = blockId;
    client.getAnnotations(opts, getMediatedCallback(function (err, data) {
        if (!data) return;
        // We have now seen this block.
        var block = Storage.get(blockId);
        block && block.setFetchedState(true);
        callback(err, self._annotationsSTC.adaptThread(data, true));
    }));
};

/**
 * Generate the admin url for the current logged in user.
 * @return {string}
 */
AnnotationsCollection.prototype.generateAdminUrl = function () {
    var client = this._getClient('admin');
    var opts = this._getBaseOpts();
    var user = auth.get('livefyre');
    return [
        client.getUrlBase(opts),
        '/admin/content?lftoken=',
        user ? user.get('token') : ''
    ].join('');
};

/**
 * Get a default handler function.
 * @param {string} serviceName Name of the client service.
 * @param {string} handlerFn The name of the client function to use.
 * @return {function(Object, function())}
 */
function getDefaultHandler(serviceName, handlerFn) {
    return function (data, callback) {
        var client = this._getClient(serviceName);
        var opts = this._getBaseOpts();
        $.extend(opts, data);
        client[handlerFn].call(client, opts, getMediatedCallback(callback));
    };
}

/**
 * Get a callback to send to the client.
 * @param {function()} callback
 * @return {function(?Object, ?Object)}
 */
function getMediatedCallback(callback) {
    return function (err, data) {
        // Handle the jsonp case where there is no error but the data object
        // contains the error information.
        if (!err && data.code !== 200) {
            err = data.error_type;
        }
        log(err, data);
        callback(err, data);
    };
}

/**
 * @param {Annotation} data
 * @param {function} callback A callback with "err/data" interface
 */
AnnotationsCollection.prototype.getPermalink = function (data, callback) {
    var client = this._getClient('bootstrap');
    var opts = this._getBaseOpts();
    $.extend(opts, data);
    client.getPermalink(opts, getMediatedCallback(function (err, data) {
        callback(err, Adapters.adaptPermalink(data));
    }));
};

/**
 * @param {Annotation} data
 * @param {function} callback A callback with "err/data" interface
 */
AnnotationsCollection.prototype.getThread = function (data, callback) {
    var client = this._getClient('bootstrap');
    var opts = this._getBaseOpts();
    var self = this;
    $.extend(opts, data);
    client.getThread(opts, getMediatedCallback(function (err, data) {
        if (err) return;
        var thread = self._annotationsSTC.adaptPermalinkThread(data);
        callback(err, thread.blockId, thread.comments);
    }));
};

/**
 * Is this collection part of a custom network?
 * @return {boolean} Yay or nay.
 */
AnnotationsCollection.prototype.isCustomNetwork = memoize(function () {
    return !!this.network.match(/fyre\.co$/);
});

/**
 * Load the tracking iframe.
 * @private
 */
AnnotationsCollection.prototype._loadTrackingIframe = function () {
    if (this._trackingLoaded || this.network === 'fyre') {
        return;
    }
    this._trackingLoaded = true;
    document.body.appendChild($(trackingTemplate({
        trackingHost: '//www.livefyre.com',
        trackingUrl: encodeURIComponent(window.location.href)
    }))[0]);
};

/**
 * @param {Annotation} data
 * @param {function} callback A callback with "err/data" interface
 */
AnnotationsCollection.prototype.postAnnotation = function (data, callback) {
    var client = this._getClient('quill');
    var opts = this._getBaseOpts();
    var self = this;
    $.extend(opts, data);
    opts.postData.lftoken = opts.lftoken;
    client.postAnnotation(opts, getMediatedCallback(function (err, data) {
        if (err) {
            callback(err);
            return;
        }
        callback(err, self._annotationsSTC.adaptThread(data));
    }));
};

/**
 * @param {Object} data
 * @param {function} callback A callback with "err/data" interface
 */
AnnotationsCollection.prototype.postApprove = getDefaultHandler('quill', 'postApprove');

/**
 * @param {Object} data
 * @param {function} callback A callback with "err/data" interface
 */
AnnotationsCollection.prototype.postDelete = getDefaultHandler('quill', 'postDelete');

/**
 * @param {Object} data
 * @param {function} callback A callback with "err/data" interface
 */
AnnotationsCollection.prototype.postEdit = getDefaultHandler('quill', 'postEdit');

/**
 * @param {Object} data
 * @param {function} callback A callback with "err/data" interface
 */
AnnotationsCollection.prototype.postFlag = getDefaultHandler('quill', 'postFlag');

/**
 * @param {Object} data
 * @param {function} callback A callback with "err/data" interface
 */
AnnotationsCollection.prototype.postHide = getDefaultHandler('quill', 'postHide');

/**
 * @param {Object} data
 * @param {function()} callback A callback with "err/data" interface
 */
AnnotationsCollection.prototype.postVote = function (data, callback) {
    var client = this._getClient('quill');
    var opts = this._getBaseOpts();
    $.extend(opts, data);
    client.postVote(opts, getMediatedCallback(function (err, data) {
        if (err) {
            callback(err);
            return;
        }
        data = data[BootstrapKeys.DATA];
        callback(err, data);
    }));
};

/**
 * Try to decrypt the current private content.
 */
AnnotationsCollection.prototype.processStoredErefs = function () {
    var self = this;
    var user = auth.get('livefyre');

    // The login event could trigger a process before the collection inits
    // after init is complete this will be called again.
    this.id && user && permissions.getKeys(user, this, function(err, keys) {
        self._erefProcessor.setKeys(keys || []);
        self._erefProcessor.processStorage();
    });
};

module.exports = AnnotationsCollection;

});

define('annotations/models/block',['require','exports','module','streamhub-sdk/content','inherits'],function (require, exports, module) {/**
 * @file Model for block.
 */
var Content = require('streamhub-sdk/content');
var inherits = require('inherits');

/**
 * Block model.
 * @extends {Content}
 * @constructor
 */
var Block = function() {
    Content.call(this);

    this.id = null;
    this.blockType = Block.TYPES.UNSET;
    this.numAnnotations = 0;
    this.simhash = '';
    this.index = -1;
    this.el = null;
    this.content = null;
    this.generatedId = '';
    this.isFetched = false;
};
inherits(Block, Content);

/** @type {string} */
Block.DATA_ID = 'data-lf-anchor-id';

/** Block types */
Block.TYPES = {
    UNSET: 0,
    TEXT: 1,
    IMAGE: 2,
    MEDIA: 3,
    RICH: 4
};

/**
 * Return the block's id, whether it is known only to the client (.generatedId),
 * or has been save on the BE (.id).
 * @return {string}
 */
Block.prototype.getId = function () {
    return this.id || this.generatedId;
};

/**
 * @param {string} blockId
 */
Block.prototype.setId = function (blockId) {
    this.id = blockId;
};

/**
 * Return true if this block has been persisted to the BE and so, has an id.
 * @returns {boolean}
 */
Block.prototype.isSaved = function () {
    return !!this.id;
};

/**
 * Record that we have fetched this block before.
 * @param {boolean} fetched
 */
Block.prototype.setFetchedState = function (fetched) {
    this.isFetched = fetched;
};

/**
 * Determine if we have fetched this block before.
 * @param {string} blockId
 * @return {boolean}
 */
Block.prototype.getFetchedState = function () {
    return this.isFetched;
};

/**
 * Update the numAnnotations attribute.
 * @param {number} inc The amount to increment the count.
 * @param {number=} opt_count Optionally the count to update to.
 * @return {number} The change from the old count.
 */
Block.prototype.updateNumAnnotations = function (inc, opt_count) {
    var isNumber = typeof opt_count === 'number';
    var count = isNumber ? opt_count : this.numAnnotations + inc;
    var diff = count - this.numAnnotations;
    this.set({numAnnotations: count});
    return diff;
};

module.exports = Block;

});

define('annotations/util/location',['require','exports','module'],function (require, exports, module) {/**
 * @fileOverview location functions.
 */

/** @type {Object} */
module.exports = {
    /**
     * Get the current origin.
     * @return {string}
     */
    getOrigin: function () {
        return window.location.origin || location.getOriginIE();
    },

    /**
     * When partying on an IE browser .
     * @return {string}
     */
    getOriginIE: function () {
        var port = '';
        if (window.location.port) {
            port = ':' + window.location.port;
        }
        return window.location.protocol + '//' + window.location.hostname + port;
    }
};

});

define("hgn!templates/blocks/mediawrapper", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-media-wrapper\"></div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

/*
 * JavaScript MD5 1.0.1
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 * 
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*jslint bitwise: true */
/*global unescape, define */

(function ($) {
    

    /*
    * Add integers, wrapping at 2^32. This uses 16-bit operations internally
    * to work around bugs in some JS interpreters.
    */
    function safe_add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
    * Bitwise rotate a 32-bit number to the left.
    */
    function bit_rol(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }

    /*
    * These functions implement the four basic operations the algorithm uses.
    */
    function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }
    function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }
    function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }
    function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    }

    /*
    * Calculate the MD5 of an array of little-endian words, and a bit length.
    */
    function binl_md5(x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << (len % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var i, olda, oldb, oldc, oldd,
            a =  1732584193,
            b = -271733879,
            c = -1732584194,
            d =  271733878;

        for (i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i],       7, -680876936);
            d = md5_ff(d, a, b, c, x[i +  1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i +  2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i +  4],  7, -176418897);
            d = md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i +  7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);
            d = md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i +  1],  5, -165796510);
            d = md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i],      20, -373897302);
            a = md5_gg(a, b, c, d, x[i +  5],  5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10],  9,  38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i +  4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i +  9],  5,  568446438);
            d = md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);
            c = md5_gg(c, d, a, b, x[i +  3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);
            d = md5_gg(d, a, b, c, x[i +  2],  9, -51403784);
            c = md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i +  5],  4, -378558);
            d = md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);
            d = md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i +  7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13],  4,  681279174);
            d = md5_hh(d, a, b, c, x[i],      11, -358537222);
            c = md5_hh(c, d, a, b, x[i +  3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i +  6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i +  9],  4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i +  2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i],       6, -198630844);
            d = md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i +  5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);
            d = md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i +  4],  6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i +  2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i +  9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    }

    /*
    * Convert an array of little-endian words to a string
    */
    function binl2rstr(input) {
        var i,
            output = '';
        for (i = 0; i < input.length * 32; i += 8) {
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
        }
        return output;
    }

    /*
    * Convert a raw string to an array of little-endian words
    * Characters >255 have their high-byte silently ignored.
    */
    function rstr2binl(input) {
        var i,
            output = [];
        output[(input.length >> 2) - 1] = undefined;
        for (i = 0; i < output.length; i += 1) {
            output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
        }
        return output;
    }

    /*
    * Calculate the MD5 of a raw string
    */
    function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
    }

    /*
    * Calculate the HMAC-MD5, of a key and some data (raw strings)
    */
    function rstr_hmac_md5(key, data) {
        var i,
            bkey = rstr2binl(key),
            ipad = [],
            opad = [],
            hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length > 16) {
            bkey = binl_md5(bkey, key.length * 8);
        }
        for (i = 0; i < 16; i += 1) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
    }

    /*
    * Convert a raw string to a hex string
    */
    function rstr2hex(input) {
        var hex_tab = '0123456789abcdef',
            output = '',
            x,
            i;
        for (i = 0; i < input.length; i += 1) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt((x >>> 4) & 0x0F) +
                hex_tab.charAt(x & 0x0F);
        }
        return output;
    }

    /*
    * Encode a string as utf-8
    */
    function str2rstr_utf8(input) {
        return unescape(encodeURIComponent(input));
    }

    /*
    * Take string arguments and return either raw or hex encoded strings
    */
    function raw_md5(s) {
        return rstr_md5(str2rstr_utf8(s));
    }
    function hex_md5(s) {
        return rstr2hex(raw_md5(s));
    }
    function raw_hmac_md5(k, d) {
        return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
    }
    function hex_hmac_md5(k, d) {
        return rstr2hex(raw_hmac_md5(k, d));
    }

    function md5(string, key, raw) {
        if (!key) {
            if (!raw) {
                return hex_md5(string);
            }
            return raw_md5(string);
        }
        if (!raw) {
            return hex_hmac_md5(key, string);
        }
        return raw_hmac_md5(key, string);
    }

    if (typeof define === 'function' && define.amd) {
        define('md5',[],function () {
            return md5;
        });
    } else {
        $.md5 = md5;
    }
}(this));

define('annotations/util/simhash',['require','exports','module','md5'],function (require, exports, module) {/**
 * @file A Simhash class.
 */
var md5 = require('md5');

/**
 * Class to produce and compare simhash.
 * @constructor
 * @param {string} s - A string for which to create a simhash.
 */
var Simhash = function(s) {
    this.value = Simhash._calcSimhash(s);
};

/**
 * Returns a hamming distance of two simhash values.
 * @param {Simhash} simhash - A Simhash object
 * @returns {number} A hamming distance
 */
Simhash.prototype.hammingDistanceTo = function(simhash) {
    var xArray = Simhash._convertTo32Bits(this.value);
    var yArray = Simhash._convertTo32Bits(simhash.value);

    var result = [];
    for (var i = 0; i < xArray.length; i++) {
        result.push((xArray[i] ^ yArray[i]) >>> 0);
    }
    return Simhash._hammingDistance(Simhash._convertArrayToHexString(result));
};

/**
 * Returns the similarity to a simhash value.
 * @param {Simhash} simhash - A simhash instance
 */
Simhash.prototype.similarTo = function(simhash) {
    if (!simhash instanceof Simhash) {
        return null;
    }
    return Simhash.similarity(this.value, simhash.value);
};

/**
 * Returns a 128 bit simhash hex string
 * @param {string} s - A string
 * @returns {string} A 128 bits simhash hex string
 */
Simhash._calcSimhash = function(s) {
    var tokens = Simhash._tokenize(s);
    var shingles = [[], [], [], []];
    var i;

    for (i = 0; i < tokens.length; i++) {
        var md5Str = md5(tokens[i]);
        var md5Array = Simhash._convertTo32Bits(md5Str);

        for (var j = 0; j < md5Array.length; j++) {
            shingles[j].push(md5Array[j]);
        }
    }

    var result = [];
    for (i = 0; i < shingles.length; i++) {
        result.push(Simhash._convertToHexString(Simhash._simhash(shingles[i])));
    }
    return result.join('');
};

/**
 * Convert a 32 bit number to a hex string.
 * @param {number} n
 * @returns {string} a 128 bits hex string
 */
Simhash._convertToHexString = function(n) {
    var result = n.toString(16);
    var len = 8 - result.length;

    var zeros = [];
    for (var i = 0; i < len; i++) {
        zeros.push('0');
    }
    return zeros.join('') + result;
};

/**
 * Covert an array of four 32 bits integer to a hex string.
 * @param {Array} a - An array of four 32 bits integer.
 * @returns {string} A 128 bits hex string
 */
Simhash._convertArrayToHexString = function(a) {
    var result = [];
    for (var i = 0; i < 4; i++) {
        result.push(Simhash._convertToHexString(a[i]));
    }
    return result.join('');
};

/**
 * Break up a 128 bits hex string into an array of four 32 bits integers.
 * @param {string} s - a 128 bits hex string
 * @returns {Array} An array of 4 32 bits integers
 */
Simhash._convertTo32Bits = function(s) {
    if (!s) {
        return null;
    }

    var len = 32;
    var chSize = 8;  // 8 hex chars are 32 bits.
    var ints = [];

    for (var i = 0; i < len; i += chSize) {
        var chunk = i + chSize < len ? s.slice(i, i + chSize) : s.slice(i);
        ints.push(parseInt(chunk, 16));
    }
    return ints;
};

/**
 * Returns a 32 bit unsigned simhash.
 * @param {Array} shingles - An array of 32 bits integers
 * @returns {number} A simhash which is a 32 bits unsigned number
 */
Simhash._simhash = function(shingles) {
    var simhash = 0x0;
    var mask = 0x1;
    var shingle;

    for (var pos = 0; pos < 32; pos++) {
        var weight = 0;
        for (var i = 0; i < shingles.length; i++) {
            shingle = shingles[i];
            weight += (shingle & mask) ? 1 : -1;
        }
        if (weight > 0) {
            simhash |= mask;
        }
        mask <<= 1;
    }

    return simhash >>> 0;
};

/**
 * Returns an array of tokens.
 * @param {string} s - A string to be tokenized
 * @returns {Array.<string>} A array of tokens
 */
Simhash._tokenize = function(s) {
    if (!s) {
        return [''];
    }

    // Replace punctuation and spaces with a single space.
    var regex = /[\s\-=_!"#%&'*{},.\/:;?\(\)\[\]@\\$\^*+<>~`\u00a1\u00a7\u00b6\u00b7\u00bf\u037e\u0387\u055a-\u055f\u0589\u05c0\u05c3\u05c6\u05f3\u05f4\u0609\u060a\u060c\u060d\u061b\u061e\u061f\u066a-\u066d\u06d4\u0700-\u070d\u07f7-\u07f9\u0830-\u083e\u085e\u0964\u0965\u0970\u0af0\u0df4\u0e4f\u0e5a\u0e5b\u0f04-\u0f12\u0f14\u0f85\u0fd0-\u0fd4\u0fd9\u0fda\u104a-\u104f\u10fb\u1360-\u1368\u166d\u166e\u16eb-\u16ed\u1735\u1736\u17d4-\u17d6\u17d8-\u17da\u1800-\u1805\u1807-\u180a\u1944\u1945\u1a1e\u1a1f\u1aa0-\u1aa6\u1aa8-\u1aad\u1b5a-\u1b60\u1bfc-\u1bff\u1c3b-\u1c3f\u1c7e\u1c7f\u1cc0-\u1cc7\u1cd3\u2016\u2017\u2020-\u2027\u2030-\u2038\u203b-\u203e\u2041-\u2043\u2047-\u2051\u2053\u2055-\u205e\u2cf9-\u2cfc\u2cfe\u2cff\u2d70\u2e00\u2e01\u2e06-\u2e08\u2e0b\u2e0e-\u2e16\u2e18\u2e19\u2e1b\u2e1e\u2e1f\u2e2a-\u2e2e\u2e30-\u2e39\u3001-\u3003\u303d\u30fb\ua4fe\ua4ff\ua60d-\ua60f\ua673\ua67e\ua6f2-\ua6f7\ua874-\ua877\ua8ce\ua8cf\ua8f8-\ua8fa\ua92e\ua92f\ua95f\ua9c1-\ua9cd\ua9de\ua9df\uaa5c-\uaa5f\uaade\uaadf\uaaf0\uaaf1\uabeb\ufe10-\ufe16\ufe19\ufe30\ufe45\ufe46\ufe49-\ufe4c\ufe50-\ufe52\ufe54-\ufe57\ufe5f-\ufe61\ufe68\ufe6a\ufe6b\uff01-\uff03\uff05-\uff07\uff0a\uff0c\uff0e\uff0f\uff1a\uff1b\uff1f\uff20\uff3c\uff61\uff64\uff65]+/g;
    var result = s
        .replace(regex, ' ')
        .replace(/[\s\xa0]+/g, ' ')
        .replace(/^\s+|\s+$/g, '')
        .toLowerCase();
    return result.split(' ');
};

/**
 * Returns a hamming distance.
 * @param {string} s - A 128 bits simhash hex string
 * @returns {number} A hamming distance
 */
Simhash._hammingDistance = function(s) {
    var result = 0;
    var x = Simhash._convertTo32Bits(s);

    for (var i = 0; i < x.length; i++) {
        var v = x[i];
        var distance;
        for (distance = 0; v; distance++) {
            v &= v - 1;
        }
        result += distance;
    }

    return result;
};

/**
 * Returns the similarity of two simhash values.
 * @param {string} x - A 128 bit simhash hex string
 * @param {string} y - A 128 bit simhash hex string
 * @returns {number} A percent of similarity
 */
Simhash.similarity = function(x, y) {
    var xArray = Simhash._convertTo32Bits(x);
    var yArray = Simhash._convertTo32Bits(y);

    var andResult = [];
    var orResult = [];

    for (var i = 0; i < xArray.length; i++) {
        andResult.push((xArray[i] & yArray[i]) >>> 0);
        orResult.push((xArray[i] | yArray[i]) >>> 0);
    }

    // TODO: Very very rare would the divider be zero, but divide
    // by zero is bad.
    var a = Simhash._hammingDistance(Simhash._convertArrayToHexString(andResult));
    var b = Simhash._hammingDistance(Simhash._convertArrayToHexString(orResult));

    return a / b;
};

module.exports = Simhash;

});

define('annotations/util/object',['require','exports','module'],function (require, exports, module) {module.exports = {
    /**
     * Returns the keys of an object.
     * @param {Object} obj
     * @return {!Array.<string>}
     */
    getKeys: function(obj) {
        var res = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                res.push(key);
            }
        }
        return res;
    },

    /**
     * Returns the values of an object.
     * @param {Object} obj
     * @return {!Array.<*>}
     */
    getValues: function(obj) {
        var res = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                res.push(obj[key]);
            }
        }
        return res;
    }
};

});

define('annotations/util/simhashlookup',['require','exports','module','annotations/adapters','annotations/util/simhash','annotations/util/object'],function (require, exports, module) {/**
 * @file A class to lookup simhash.
 */
var KEYS = require('annotations/adapters').BootstrapKeys;
var Simhash = require('annotations/util/simhash');
var getKeys = require('annotations/util/object').getKeys;


/**
 * A class for lookup
 */
var SimhashLookup = function(data) {
    this._simhashToBlockIdLookup = this._createSimhashToBlockIdLookup(data);
};

/**
 * Build a lookup for simhash to an array of block ID mapping.
 *
 * @param {Object} data - Block data.
 * @private
 */
SimhashLookup.prototype._createSimhashToBlockIdLookup = function(data) {
    var lookup = {};

    for (var blockId in data) {
        if (data.hasOwnProperty(blockId)) {
            var hints = data[blockId][KEYS.HINTS];
            var simhash = hints[KEYS.SIMHASH];
            var index = hints[KEYS.INDEX];

            lookup[simhash] = lookup[simhash] || [];
            // The position of the block ID in the array correponds to
            // the position of repeated blocks.
            lookup[simhash][index] = blockId;
        }
    }
    return lookup;
};

/**
 * Get the block ID given a simhash value and index.
 * @param {string} simhash - A 128 bit simhash hex string
 * @param {number} index - An index of the block
 * @returns {?string} The block ID.
 */
SimhashLookup.prototype.getBlockId = function(simhash, index) {
    if (this._simhashToBlockIdLookup.hasOwnProperty(simhash)) {
        var blockIds = this._simhashToBlockIdLookup[simhash];
        return blockIds[index] || null;
    }
    return null;
};

/**
 * Get the block ID whose simhash value is above the threshold.
 * @param (string) simhash - A 128 bit simhash hex string
 * @param {number} index - An index of the block
 * @returns (?string) The block ID.
 */
SimhashLookup.prototype.getBlockIdWithThreshold = function(simhash, index, threshold) {
    var matchedSimhash;
    var bestSimilarity = 0;
    var simhashes = getKeys(this._simhashToBlockIdLookup);

    for (var i = 0, l = simhashes.length; i < l; i++) {
        var s = Simhash.similarity(simhash, simhashes[i]);
        // Keep track of the best similarity.
        if (s > threshold && s > bestSimilarity) {
            bestSimilarity = s;
            matchedSimhash = simhashes[i];
        }
    }
    return this.getBlockId(matchedSimhash, index);
};

module.exports = SimhashLookup;

});

define("hgn!templates/blocks/elementwrap", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<span class=\"lf-text-block\">");_.b(_.v(_.f("content",c,p,0)));_.b("</span>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/blocks/detector',['require','exports','module','jquery','annotations/models/block','annotations/adapters','annotations/util/location','hgn!templates/blocks/mediawrapper','annotations/util/simhash','annotations/util/simhashlookup','annotations/util/storage','hgn!templates/blocks/elementwrap'],function (require, exports, module) {/**
 * @fileOverview A class to detect blocks in the content.
 */

var $ = require('jquery');
var Block = require('annotations/models/block');
var KEYS = require('annotations/adapters').BootstrapKeys;
var locationUtil = require('annotations/util/location');
var mediaWrapper = require('hgn!templates/blocks/mediawrapper');
var Simhash = require('annotations/util/simhash');
var SimhashLookup = require('annotations/util/simhashlookup');
var Storage = require('annotations/util/storage');
var wrap = require('hgn!templates/blocks/elementwrap');

/**
 * A class to detect blocks in the content.
 * @constructor
 * @param {Object} opts - A JSON object.
 */
var BlockDetector = function (opts) {
    this._bootstrap = opts.content || {};
    this._selectors = opts.selectors;
    this._simhashLookup = new SimhashLookup(this._bootstrap);
};

/**
 * Custom block id set by the user. This must be page-unique. This will be used
 * as the block id.
 * @type {string}
 */
var CUSTOM_BLOCK_ID_ATTR_BACKCOMPAT = 'data-lf-block-id';  // Storify uses this, but no one else knows about it.
var CUSTOM_BLOCK_ID_ATTR = 'data-lf-custom-anchor-id';

/**
 * Custom block type set by the user. This will be used to pick which block type
 * will be used.
 * @type {string}
 */
var CUSTOM_BLOCK_TYPE_ATTR_BACKCOMPAT = 'data-lf-block-type';
var CUSTOM_BLOCK_TYPE_ATTR = 'data-lf-custom-anchor-type';

/**
 * Style attributes that we want to carry over from the image to the wrapper
 * and remove completely from the image. If we don't remove them from the image,
 * weird styling issues will occur.
 * @const {Object.<string, string|number>}
 */
var IMG_STYLE_ATTRS = {
    'bottom': 0,
    'float': 'none',
    'left': 0,
    'margin': 0,
    'padding': 0,
    'right': 0,
    'top': 0
};

/** @const {Array.<string>} */
var MEDIA_ELEMENTS = ['IMG'];

/**
 * List of media types.
 * @type {Array.<string>}
 */
var MEDIA_TYPES = [
    Block.TYPES.IMAGE,
    Block.TYPES.MEDIA,
    Block.TYPES.VIDEO
];

/**
 * Data attribute added to media elements to store the pre-wrapped style
 * attributes so that it can be replaced upon completion.
 * @type {string}
 */
var SAVED_STYLE_ATTR = 'data-lf-saved-style';

/** @enum {string} */
BlockDetector.CLASSES = {
    BLOCK: 'lf-block',
    IMAGE: 'lf-image-block',
    MEDIA_WRAPPER: 'lf-media-wrapper',
    RICH: 'lf-rich-block',
    TEXT: 'lf-text-block',
    VIDEO: 'lf-video-block'
};

/**
 * Similarity above the threshold is consided a match.
 * @type {number}
 */
BlockDetector.SIMILARITY_THRESHOLD = 0.65;

/**
 * Apply display CSS to the wrapper and image.
 * @param {jQuery.Element} wrap The wrapper element.
 * @param {jQuery.Element} img The image element.
 */
function applyDisplay(wrap, img) {
    var key = 'display';
    var display = img.css(key);
    // Need to force inline-block for inline elements. This protects against
    // some strange cases.
    if (display === 'inline') {
        display = 'inline-block';
    }
    wrap.css(key, display);
}

/**
 * Apply position CSS to the wrapper and image.
 * @param {jQuery.Element} wrap The wrapper element.
 * @param {jQuery.Element} img The image element.
 */
function applyPosition(wrap, img) {
    var key = 'position';
    var position = img.css(key);
    // We only want to use relative and absolute positioning because the inner
    // thread button needs to sit in a corner.
    if (['relative', 'absolute'].indexOf(position) === -1) {
        position = 'relative';
    }
    wrap.css(key, position);
    img.css(key, 'relative');
}

/**
 * Get a set of blocks based on the provided selectors.
 * @param {jQuery} selectors The selectors to use when generating the set.
 * @return {Array.<Block>}
 */
function getBlockSet(selectors) {
    return selectors.map(function(i, element) {
        var blk = new Block();
        var CLASSES = BlockDetector.CLASSES;
        // Element should be an element, not a jQuery.Element
        var elem = element instanceof $ ? element[0] : element;
        var $elem = $(elem);
        var customTypeAttr = ($elem.attr(CUSTOM_BLOCK_TYPE_ATTR) ||
            $elem.attr(CUSTOM_BLOCK_TYPE_ATTR_BACKCOMPAT) || 'text').toUpperCase();

        if (isMedia(elem) || customTypeAttr === Block.TYPES.MEDIA) {
            blk.el = wrapMedia(elem);
            blk.blockType = Block.TYPES.MEDIA;
        } else {
            blk.el = wrapElement(elem);
            blk.blockType = Block.TYPES[customTypeAttr];
            $(blk.el).addClass(CLASSES[customTypeAttr]);
        }

        // It's possible that the wrapped element isn't valid, so we don't
        // want to keep it.
        if (!blk.el) {
            return;
        }
        $(blk.el).addClass(CLASSES.BLOCK);
        if ($elem.is('img')) {
            blk.blockType = Block.TYPES.IMAGE;
            var imageSrc = $elem.attr('src');
            // Convert relative urls to absolute urls
            if (imageSrc.indexOf('/') === 0) {
                imageSrc = locationUtil.getOrigin() + imageSrc;
            }
            blk.content = imageSrc;

            return blk;
        }
        blk.content = $elem.text();
        return blk;
    }).get();
}

/**
 * Determines if an element counts as media.
 * @param {Element} el The element to check.
 * @return {boolean} Whether the element is media or not.
 */
function isMedia(el) {
    return $.inArray(el.tagName, MEDIA_ELEMENTS) !== -1;
}

/**
 * Wraps a text node in a span so that it can be used as a block.
 * @param {Text} textNode The text node to wrap.
 * @return {Element} Wrapped element.
 */
function wrapElement(element) {
    // Don't wrap normal elements
    if (element.nodeName !== '#text') {
        return $(element)[0];
    }
    // Don't wrap empty text nodes
    if (!element.nodeValue.trim().length) {
        return null;
    }

    var elem = $(wrap({content: element.nodeValue}))[0];
    element.parentNode.replaceChild(elem, element);
    return elem;
}

/**
 * Wraps an image in a div so that we can put a block annotation counter on it.
 * @param {Element} element The element to wrap.
 * @return {Element} Wrapped element.
 */
function wrapMedia(element) {
    var $el = $(element);
    $el.attr(SAVED_STYLE_ATTR, $el.attr('style'));
    var $wrapperEl = $el.wrap(mediaWrapper()).parent();
    var orig;

    $.each(IMG_STYLE_ATTRS, function (key, value) {
        orig = $el.css(key);
        $wrapperEl.css(key, orig || value);
        $el.css(key, value === 'inherit' ? orig : value);
    });
    applyDisplay($wrapperEl, $el);
    applyPosition($wrapperEl, $el);

    var CLASSES = BlockDetector.CLASSES;
    var cls = element.tagName === MEDIA_ELEMENTS[0] ? CLASSES.IMAGE : CLASSES.VIDEO;
    $wrapperEl.addClass(cls);
    return $wrapperEl[0];
}

/**
 * Unwraps an element.
 * @param {Element} element The element to unwrap.
 */
function unwrapElement(element) {
    var $el = $(element);
    if (element.tagName === 'SPAN') {
        $(element.childNodes[0]).unwrap();
        return;
    }
    // Remove classes from the element
    $.each(BlockDetector.CLASSES, function (key, cls) {
        $el.removeClass(cls);
    });
    // Remove data attribute from the element
    $el.removeAttr(Block.DATA_ID);
}

/**
 * Unwraps a media element.
 * @param {Element} element The media element to unwrap.
 */
function unwrapMedia(element) {
    var $children = $(element).children();
    $children.attr('style', $children.attr(SAVED_STYLE_ATTR) || '');
    $children.removeAttr(SAVED_STYLE_ATTR);
    $children.unwrap();
}

/**
 * Match the array of Blocks returned by the selector function with the
 * bootstrap data and returns the result as an array of Blocks.
 *
 * The selector function is required to return an array of Blocks of which
 * content and el must be set.  The content is what being simhashed and matched
 * with the bootstrap data. The el is the reference to the HTML element.
 *
 * As the method iterates through each Block in the array returned by the
 * selector function, it tries to find a (exact or similar) match in the
 * bootstrap data.  Information about the match is captured in a Block and
 * ultimately returned as an array.  If no match is found, a Block is still
 * returned but information like the block ID, the number of annotations,
 * and the index will not be available.
 *
 * @param (Function=) opt_selector - A function which returns an array of Blocks.
 * @returns {Array} An array of AnnotationView objects.
 */
BlockDetector.prototype.detect = function (opt_selector) {
    var blockIndices = {};
    var blks = opt_selector ? opt_selector() : getBlockSet(this._selectors);
    var block;
    var i;
    var len;

    for (i = 0, len = blks.length; i < len; i++) {
        block = blks[i];

        // If the block element doesn't exist, no need to continue processing
        // this block.
        if (!block.el) {
            continue;
        }

        block.simhash = new Simhash(block.content).value;

        // Keep track of number of repeated blocks.
        if (blockIndices[block.simhash] === undefined) {
            blockIndices[block.simhash] = 0;
        } else {
            blockIndices[block.simhash] += 1;
        }

        // Order of operations for blocks ids is:
        // 1. Get block id from bootstrap
        // 1.5 Check for imposters
        // 2. Get custom id from element that the user has put on there
        // 3. Generate our own with simhash concatenated with index

        var indices = block.index = blockIndices[block.simhash];
        var blockId = this._simhashLookup.getBlockId(block.simhash, indices);
        if (!blockId) {
            blockId = this._simhashLookup.getBlockIdWithThreshold(
                   block.simhash, indices, BlockDetector.SIMILARITY_THRESHOLD);
        }

        // 1.5 If there is an exact match, do not use a similar match.
        if (blockId) {
            var simhashPart = blockId.split(':')[0];
            if (this._simhashLookup.getBlockId(simhashPart, indices) &&
                simhashPart !== block.simhash) {
                blockId = null;
            }
        }

        var $blockEl = $(block.el);

        // 1. The blockId exists, use it.
        if (blockId) {
            block.index = this._bootstrap[blockId][KEYS.HINTS][KEYS.INDEX];
            block.id = blockId;
            block.numAnnotations = this._bootstrap[blockId][KEYS.NUM_ANNOTATIONS];
            Storage.set(block.id, block);
            $blockEl.attr(Block.DATA_ID, block.id);
            continue;
            // TODO(sfung): The simhash could be different because it's similar.
            //              Return old simhash or new simhash.
        }

        // 2. Check if the user has added a custom block id
        var customId = $blockEl.attr(CUSTOM_BLOCK_ID_ATTR) ||
                       $blockEl.attr(CUSTOM_BLOCK_ID_ATTR_BACKCOMPAT);
        if (customId) {
            block.generatedId = block.id = customId;
            Storage.set(block.generatedId, block);
            $blockEl.attr(Block.DATA_ID, block.id);
            continue;
        }
        // 3. Generate the block id
        block.generatedId = block.id = block.simhash + ':' + block.index;
        Storage.set(block.generatedId, block);
        $blockEl.attr(Block.DATA_ID, block.id);
    }

    return blks;
};

/**
 * Unwrap a block. This removes all Sidenotes related classes and data
 * attributes from the block element.
 * @param {Block} block The block to unwrap.
 */
BlockDetector.unwrapBlock = function (block) {
    if (MEDIA_TYPES.indexOf(block.blockType) > -1) {
        unwrapMedia(block.el);
        return;
    }
    unwrapElement(block.el);
};

module.exports = BlockDetector;

});

define('annotations/util/useragent',['require','exports','module','annotations/util/internals'],function (require, exports, module) {/**
 * @fileOverview User agent functions.
 */

var internals = require('annotations/util/internals');

/** @type {Object} */
var userAgent = {};

/**
 * Get the browser version.
 * @return {string|number}
 */
userAgent.getIEVersion = internals.memoize(function () {
    if (navigator.userAgent.match(/MSIE ([0-9]+)\./)) {
        return parseInt(RegExp.$1, 10);
    }
    return null;
});

/**
 * Is the current browser IE?
 * @return {boolean} yay or nay.
 */
userAgent.isIE = internals.memoize(function () {
    return /MSIE ([0-9]+)\./.test(navigator.userAgent);
});

/**
 * Is the current browser mobile?
 * @return {boolean} yay or nay.
 */
userAgent.isMobile = internals.memoize(function () {
    var mobile = navigator.appVersion.indexOf('Mobile') !== -1;
    var android = navigator.appVersion.indexOf('Android') !== -1;
    return mobile || android;
});

module.exports = userAgent;

});

define('xrange/util/dom',['require','exports','module'],function (require, exports, module) {/**
 * @fileOverview Commonly used utility functions.
 */

/** @type {Object} */
var util = {};

/**
 * Find the first or last node within an element based on the optional second
 * argument.
 * @param {Element} parent The parent element to search.
 * @param {boolean=} opt_last Optionally select the last node within the element.
 * @return {Node} The first or last node in the element.
 */
util.findNodeInElement = function (parent, opt_last) {
  var _node;
  var fn = !opt_last ? util.forEachNode : util.forEachNodeReverse;
  fn(parent, function (node) {
    _node = node;
    return true;
  });
  return _node;
};

/**
 * Process an individual node. If there are child nodes of the current node,
 * call the fn argument. Otherwise, call the callback with the node as a param.
 * @param {Element|Node} node The node to process.
 * @param {function()} callback The function to call when a node is reached.
 * @param {function()} fn The function to call for recursion.
 * @return {boolean=} Whether we should continue to process.
 */
function processNode(node, callback, fn) {
  // If there are child nodes, go into them.
  if (node.hasChildNodes()) {
    return fn(node, callback);
  }
  // We only want to call the callback for text nodes.
  if (node.nodeType !== 3) {
    return;
  }
  return callback(node);
}

/**
 * Recursively iterates over the nodes that exist within the provided parent
 * element and calls the provided callback for each one. If the callback returns
 * true, the iteration will stop.
 * @param {Element} parent The parent element to search.
 * @param {function()} callback The function to call for each node.
 * @return {boolean=} True if the iteration was stopped prematurely.
 */
util.forEachNode = function (parent, callback) {
  var childNodes = parent.childNodes;
  for (var i = 0; i < childNodes.length; i++) {
    if (processNode(childNodes[i], callback, util.forEachNode)) {
      return true;
    }
  }
};

/**
 * Recursively iterates over the nodes that exist within the provided parent
 * element and calls the provided callback for each one. If the callback returns
 * true, the iteration will stop. This goes in reverse order, starting at the
 * end of the parent's child nodes.
 * @param {Element} parent The parent element to search.
 * @param {function()} callback The function to call for each node.
 * @return {boolean=} True if the iteration was stopped prematurely.
 */
util.forEachNodeReverse = function (parent, callback) {
  var childNodes = parent.childNodes;
  for (var i = childNodes.length - 1; i >= 0; i--) {
    if (processNode(childNodes[i], callback, util.forEachNodeReverse)) {
      return true;
    }
  }
};

/**
 * Iterates over a node's siblings until it doesn't have any left and calls the
 * callback function for each node it encounters. If one of the siblings is an
 * Element, it will process all of the element's children, calling the callback
 * for each node.
 * @param {Element|Node} node The node to iterate it's siblings.
 * @param {function()} callback The function to call for each node.
 * @return {boolean} True if the iteration was stopped prematurely.
 */
util.forEachSibling = function (node, callback) {
  var next = node.nextSibling;
  while (next) {
    if (processNode(next, callback, util.forEachNode)) {
      return true;
    }
    next = next.nextSibling;
  }
  return false;
};

/**
 * Returns a text rectangle object that encloses a group of text rectangles.
 * @return {Object}
 */
util.getBoundingClientRect = function (elem) {
  var rect = elem.getBoundingClientRect();
  // Sometimes IE has a problem getting this value for the first time. When
  // this happens, all of the data attributes are 0. It always seems to work
  // the second time, even if it's immediately after.
  if (!rect.height && !rect.top) {
    rect = elem.getBoundingClientRect();
  }
  // On some of the older IE browsers, the rect object doesn't contain
  // attributes for height or width, so we get to generate it!
  if (typeof rect.height === undefined) {
    rect = {top: rect.top, right: rect.right, bottom: rect.bottom, left: rect.left};
    rect.height = rect.bottom - rect.top;
    rect.width = rect.right - rect.left;
  }
  return rect;
};

/**
 * Puts the specified node and all of its subtree into a "normalized" form. In
 * a normalized subtree, no text nodes in the subtree are empty and there are
 * no adjacent text nodes.
 * @param {Element} parentNode The parent element to normalize.
 */
util.normalize = function (parentNode) {
  var childNodes = parentNode.childNodes;
  var i;
  var len;
  var node;
  var nodesToRemove = [];
  var textNode;

  // Clean up the nodes and add some of the remove bin.
  for (i=0, len=childNodes.length; i<len; i++) {
    node = childNodes[i];
    // Recursively update child elements.
    if (node.hasChildNodes()) {
      util.normalize(node);
      textNode = null;
      continue;
    }
    if (textNode) {
      if (node.nodeType === 3) {
        nodesToRemove.push(node);
        textNode.nodeValue += node.nodeValue;
        continue;
      }
      textNode = null;
      continue;
    }
    if (node.nodeType === 3) {
      textNode = node;
    }
  }

  for (i=0, len=nodesToRemove.length; i<len; i++) {
    parentNode.removeChild(nodesToRemove[i]);
  }
};

module.exports = util;

});

define('xrange/util/base',['require','exports','module'],function (require, exports, module) {/**
 * @fileOverview Commonly used utility functions.
 */

/** @type {Object} */
var util = {};

/**
 * Abstract method. Throws an exception if it is not overridden.
 * @throws {Exception} If not overridden.
 */
util.abstractMethod = function () {
  throw 'This function must be overridden';
};

/**
 * Memoize a function. That is, only run the function once and cache the result
 * so that it doesn't have to keep calculating it.
 * @param {function()} fn The function to memoize.
 * @return {function()} The memoized function.
 */
util.memoize = function (fn) {
  return function() {
    var value = fn.call(this);
    fn = function () {
      return value;
    };
    return value;
  };
};

module.exports = util;

});

define('xrange/util', ['xrange/util/base'], function (main) { return main; });

define('xrange/abstractrange',['require','exports','module','xrange/util'],function (require, exports, module) {/**
 * @fileOverview Abstract range class.
 */

var abstractMethod = require('xrange/util').abstractMethod;

/**
 * Abstract range class.
 */
function AbstractRange() {}

/**
 * Create a native range instance. If there is a selection, create it based on
 * the selection.
 * @return {TextRange} The native range instance.
 */
AbstractRange.prototype._createNativeRange = abstractMethod;

/**
 * Add the range to the selection
 */
AbstractRange.prototype.addToSelection = abstractMethod;

/**
 * Backup the range string in case it needs to be rebuilt.
 */
AbstractRange.prototype.backup = abstractMethod;

/**
 * Clear the native selection.
 */
AbstractRange.prototype.clearNativeSelection = abstractMethod;

/**
 * Delete the contents of the range.
 */
AbstractRange.prototype.deleteContents = abstractMethod;

/**
 * Returns a text rectangle object that encloses a group of text rectangles.
 * @return {Object}
 */
AbstractRange.prototype.getBoundingClientRect = abstractMethod;

/**
 * Get the end node for this range.
 * @return {Node} The end node of this range.
 */
AbstractRange.prototype.getEndNode = abstractMethod;

/**
 * Get the end offset for this range. That is, the offset within end node.
 * @return {number} The offset position within the end node.
 */
AbstractRange.prototype.getEndOffset = abstractMethod;

/**
 * Get the original html string of the range.
 * @type {string}
 */
AbstractRange.prototype.getOriginalString = abstractMethod;

/**
 * Get the parent element of the range.
 * @return {Element} The parent element.
 */
AbstractRange.prototype.getParentNode = abstractMethod;

/**
 * Get the start node for this range.
 * @return {Node} The start node of this range.
 */
AbstractRange.prototype.getStartNode = abstractMethod;

/**
 * Get the start offset for this range. That is, the offset within start node.
 * @return {number} The offset position within the start node.
 */
AbstractRange.prototype.getStartOffset = abstractMethod;

/**
 * Insert the provided element into the range.
 * @param {Element} element The element to insert into the range.
 */
AbstractRange.prototype.insertNode = abstractMethod;

/**
 * Select the contents of the provided node.
 * @param {Node} node The node to select contents of.
 */
AbstractRange.prototype.selectNodeContents = abstractMethod;

/**
 * Set the end position of this range.
 * @param {Node} node The node to end the range in.
 * @param {number} index The character index in the node to end the range.
 */
AbstractRange.prototype.setEnd = abstractMethod;

/**
 * Set the start of the range.
 * @param {Node} node The node in which to start the range.
 * @param {number} index The position in the node to start the range.
 */
AbstractRange.prototype.setStart = abstractMethod;

/**
 * Get the html string contents of the range.
 * @return {string} The html string contents of the range.
 */
AbstractRange.prototype.toHtmlString = abstractMethod;

/**
 * Get the string contents of the range.
 * @return {string} The string contents of the range.
 */
AbstractRange.prototype.toString = abstractMethod;

module.exports = AbstractRange;

});

define('xrange/standardrange',['require','exports','module','xrange/abstractrange','inherits'],function (require, exports, module) {/**
 * @fileOverview Range class that will be used as a wrapper for native browser
 * ranges and provides the same interface as the w3c Range class.
 */

var AbstractRange = require('xrange/abstractrange');
var inherits = require('inherits');

/**
 * Custom range class. This provides a similar interface to the w3c Range.
 * @constructor
 * @extends {AbstractRange}
 * @param {Range=} opt_range Optionally pass a range when
 *   constructing the new Range. It defaults to creating a new range.
 */
function StandardRange(opt_range) {
  /**
   * The native browser range object. This will be used heavily behind the
   * scenes for all sorts of range shenanigans.
   * @type {Range}
   * @private
   */
  this._nativeRange = opt_range || this._createNativeRange();

  /**
   * The original string.
   * @type {?string}
   * @private
   */
  this._originalString = null;
}
inherits(StandardRange, AbstractRange);

/**
 * Create a native range instance. If there is a selection, create it based on
 * the selection.
 * @return {Range} The native range instance.
 */
StandardRange.prototype._createNativeRange = function () {
  var sel = window.getSelection();
  if (!sel.rangeCount || sel.isCollapsed) {
    return document.createRange();
  }
  return sel.getRangeAt(0);
};

/** @override */
StandardRange.prototype.addToSelection = function () {
    var sel = window.getSelection();
    sel.addRange(this._nativeRange);
};

/**
 * Backup the range string in case it needs to be rebuilt.
 */
StandardRange.prototype.backup = function () {
  this._originalString = this.toHtmlString();
};

/**
 * Clear the native selection.
 */
StandardRange.prototype.clearNativeSelection = function () {
  var sel = window.getSelection();
  sel.empty && sel.empty();
  sel.removeAllRanges && sel.removeAllRanges();
};

/**
 * Delete the contents of the range.
 */
StandardRange.prototype.deleteContents = function () {
  this._nativeRange.deleteContents();
};

/**
 * Returns a text rectangle object that encloses a group of text rectangles.
 * @return {Object}
 */
StandardRange.prototype.getBoundingClientRect = function () {
  return this._nativeRange.getBoundingClientRect();
};

/**
 * Get the end node for this range.
 * @return {Node} The end node of this range.
 */
StandardRange.prototype.getEndNode = function () {
  return this._nativeRange.endContainer;
};

/**
 * Get the end offset for this range. That is, the offset within end node.
 * @return {number} The offset position within the end node.
 */
StandardRange.prototype.getEndOffset = function () {
  return this._nativeRange.endOffset;
};

/**
 * Get the original html string of the range.
 * @type {string}
 */
StandardRange.prototype.getOriginalString = function () {
  return this._originalString;
};

/**
 * Get the parent element of the range.
 * @return {Element} The parent element.
 */
StandardRange.prototype.getParentNode = function () {
  var parentEl = this._nativeRange.commonAncestorContainer;
  if (parentEl.nodeType !== 1) {
    parentEl = parentEl.parentNode;
  }
  return parentEl;
};

/**
 * Get the start node for this range.
 * @return {Node} The start node of this range.
 */
StandardRange.prototype.getStartNode = function () {
  return this._nativeRange.startContainer;
};

/**
 * Get the start offset for this range. That is, the offset within start node.
 * @return {number} The offset position within the start node.
 */
StandardRange.prototype.getStartOffset = function () {
  return this._nativeRange.startOffset;
};

/**
 * Insert the provided element into the range.
 * @param {Element} element The element to insert into the range.
 */
StandardRange.prototype.insertNode = function(element) {
  this._nativeRange.insertNode(element);
};

/**
 * Select the contents of the provided node.
 * @param {Node} node The node to select contents of.
 */
StandardRange.prototype.selectNodeContents = function (node) {
  this._nativeRange.selectNodeContents(node);
};

/**
 * Set the end position of this range.
 * @param {Node} node The node to end the range in.
 * @param {number} index The character index in the node to end the range.
 */
StandardRange.prototype.setEnd = function (node, index) {
  this._nativeRange.setEnd(node, index);
};

/**
 * Set the start of the range.
 * @param {Node} node The node in which to start the range.
 * @param {number} index The position in the node to start the range.
 */
StandardRange.prototype.setStart = function (node, index) {
  this._nativeRange.setStart(node, index);
};

/**
 * Get the html string contents of the range.
 * @return {string} The html string contents of the range.
 */
StandardRange.prototype.toHtmlString = function () {
  var div = document.createElement('div');
  div.appendChild(this._nativeRange.cloneContents());
  return div.innerHTML;
};

/**
 * Get the string contents of the range.
 * @return {string} The string contents of the range.
 */
StandardRange.prototype.toString = function () {
  return this._nativeRange.toString();
};

module.exports = StandardRange;

});

define('xrange/ierange',['require','exports','module','xrange/abstractrange','inherits'],function (require, exports, module) {/**
 * @fileOverview Range class that will be used as a wrapper for native browser
 * ranges and provides the same interface as the w3c Range class.
 */

var AbstractRange = require('xrange/abstractrange');
var inherits = require('inherits');

/**
 * Custom range class. This provides a similar interface to the w3c Range, but
 * it provides that functionality to older versions of IE.
 * @constructor
 * @extends {AbstractRange}
 * @param {TextRange=} opt_range Optionally pass a range when
 *   constructing the new Range. It defaults to creating a new range.
 */
function IERange(opt_range) {
  /**
   * The native browser range object. This will be used heavily behind the
   * scenes for all sorts of range shenanigans.
   * @type {TextRange}
   * @private
   */
  this._nativeRange = opt_range || this._createNativeRange();

  /**
   * The original string.
   * @type {?string}
   * @private
   */
  this._originalString = null;

  this._endNode = null;

  this._endOffset = 0;

  this._startNode = null;

  this._startOffset = 0;
}
inherits(IERange, AbstractRange);

/**
 * Create a native range instance. If there is a selection, create it based on
 * the selection.
 * @return {TextRange} The native range instance.
 */
IERange.prototype._createNativeRange = function () {
  return document.selection.createRange();
};

/** @override */
IERange.prototype.addToSelection = function () {

};

/**
 * Backup the range string in case it needs to be rebuilt.
 */
IERange.prototype.backup = function () {
  this._originalString = this.toHtmlString();
};

/**
 * Clear the native selection.
 */
IERange.prototype.clearNativeSelection = function () {

};

/**
 * Delete the contents of the range.
 */
IERange.prototype.deleteContents = function () {

};

/**
 * Returns a text rectangle object that encloses a group of text rectangles.
 * @return {Object}
 */
IERange.prototype.getBoundingClientRect = function () {
  // TODO: Does a TextRange support this?
};

/**
 * Get the end node for this range.
 * @return {Node} The end node of this range.
 */
IERange.prototype.getEndNode = function () {
  return this._endNode;
};

/**
 * Get the end offset for this range. That is, the offset within end node.
 * @return {number} The offset position within the end node.
 */
IERange.prototype.getEndOffset = function () {
  return this._endOffset;
};

/**
 * Get the original html string of the range.
 * @type {string}
 */
IERange.prototype.getOriginalString = function () {
  return this._originalString;
};

/**
 * Get the parent element of the range.
 * @return {Element} The parent element.
 */
IERange.prototype.getParentNode = function () {
  return this._nativeRange.parentElement();
};

/**
 * Get the start node for this range.
 * @return {Node} The start node of this range.
 */
IERange.prototype.getStartNode = function () {
  return this._startNode;
};

/**
 * Get the start offset for this range. That is, the offset within start node.
 * @return {number} The offset position within the start node.
 */
IERange.prototype.getStartOffset = function () {
  return this._startOffset;
};

/**
 * Insert the provided element into the range.
 * @param {Element} element The element to insert into the range.
 */
IERange.prototype.insertNode = function(element) {

};

/**
 * Select the contents of the provided node.
 * @param {Node} node The node to select contents of.
 */
IERange.prototype.selectNodeContents = function (node) {

};

/**
 * Set the end position of this range.
 * @param {Node} node The node to end the range in.
 * @param {number} index The character index in the node to end the range.
 */
IERange.prototype.setEnd = function (node, index) {
  this._endNode = node;
  this._endOffset = index;
};

/**
 * Set the start of the range.
 * @param {Node} node The node in which to start the range.
 * @param {number} index The position in the node to start the range.
 */
IERange.prototype.setStart = function (node, index) {
  this._startNode = node;
  this._startOffset = index;
};

/**
 * Get the html string contents of the range.
 * @return {string} The html string contents of the range.
 */
IERange.prototype.toHtmlString = function () {
  return '';
};

/**
 * Get the string contents of the range.
 * @return {string} The string contents of the range.
 */
IERange.prototype.toString = function () {
  return '';
};

module.exports = IERange;

});

define('xrange/xrange',['require','exports','module','jquery','xrange/util/dom','xrange/standardrange','xrange/ierange'],function (require, exports, module) {/**
 * @fileOverview Returns whichever range object should be used. This is
 * determined by what the browser supports.
 */

var $ = require('jquery');
var domUtil = require('xrange/util/dom');

/**
 * Range object.
 * @type {StandardRange|IERange}
 */
var XRange = !!window.getSelection ?
  require('xrange/standardrange') :
  require('xrange/ierange');

/**
 * Get the range from a string representation of the range within the provided
 * element. Returns null if no range could not be found or the range itself.
 * @param {string} htmlStr The string to find the range of.
 * @param {Element} rootEl The DOM element to find the range in.
 * @param {XRange=} opt_range Optional range to update.
 * @return {?XRange} Null or the range.
 */
XRange.getRangeByString = function (str, rootEl, opt_range) {
  var rangeDom = $('<div />').html(str)[0];
  var firstRangeNode = domUtil.findNodeInElement(rangeDom);
  var lastRangeNode = domUtil.findNodeInElement(rangeDom, true);
  // Ensure that we were able to find the first and last nodes within the root
  // element.
  if (!firstRangeNode || !lastRangeNode) {
    return;
  }
  firstRangeNode = firstRangeNode.nodeValue;
  lastRangeNode = lastRangeNode.nodeValue;

  var range = opt_range || new XRange();
  var startNodes = [];

  /**
   * Checks a node and index with the startNodes array to see if the range
   * matches the string that was provided in the parent function. Iterates over
   * each start range node/idx array and tries to find a matching range.
   * @param {Node} node The node to check as the end node in the range.
   * @param {number} idx The index within the node where the range ends.
   * @return {boolean} Whether the range matches the string or not.
   */
  function checkRange(node, idx) {
    var start;
    range.setEnd(node, idx);
    for (var i=0; i < startNodes.length; i++) {
      start = startNodes[i];
      range.setStart(start[0], start[1]);
      // Check that the html string of the range is equal to the string that
      // we're trying to get the range for.
      if (range.toHtmlString() === str) {
        return true;
      }
    }
    return false;
  }

  // Loop through all child nodes in the root element to find nodes that match
  // the start and end nodes of the string.
  var success = domUtil.forEachNode(rootEl, function (node) {
    var startIdx = node.nodeValue.indexOf(firstRangeNode);
    if (startIdx > -1) {
      startNodes.push([node, startIdx]);
    }
    var endIdx = node.nodeValue.indexOf(lastRangeNode);
    if (endIdx > -1 && checkRange(node, endIdx + lastRangeNode.length)) {
      return true;
    }
  });
  return success ? range : null;
};

module.exports = XRange;

});

define('xrange/highlighter',['require','exports','module','xrange/util/dom','xrange/xrange'],function (require, exports, module) {/**
 * @fileOverview Highlighter class. This will highlight or unhighlight an XRange
 * instance with html.
 */

var domUtil = require('xrange/util/dom');
var XRange = require('xrange/xrange');

/**
 * Highlighter class.
 * @constructor
 * @param {Object} opts Config options.
 */
function Highlighter(opts) {
  /**
   * The class name that should be on the highlighted element.
   * @type {string}
   * @private
   */
  this._className = opts.className;
}

/**
 * Highlight the contents of a node. If the start or end indexes are provided,
 * use them when highlighting. Otherwise, highlight the whole node.
 * @param {Node} node The node to highlight.
 * @param {number=} opt_startIdx Optional start index for the highlight.
 * @param {number=} opt_endIdx Optional end index for the highlight.
 * @private
 */
Highlighter.prototype._highlightNode = function (node, opt_startIdx, opt_endIdx) {
  var content = node.nodeValue;
  var startIdx = opt_startIdx || 0;
  var endIdx = opt_endIdx || content.length;
  var frag = document.createDocumentFragment();
  // If the start node is greater than 0, add a new text node for the beginning
  // of the content.
  if (startIdx > 0) {
    frag.appendChild(document.createTextNode(content.substring(0, startIdx)));
  }
  // Wrap the content in a span with a class name.
  var wrap = document.createElement('span');
  wrap.className = this._className;
  wrap.innerHTML = content.substring(startIdx, endIdx);
  frag.appendChild(wrap);
  // If the end index is less than the length of the contents, add a new text
  // node for the remainder of the content.
  if (endIdx < content.length) {
    frag.appendChild(document.createTextNode(content.substring(endIdx)));
  }
  node.parentNode.replaceChild(frag, node);
  return wrap;
};

/**
 * Highlight the contents of a range. This will loop over all children of the
 * range and wrap them in elements.
 * @param {XRange} xRange The XRange object to wrap.
 */
Highlighter.prototype.highlight = function (xRange) {
  xRange.backup();
  var endNode = xRange.getEndNode();
  var endOffset = xRange.getEndOffset();
  var startNode = xRange.getStartNode();
  var startOffset = xRange.getStartOffset();

  // If start and end are same nodes, do it quickly...
  if (startNode === endNode) {
    this._highlightNode(startNode, startOffset, endOffset);
    return;
  }

  var commonAncestor = xRange.getParentNode();
  var hasReachedEnd = false;
  var self = this;

  /**
   * Highlight all of the text nodes within siblings of the currentNode arg
   * until the end node is reached. If the end node has not been reached by the
   * time all siblings have been visited, go up a level and look at the siblings
   * there.
   * @param {Element|Node} currentNode The node to look through it's siblings.
   */
  function highlightSiblings(currentNode) {
    // Loop through all of the siblings and highlight all nodes up to and
    // including the end node.
    domUtil.forEachSibling(currentNode, function (node) {
      if (node === endNode) {
        node = self._highlightNode(node, 0, endOffset);
        hasReachedEnd = true;
        return true;
      }
      node = self._highlightNode(node);
    });

    // If the end node has not been reached yet but all siblings have been
    // visited, go up a level and check the siblings there.
    if (!hasReachedEnd && currentNode.parentNode !== commonAncestor) {
      highlightSiblings(currentNode.parentNode);
    }
  }

  // Highlight the start node
  var currentNode = this._highlightNode(startNode, startOffset);
  // Start the potentially recursive process of highlighting siblings
  highlightSiblings(currentNode);
  // Need to clear the range after everything is highlighted so that it doesn't
  // look weird.
  xRange.clearNativeSelection();
};

/**
 * Unhighlight the contents of a range. This removes the elements that were
 * added in the highlight function.
 * @param {XRange} xRange The XRange object to unwrap.
 */
Highlighter.prototype.unhighlight = function (xRange) {
  var parent;
  var rootEl = xRange.getParentNode();
  var self = this;
  // Loop over all of the highlighted elements and replace them with their
  // text node children.
  domUtil.forEachNode(rootEl, function (node) {
    parent = node.parentNode;
    if (parent.className.indexOf(self._className) > -1) {
      parent.parentNode.replaceChild(node, parent);
    }
  });
  // Once the highlight elements have been removed, the text nodes will be all
  // broken, so they need to be cleaned up.
  domUtil.normalize(rootEl);
  // Since there has been so much DOM destruction with the (un)highlighting,
  // the range will need to be created again. By passing it in as the 3rd
  // argument, it will be modified instead of creating a new one.
  XRange.getRangeByString(xRange.getOriginalString(), rootEl, xRange);
};

module.exports = Highlighter;

});

define("hgn!templates/blocks/highlight", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<span class=\"lf-highlight-text\">");_.b(_.v(_.f("originalText",c,p,0)));_.b("</span>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/blocks/highlighter',['require','exports','module','jquery','annotations/models/block','annotations/blocks/detector','annotations/util/internals','event-emitter','inherits','annotations/events','annotations/util/useragent','xrange/highlighter','xrange/xrange','hgn!templates/blocks/highlight'],function (require, exports, module) {/**
 * @fileoverview Highlighter contains the selected text .
 *
 */

var $ = require('jquery');
var Block = require('annotations/models/block');
var BlockDetector = require('annotations/blocks/detector');
var debounce = require('annotations/util/internals').debounce;
var EventEmitter = require('event-emitter');
var inherits = require('inherits');
var SourceEvents = require('annotations/events').source;
var UserAgentUtil = require('annotations/util/useragent');
var XHighlighter = require('xrange/highlighter');
var XRange = require('xrange/xrange');

/**
 * @constructor
 * @extends {EventEmitter}
 * @param {Array.jQuery} sourceElements
 */
function Highlighter(sourceElements, $antenna) {
    /**
     * The source elements that are used as blocks.
     * @type {Array.jQuery}
     * @private
     */
    this._sourceElements = sourceElements;

    /**
     * Element that events will be bubbled to so that they can be handled.
     * @type {jQuery}
     */
    this.$antenna = $antenna;

    // Set up the events.
    this.delegateEvents();

    /**
     * Highlighter that highlights ranges.
     * @type {XHighlighter}
     * @private
     */
    this._highlighter = new XHighlighter({
        className: Highlighter.CLASSES.HIGHLIGHTED_TEXT
    });

    EventEmitter.call(this);
}
inherits(Highlighter, EventEmitter);

/** @type {string} */
Highlighter.mouseEvents = 'keyup.Highlighter mouseup.Highlighter';

/**
 * @type {string}
 */
Highlighter.touchEvents = 'tapend.Highlighter';

/** @type {?string} */
Highlighter.prototype.events = null;

/**
 * The template that may be used for this view.
 * @type {function()}
 */
Highlighter.prototype.template = require('hgn!templates/blocks/highlight');

/** @enum {string} */
Highlighter.CLASSES = {
    HIGHLIGHTED_TEXT: 'lf-highlight-text',
    MOBILE_THREAD_BUTTON: 'lf-mobile-thread-btn',
    THREAD_BUTTON: 'lf-thread-btn'
};

/**
 * Handles keyup event, and if any text is selected, triggers an event.
 */
Highlighter.prototype._handleTextHighlighted = function () {
    var range = new XRange();
    var CLASSES = Highlighter.CLASSES;
    var selectionInfo = {
        range: range,
        text: range.toHtmlString()
    };

    // It's possible to select the block element as the end node. If this
    // happens, we want to update the end node to be the 2nd to last element
    // since the last element is the thread button.
    var endNode = range.getEndNode();
    // If the range contains the thread button, we don't want to continue.
    if (selectionInfo.text.indexOf(CLASSES.THREAD_BUTTON) > -1 ||
        selectionInfo.text.indexOf(CLASSES.MOBILE_THREAD_BUTTON) > -1 ||
        $(endNode).hasClass(BlockDetector.CLASSES.BLOCK)) {
        return;
    }
    // Find the closest text block. This looks through all ancestors of the
    // range's parent until it finds one. It's possible a text node isn't
    // immediately wrapped by the text block.
    var parentElement = range.getParentNode();
    if (!parentElement) {
        return;
    }
    var $blockEl = $(parentElement).closest('.' + BlockDetector.CLASSES.TEXT);
    selectionInfo.blockId = $blockEl.attr(Block.DATA_ID);
    this.$antenna.trigger(SourceEvents.TEXT_HIGHLIGHTED, selectionInfo);
};

/**
 * Listen for selection changes
 */
Highlighter.prototype.delegateEvents = function() {
    var isMobile = UserAgentUtil.isMobile();
    this.events = isMobile ? Highlighter.touchEvents : Highlighter.mouseEvents;
    this.undelegateEvents();
    this._sourceElements.on(this.events, $.proxy(this._handleTextHighlighted, this));
    if (isMobile) {
        $(document).on('selectionchange.Highlighter',
            debounce(this._handleTextHighlighted, 400, true));
    }
};

/**
 * Cleanup the highlighter
 */
Highlighter.prototype.destroy = function() {
    this.undelegateEvents();
    this._sourceElements = null;
    this._highlighter = null;
};

/**
 * Freeze the selection with our background color
 * @param {Range} range
 * @param {string} text
 */
Highlighter.prototype.freezeHighlight = function(range, text) {
    this._highlighter.highlight(range);
};

/**
 * Unlisten
 */
Highlighter.prototype.undelegateEvents = function() {
    this._sourceElements.off(this.events);
    $(document).off('selectionchange.Highlighter');
};

/**
 * Remove our background color for the selection
 * @param {Range} range
 * @param {string} text
 */
Highlighter.prototype.unfreezeHighlight = function(range, text) {
    this._highlighter.unhighlight(range);
};

module.exports = Highlighter;

});

define("hgn!templates/blocks/questionpopover", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-title-text\">");_.b(_.v(_.d("strings.title",c,p,0)));_.b("</div>");_.b("\n" + i);_.b("<br>");_.b("\n" + i);_.b("<div class=\"lf-mock-text\">");_.b("\n" + i);_.b("    <span class=\"lf-gradient-right\"></span>");_.b("\n" + i);_.b("    ");_.b(_.v(_.d("strings.mockText",c,p,0)));_.b("\n" + i);_.b("    <span>");_.b("\n" + i);_.b("        <a class=\"lf-thread-btn fycon-action-view lf-has-num lf-active\">5</a>");_.b("\n" + i);_.b("    </span>");_.b("\n" + i);_.b("    <span class=\"lf-gradient-left\"></span>");_.b("\n" + i);_.b("</div>");_.b("\n" + i);_.b("<br>");_.b("\n" + i);_.b("<div class=\"lf-explanation-text\">");_.b(_.t(_.d("strings.explanation",c,p,0)));_.b("</div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/util/dom',['require','exports','module','annotations/util/useragent'],function (require, exports, module) {/**
 * @fileoverview Dom helpers that are generally unsupported or too specific for jQuery
 */

var UserAgentUtil = require('annotations/util/useragent');

/** @type {Object} */
var dom = {};

/**
 * Returns a text rectangle object that encloses a group of text rectangles.
 * @return {Object}
 */
dom.getBoundingClientRect = function (elem) {
    var rect = elem.getBoundingClientRect();
    // Sometimes IE has a problem getting this value for the first time. When
    // this happens, all of the data attributes are 0. It always seems to work
    // the second time, even if it's immediately after.
    if (!rect.height && !rect.top) {
        rect = elem.getBoundingClientRect();
    }
    // Rect object doesn't contain height or width, so we get to generate it!
    if (UserAgentUtil.isIE() && UserAgentUtil.getIEVersion() < 9) {
        rect = {top: rect.top, right: rect.right, bottom: rect.bottom, left: rect.left};
        rect.height = rect.bottom - rect.top;
        rect.width = rect.right - rect.left;
    }
    return rect;
};

/**
 * Get the scroll x position within the window. This needs it's own function
 * for browser compatibility.
 * @return {number}
 */
dom.getScrollX = function () {
    if (window.pageXOffset !== undefined) {
        return window.pageXOffset;
    }
    return (document.documentElement || document.body.parentNode || document.body).scrollLeft;
};

/**
 * Get the scroll y position within the window. This needs it's own function
 * for browser compatibility.
 * @return {number}
 */
dom.getScrollY = function () {
    if (window.pageYOffset !== undefined) {
        return window.pageYOffset;
    }
    return (document.documentElement || document.body.parentNode || document.body).scrollTop;
};

module.exports = dom;

});

define('view/view',['require','exports','module','jquery','view/delegate','event-emitter','view/event-map','inherits'],function (require, exports, module) {var $ = require('jquery');
var delegate = require('view/delegate');
var EventEmitter = require('event-emitter');
var EventMap = require('view/event-map');
var inherits = require('inherits');



/**
 * A View is an Object that facades an HTMLElement, and provides helpful methods
 * for automatically creating appropriate Elements on construction, rendering
 * templates as their innerHTML, and delegating and undelegating event listeners
 * @param opts {Object} A set of options to config the view with
 * @param opts.el {HTMLElement} The element the View should control
 * @exports view/view
 * @constructor
 */
var View = function(opts) {
    EventEmitter.call(this);
    opts = opts || {};
    this.opts = opts;
    this.uid = delegate.getUniqueId();

    this.setElement(opts.el || document.createElement(this.elTag));
};
inherits(View, EventEmitter);

var delegateEventSplitter = /^(\S+)\s*(.*)$/;

/**
 * Find elements within the View's .el by jQuery selector
 * @param {string} selector
 * @return {jQuery}
 */
View.prototype.$ = function(selector) {
    return this.$el.find(selector);
};

/**
 * Find elements by class name
 * @param {string} className
 * @return {jQuery}
 */
View.prototype.getElementsByClass = function(className) {
    return this.$el.find('.' + className);
};

/**
 * The HTMLElement tag to use if this View creates its own element
 * @type {string}
 */
View.prototype.elTag = 'div';

/**
 * Class to be added to the view's element.
 * @type {string}
 */
View.prototype.elClass = '';

/**
 * Event bindings.
 * @type {EventMap}
 */
View.prototype.events = new EventMap();

/**
 * Get contextual data for a template.
 * @type {function()}
 */
View.prototype.getTemplateContext = function () {
    return this;
};

/**
 * The template that may be used for this view.
 * @type {?function()}
 */
View.prototype.template = null;

/**
 * Set the element for the view to render in.
 * You will probably want to call .render() after this, but not always.
 * @param element {HTMLElement} The element to render this View in
 * @return this
 */
View.prototype.setElement = function (element) {
    if (this.el) {
        this.$el.removeClass(this.elClass);
        this.undelegateEvents();
    }

    this.$el = element instanceof $ ? element : $(element);
    this.el = this.$el[0];

    if (this.elClass) {
        this.$el.addClass(this.elClass);
    }

    this.delegateEvents();

    return this;
};

/**
 * Attatch the declared events
 * @param events {Object.<string, (string|function)>} Mapping of event/selectors to a function
 * or the name of a method on this view.
 * Backbone.View style, e.g. { "click testSelector": "updateTestEl" }
 */
View.prototype.delegateEvents = function (events) {
    if (!(events || (events = this.events))) {
        return this;
    }
    delegate.delegateEvents(this.$el, events, this.uid, this);
    return this;
};

/**
 * Unbinds the events registered with .delegateEvents
 */
View.prototype.undelegateEvents = function() {
    delegate.undelegateEvents(this.$el, this.uid);
    return this;
};

/**
 * If a template is set, render it in this.el
 * Subclasses will want to setElement on child views after rendering,
 *     then call .render() on those subelements
 */
View.prototype.render = function () {
    var context;
    if (typeof this.template === 'function') {
        context = this.getTemplateContext();
        this.$el.html(this.template(context));
    }
};

/**
 * The inverse of render. Detaches the element from the DOM.
 * Retains data and event handlers
 */
View.prototype.detach = function () {
    this.$el.detach();
};

/**
 * Destroy this View, rendering it useless.
 * Remove .el from the DOM, and unbind all event listeners in .events
 * Subclasses should free up as much memory as possible here.
 */
View.prototype.destroy = function () {
    this.$el.remove();
    this.template = null;
    this.undelegateEvents();
};

module.exports = View;

});

define('view', ['view/view'], function (main) { return main; });

define("hgn!templates/thread/lfwrapper", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf\"></div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/container", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-thread-content\"></div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/ui/container',['require','exports','module','jquery','inherits','annotations/util/internals','annotations/util/useragent','view','hgn!templates/thread/lfwrapper','hgn!templates/container'],function (require, exports, module) {/**
 * @fileOverview Container base class which provides the basic functionality for
 * popovers (e.g. showing, hiding, etc)
 */

var $ = require('jquery');
var inherits = require('inherits');
var nullFunction = require('annotations/util/internals').nullFunction;
var UserAgentUtil = require('annotations/util/useragent');
var View = require('view');
var lfWrapperTemplate = require('hgn!templates/thread/lfwrapper');

/** @enum {string} */
var VIS_EVENT = {
    HIDE: 'hide',
    SHOW: 'show'
};

/** @enum {string} */
var VIS_STATE = {
    HIDDEN: 'hidden',
    HIDING: 'hiding',
    SHOWING: 'showing',
    VISIBLE: 'visible'
};

/**
 * Container base class.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
function Container(opts) {
    View.call(this, opts);

    /**
     * The active vis change state.
     * @type {VIS_STATE}
     * @private
     */
    this._activeVisState = VIS_STATE.HIDDEN;

    /**
     * Queued callback functions.
     * @type {Object.<string, Array.<function()>>}
     * @private
     */
    this._queuedEvents = {};
    this._queuedEvents[VIS_EVENT.HIDE] = [];
    this._queuedEvents[VIS_EVENT.SHOW] = [];

    /**
     * Animation time for the popover to hide.
     * @type {number}
     * @private
     */
    this._hideTimeMS = 0;

    /**
     * Animation time for the popover to show.
     * @type {number}
     * @private
     */
    this._showTimeMS = 0;

    this.render();
    var appendee = this.el.parentNode || this.el;
    (this.opts.parentEl || document.body).appendChild(appendee);
}
inherits(Container, View);

/** @enum {string} */
Container.CLASSES = {
    ACTIVE: 'lf-active',
    BASE: 'lf-thread',
    CONTENT: 'lf-thread-content',
    REMOVE: 'lf-remove'
};

/** @override */
Container.prototype.elClass = Container.CLASSES.BASE;

/** @override */
Container.prototype.events = (function () {
    var events = {};
    if (!UserAgentUtil.isMobile()) {
        events['mousedown'] = '_handlePress';
    }
    return events;
})();

/** @override */
Container.prototype.render = function() {
    View.prototype.render.call(this);
    this.$el.wrap(lfWrapperTemplate());
};

/** @override */
Container.prototype.template = require('hgn!templates/container');

/**
 * Handle the mousedown event. Don't want it to bubble all the way to the body
 * because it'll kill itself.
 * @param {jQuery.Event} ev
 * @private
 */
Container.prototype._handlePress = function (ev) {
    ev.stopPropagation();
};

/**
 * Process the set of queued callbacks for a specific type.
 * @param {VIS_EVENT} type The visibility type to process.
 * @private
 */
Container.prototype._processQueuedCallbacks = function (type) {
    var callback;
    while (this._queuedEvents[type].length) {
        callback = this._queuedEvents[type].pop();
        callback();
    }
};

/**
 * Hide the popover.
 * @param {function()=} opt_callback
 */
Container.prototype.hide = function (opt_callback) {
    if (this._activeVisState === VIS_STATE.HIDING) {
        opt_callback && this.onHide(opt_callback);
        return;
    }

    this.$el.addClass(Container.CLASSES.REMOVE);
    setTimeout($.proxy(this.hideInternal, this, opt_callback), this._hideTimeMS);
};

/**
 * Additional functionality to be fired when the popover has completed the hide
 * animation (via CSS).
 * @param {function()=} opt_callback
 */
Container.prototype.hideInternal = function (opt_callback) {
    this.$el.hide().attr('class', this.elClass);
    this._activeVisState = VIS_STATE.HIDDEN;
    (typeof opt_callback === 'function') && opt_callback();
    this._processQueuedCallbacks(VIS_EVENT.HIDE);
};

/**
 * Is the popover in the process of showing?
 * @return {boolean}
 */
Container.prototype.isShowing = function () {
    return this._activeVisState === VIS_STATE.SHOWING;
};

/**
 * Is the popover visible?
 * @return {boolean}
 */
Container.prototype.isVisible = function () {
    return this._activeVisState === VIS_STATE.VISIBLE;
};

/**
 * Add a callback that fires when the popover becomes hidden. If the current
 * state of the popover is hidden, it immediately calls the callback.
 * @param {function()} callback The callback to call when hidden.
 */
Container.prototype.onHide = function (callback) {
    if (this._activeVisState === VIS_STATE.HIDDEN) {
        return callback();
    }
    this._queuedEvents[VIS_EVENT.HIDE].push(callback);
};

/**
 * Add a callback that fires when the popover becomes visible. If the current
 * state of the popover is visible, it immediately calls the callback.
 * @param {function()} callback The callback to call when hidden.
 */
Container.prototype.onShow = function (callback) {
    if (this._activeVisState === VIS_STATE.VISIBLE) {
        return callback();
    }
    this._queuedEvents[VIS_EVENT.SHOW].push(callback);
};

/**
 * Resize and reposition the popover element.
 * @param {Element} elem The element to position the popover next to.
 */
Container.prototype.resizeAndReposition = nullFunction;

/**
 * @param {Element} el The root element of the content
 */
Container.prototype.setContentNode = function (el) {
    var content = this.$('.' + Container.CLASSES.CONTENT);
    content.empty();
    content.append(el);
};

/**
 * Show the popover.
 * @param {Element} el The element to show next to.
 * @param {function()=} opt_callback
 */
Container.prototype.show = function (el, opt_callback) {
    if (this._activeVisState === VIS_STATE.SHOWING) {
        return;
    }

    this._activeVisState = VIS_STATE.SHOWING;
    this.resizeAndReposition(el);
    this.$el.show();
    this.$el.addClass(Container.CLASSES.ACTIVE);

    setTimeout($.proxy(function() {
        this._activeVisState = VIS_STATE.VISIBLE;
        opt_callback && opt_callback();
        this._processQueuedCallbacks(VIS_EVENT.SHOW);
    }, this), this._showTimeMS);
};

module.exports = Container;

});

define("hgn!templates/popover", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-thread-content lf-popover-content\"></div>");_.b("\n" + i);_.b("<div class=\"lf-popover-arrow\"></div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/ui/popover',['require','exports','module','jquery','annotations/ui/container','annotations/util/dom','inherits','hgn!templates/popover'],function (require, exports, module) {/**
 * @fileOverview Popover base class which provides the basic functionality for
 * popovers (e.g. showing, hiding, etc)
 */

var $ = require('jquery');
var Container = require('annotations/ui/container');
var domUtil = require('annotations/util/dom');
var inherits = require('inherits');

/**
 * Popover base class.
 * @constructor
 * @extends {Container}
 * @param {Object} opts Config options.
 */
function Popover(opts) {
    Container.call(this, opts);

    /**
     * The active position of the popover. This is set when the popover is
     * positioned. This only differs from this._position when it's set to auto.
     * @type {?string}
     * @private
     */
    this._activePosition = null;

    /** @override */
    this._hideTimeMS = 300;

    /** @override */
    this._showTimeMS = 300;
}
inherits(Popover, Container);

/** @enum {string} */
Popover.CLASSES = {
    BASE: 'lf-popover',
    CONTENT: 'lf-popover-content',
    POSITION_PREFIX: 'lf-pos-',
    LF: 'lf'
};

/** @enum {string} */
Popover.POSITIONS = {
    SMART: 'smart',
    BOTTOM: 'bottom',
    LEFT: 'left',
    RIGHT: 'right'
};

/** @enum {function()} */
Popover.POSITION_FN_MAP = {
    'bottom': '_getBottomPosition',
    'left': '_getLeftPosition',
    'right': '_getRightPosition',
    'smart': '_getSmartPosition'
};

/** @override */
Popover.prototype.elClass = Popover.CLASSES.BASE;

/** @override */
Popover.prototype.template = require('hgn!templates/popover');

/**
 * Get the bottom position of the element where this popover should be positioned.
 * @param {Element} elem The element to position next to.
 * @return {Object} Top and left positioning for the popover.
 * @private
 */
Popover.prototype._getBottomPosition = function (elem) {
    this._activePosition = Popover.POSITIONS.BOTTOM;
    var boundingRect = domUtil.getBoundingClientRect(elem);
    var top = boundingRect.bottom + domUtil.getScrollY() + 10;
    var availableWidth = boundingRect.right - boundingRect.left;
    var width = availableWidth < this.opts.maxWidth ? availableWidth : this.opts.maxWidth;
    var left = (availableWidth - width) / 2;
    left += boundingRect.left + domUtil.getScrollX();
    return {top: top, left: left, width: width};
};

/**
 * Get the left position of the element where this popover should be positioned.
 * @param {Element} elem The element to position next to.
 * @return {Object} Top and left positioning for the popover.
 * @private
 */
Popover.prototype._getLeftPosition = function (elem) {
    this._activePosition = Popover.POSITIONS.LEFT;
    var boundingRect = domUtil.getBoundingClientRect(elem);
    var top = boundingRect.top + domUtil.getScrollY();
    var right = $('body').width() - boundingRect.left + this.opts.leftPadding;
    var width = boundingRect.left - this.opts.leftPadding;
    return {top: top, right: right, width: width};
};

/**
 * Get the width of the popover.
 * @param {number} width The width of the area where the popover will be.
 * @return {number} The width the popover should be.
 * @private
 */
Popover.prototype._getPopoverWidth = function (width) {
    if (width < this.opts.minWidth) return this.opts.minWidth;
    if (width > this.opts.maxWidth) return this.opts.maxWidth;
    width -= this.opts.sidePadding * (this._activePosition === Popover.POSITIONS.BOTTOM ? 2 : 1);
    return width;
};

/**
 * Get the right position of the element where this popover should be positioned.
 * @param {Element} elem The element to position next to.
 * @return {Object} Top and left positioning for the popover.
 * @private
 */
Popover.prototype._getRightPosition = function (elem) {
    this._activePosition = Popover.POSITIONS.RIGHT;
    var boundingRect = domUtil.getBoundingClientRect(elem);
    var top = boundingRect.top + domUtil.getScrollY();
    var left = boundingRect.right + domUtil.getScrollX() + 10;
    var width = document.body.clientWidth - left;
    return {top: top, left: left, width: width};
};

/**
 * Automatically pick the best position for the popover.
 * @param {Element} elem The element to position next to.
 * @return {Object} Top and left positioning for the popover.
 * @private
 */
Popover.prototype._getSmartPosition = function (elem) {
    var position = this._getRightPosition(elem);
    if (position.width < this.opts.minWidth) {
        return this._getBottomPosition(elem);
    }
    return position;
};

/**
 * Scroll the popover into position. The works on the top and bottom. If it's on
 * the top, it scrolls down so that the top of the popover is 20 pixels below
 * the top fold. If it's on the bottom, it scrolls up so that 200 pixels of the
 * popover are visible. Don't scroll in addition to another scroll, however,
 * which could be the case when there is a permalink being scrolled to.
 * @param {number} top The top position of the popover.
 */
Popover.prototype._scrollIntoPosition = function (top) {
    var scrollElem = $('body,html');
    if (scrollElem.is(':animated')) {
        return;
    }

    var scrollY = domUtil.getScrollY();
    var bottomViewport = scrollY + $(window).height();
    var isAboveBottomFold = top + this.opts.minPopoverInView <= bottomViewport;
    var isBelowTopFold = top > scrollY + this.opts.topSpacing;

    // If it's satisfactorily in view, don't shift the top position.
    if (isAboveBottomFold && isBelowTopFold) {
        return;
    }

    var scrollTop;
    if (!isAboveBottomFold) {
        scrollTop = scrollY + (this.opts.minPopoverInView + top - bottomViewport);
    } else if (!isBelowTopFold) {
        scrollTop = top - this.opts.topSpacing;
    }
    scrollElem.animate({scrollTop: scrollTop}, this.opts.scrollDuration);
};

/** @override */
Popover.prototype.render = function () {
    Container.prototype.render.call(this);
    this.$_contentNode = this.$('.' + Popover.CLASSES.CONTENT);
};

/** @override */
Popover.prototype.resizeAndReposition = function (elem) {
    var position = this[Popover.POSITION_FN_MAP[this._position]].call(this, elem);
    var POSITION_PREFIX = Popover.CLASSES.POSITION_PREFIX;
    position.width = this._getPopoverWidth(position.width);
    this.$el.css(position).removeClass(function () {
        var classes = [];
        for (var pos in Popover.POSITIONS) {
            if (Popover.POSITIONS.hasOwnProperty(pos)) {
                classes.push(POSITION_PREFIX + Popover.POSITIONS[pos]);
            }
        }
        return classes.join(' ');
    }).addClass(POSITION_PREFIX + this._activePosition);
    this._scrollIntoPosition(position.top);
};

/**
 * @param {Element} el The root element of the content
 */
Popover.prototype.setContentNode = function (el) {
    this.$_contentNode.empty();
    this.$_contentNode.append(el);
};

module.exports = Popover;

});

define('annotations/i18n/enumeration',['require','exports','module'],function (require, exports, module) {/**
 * @fileOverview Text enumeration object for allowing internationalization of
 * the text.
 */

var TextEnumeration = function() {
    /**
     * The text enumeration values.
     * @type {Object}
     * @private
     */
    this.values_ = {};

    // Load the default set of enumerations.
    this.set(TextEnumeration.VALUES);
};

/** @enum {string} */
TextEnumeration.prototype.KEYS = {
    APP_NAME: 'appName',
    APP_VERSION: 'appVersion',

    COMMENT_MODERATOR_TAG: 'commentModeratorTag',
    COMMENT_PENDING_TAG: 'commentPendingTag',
    COMMENT_VOTE_COUNT: 'commentVoteCount',
    COMMENT_VOTE_COUNT_SING: 'commentVoteCountSing',
    COMMENT_READ_MORE: 'commentReadMoreLink',
    COMMENT_REPLY_LINK: 'commentReplyLink',
    COMMENT_REPLY_LINK_SING: 'commentReplyLinkSing',

    DATETIME_MINUTE_ABBREVIATION: 'datetimeMinutePrefix',
    DATETIME_MONTHS: 'datetimeMonths',

    EDITOR_EDIT_BTN: 'editorEditBtn',
    EDITOR_PLACEHOLDER: 'editorPlaceholder',
    EDITOR_POST_BTN: 'editorPostBtn',
    EDITOR_POST_BTN_MOBILE: 'editorPostBtnMobile',
    EDITOR_POSTING: 'editorPosting',
    EDITOR_REPLY_BTN: 'editorReplyBtn',
    EDITOR_TITLE: 'editorTitle',
    EDITOR_REPLY_TITLE: 'editorReplyTitle',
    EDITOR_EDIT_POSTING: 'editorEditPosting',
    EDITOR_EDIT_TITLE: 'editorEditTitle',
    EDITOR_EDIT_REPLY_TITLE: 'editorEditReplyTitle',
    EMPTY_IMAGE_BLOCK_TXT: 'emptyImageBlockTxt',
    EMPTY_TEXT_BLOCK_TXT: 'emptyTextBlockTxt',

    MENU_AUTH_SIGN_IN_BTN: 'menuAuthSignInBtn',
    MENU_AUTH_SIGNED_IN_MSG: 'menuAuthSignedInMsg',

    MENU_BACK_BTN: 'menuBackBtn',

    MENU_CONFIRM_ACCEPT: 'menuConfirmAccept',
    MENU_CONFIRM_CANCEL: 'menuConfirmCancel',
    MENU_CONFIRM_TITLE: 'menuConfirmTitle',

    MENU_ETC_OPTION_APPROVE: 'menuEtcOptionApprove',
    MENU_ETC_OPTION_DELETE: 'menuEtcOptionDelete',
    MENU_ETC_OPTION_EDIT: 'menuEtcOptionEdit',
    MENU_ETC_OPTION_FLAG: 'menuEtcOptionFlag',
    MENU_ETC_OPTION_SHARE: 'menuEtcOptionShare',
    MENU_ETC_POSTED_AT: 'menuEtcPostedAt',
    MENU_ETC_TITLE: 'menuEtcTitle',

    MENU_FLAG_OPTION_DISAGREE: 'menuFlagOptionDisagree',
    MENU_FLAG_OPTION_OFFENSIVE: 'menuFlagOptionOffensive',
    MENU_FLAG_OPTION_OFF_TOPIC: 'menuFlagOptionOffTopic',
    MENU_FLAG_OPTION_SPAM: 'menuFlagOptionSpam',
    MENU_FLAG_TITLE: 'menuFlagTitle',

    MENU_INFO_COPYRIGHT: 'menuInfoCopyright',
    MENU_INFO_HELP: 'menuInfoHelp',
    MENU_INFO_LF_LINK: 'menuInfoLivefyreLink',

    MENU_REPLIES_VIEW_TITLE: 'menuRepliesViewTitle',
    MENU_REPLIES_VIEW_REPLY: 'menuRepliesViewReply',

    MENU_SHARE_OPTION_FACEBOOK: 'menuShareOptionFacebook',
    MENU_SHARE_OPTION_TWITTER: 'menuShareOptionTwitter',
    MENU_SHARE_TITLE: 'menuShareTitle',

    MENU_USER_EDIT_PROFILE: 'menuUserEditProfile',
    MENU_USER_ADMIN: 'menuUserAdmin',
    MENU_USER_LOGOUT: 'menuUserLogout',
    MENU_USER_BACK_BTN: 'menuUserBackBtn',

    QUESTION_EXPLANATION: 'questionExplanation',
    QUESTION_MOCK_TEXT: 'questionMockText',
    QUESTION_TITLE: 'questionTitle',

    QUEUED_COMMENTS_PLURAL: 'queuedCommentsPlural',
    QUEUED_COMMENTS_SINGULAR: 'queuedCommentsSingular',
    QUEUED_REPLIES_PLURAL: 'queuedRepliesPlural',
    QUEUED_REPLIES_SINGULAR: 'queuedRepliesSingular',

    REPLY_BTN: 'replyBtn',
    SIGN_IN_TO_POST: 'signInToPost',
    THREAD_COLLAPSE_BTN: 'threadCollapseBtn',
    THREAD_EXPAND_BTN_PLURAL: 'threadExpandBtnPlural',
    THREAD_EXPAND_BTN_SINGULAR: 'threadExpandBtnSingular',
    THREAD_REPLY_BTN: 'threadReplyBtn',
    PERMALINK_TITLE: 'permalinkTitle',
    PERMALINK_BACK_BTN: 'permalinkBackBtn',
    PERMALINK_MISSING: 'permalinkMissing',

    NOTIFICATION_APPROVED: 'notificationApproved',
    NOTIFICATION_DELETED: 'notificationDeleted',
    NOTIFICATION_FLAGGED: 'notificationFlagged',

    FACEBOOK_SHARE_DESCRIPTION: 'facebookShareDescription',
    FACEBOOK_SHARE_DESCRIPTION_SOURCE: 'facebookShareDescriptionSource',
    FACEBOOK_SHARE_CAPTION: 'facebookShareCaption',

    SLIDER_COMMENT_TALLY: 'sliderCommentTally',
    SLIDER_INVITE_READ: 'sliderInviteRead',
    SLIDER_INVITE_WRITE: 'sliderInviteWrite',
    SLIDER_LOADING: 'sliderLoading',
    SLIDER_WRITE_TEXT: 'sliderWriteText',

    ERROR_CONNECTION: 'errorConnection',
    ERROR_DUPLICATE: 'errorDuplicate',
    ERROR_GENERAL: 'errorGeneral',
    ERROR_SERVER: 'errorServer'
};

/** @enum {string} */
TextEnumeration.VALUES = (function() {
    var d = {};
    var K = TextEnumeration.prototype.KEYS;

    d[K.APP_NAME] = 'Sidenotes';
    d[K.APP_VERSION] = 'v1.2.1';

    d[K.COMMENT_MODERATOR_TAG] = 'Mod';
    d[K.COMMENT_PENDING_TAG] = 'Pending';
    d[K.COMMENT_READ_MORE] = 'Read More';
    d[K.COMMENT_REPLY_LINK] = 'See {number} replies';
    d[K.COMMENT_REPLY_LINK_SING] = 'See reply';
    d[K.COMMENT_VOTE_COUNT] = 'votes';
    d[K.COMMENT_VOTE_COUNT_SING] = 'vote';

    d[K.DATETIME_MINUTE_ABBREVIATION] = 'm';
    d[K.DATETIME_MONTHS] = [
        'January', 'February', 'March', 'April', 'May', 'June', 'July',
        'August', 'September', 'October', 'November', 'December'
    ];

    d[K.EDITOR_EDIT_BTN] = 'Save';
    d[K.EDITOR_PLACEHOLDER] = 'What do you think?';
    d[K.EDITOR_POST_BTN] = 'Post Sidenote';
    d[K.EDITOR_POST_BTN_MOBILE] = 'Post';
    d[K.EDITOR_POSTING] = 'Posting...';
    d[K.EDITOR_REPLY_BTN] = 'Post Reply';
    d[K.EDITOR_TITLE] = 'Write Sidenote';
    d[K.EDITOR_REPLY_TITLE] = 'Write Reply';
    d[K.EDITOR_EDIT_POSTING] = 'Saving...';
    d[K.EDITOR_EDIT_TITLE] = 'Edit Sidenote';
    d[K.EDITOR_EDIT_REPLY_TITLE] = 'Edit Reply';
    d[K.EMPTY_IMAGE_BLOCK_TXT] = 'What do you think?';
    d[K.EMPTY_TEXT_BLOCK_TXT] = '+';

    /** Auth menu strings */
    d[K.MENU_AUTH_SIGN_IN_BTN] = 'Sign in';
    d[K.MENU_AUTH_SIGNED_IN_MSG] = 'You must be signed in to {action}';

    /** Default menu strings */
    d[K.MENU_BACK_BTN] = 'Back';

    /** Delete menu options */
    d[K.MENU_CONFIRM_ACCEPT] = 'Yes, {action}';
    d[K.MENU_CONFIRM_CANCEL] = 'Cancel';
    d[K.MENU_CONFIRM_TITLE] = 'Are you sure?';

    /** Etc menu options */
    d[K.MENU_ETC_OPTION_APPROVE] = 'Approve';
    d[K.MENU_ETC_OPTION_DELETE] = 'Delete';
    d[K.MENU_ETC_OPTION_EDIT] = 'Edit';
    d[K.MENU_ETC_OPTION_FLAG] = 'Flag';
    d[K.MENU_ETC_OPTION_SHARE] = 'Share';
    d[K.MENU_ETC_POSTED_AT] = 'Posted on {date}';
    d[K.MENU_ETC_TITLE] = 'More';

    /** Info menu options */
    d[K.MENU_INFO_COPYRIGHT] = '&copy; Livefyre, Inc. 2014';
    d[K.MENU_INFO_HELP] = 'Help';
    d[K.MENU_INFO_LF_LINK] = 'Visit Livefyre.com';

    /** Flag menu options */
    d[K.MENU_FLAG_OPTION_DISAGREE] = 'Disagree';
    d[K.MENU_FLAG_OPTION_OFFENSIVE] = 'Offensive';
    d[K.MENU_FLAG_OPTION_OFF_TOPIC] = 'Off Topic';
    d[K.MENU_FLAG_OPTION_SPAM] = 'Spam';
    d[K.MENU_FLAG_TITLE] = 'Flag as...';

    d[K.MENU_REPLIES_VIEW_TITLE] = 'Details';
    d[K.MENU_REPLIES_VIEW_REPLY] = 'Reply to Conversation';

    /** Share menu options */
    d[K.MENU_SHARE_OPTION_FACEBOOK] = 'Facebook';
    d[K.MENU_SHARE_OPTION_TWITTER] = 'Twitter';
    d[K.MENU_SHARE_TITLE] = 'Share';

    d[K.MENU_USER_EDIT_PROFILE] = 'Edit Profile';
    d[K.MENU_USER_ADMIN] = 'Admin Console';
    d[K.MENU_USER_LOGOUT] = 'Sign Out';
    d[K.MENU_USER_BACK_BTN] = 'All';

    d[K.QUEUED_COMMENTS_PLURAL] = '{number} New Sidenotes';
    d[K.QUEUED_COMMENTS_SINGULAR] = '1 New Sidenote';
    d[K.QUEUED_REPLIES_PLURAL] = '{number} New Replies';
    d[K.QUEUED_REPLIES_SINGULAR] = '1 New Reply';

    d[K.QUESTION_TITLE] = 'What is a Sidenote?';
    d[K.QUESTION_EXPLANATION] = 'You can now read and write comments directly on sentences, paragraphs, images and quotes.<br><br><span class="lf-highlight-text">Highlight text</span> and click the <span class="fycon-write"></span> icon or click the <span class="fycon-action-view"></span> icon at the end of each paragraph.';
    d[K.QUESTION_MOCK_TEXT] = 'What is familiarly known is not properly known, just for the reason that it is familiar.';

    d[K.REPLY_BTN] = 'Reply';
    d[K.SIGN_IN_TO_POST] = '<u>Sign in</u> to write a sidenote';
    d[K.THREAD_COLLAPSE_BTN] = 'Collapse';
    d[K.THREAD_EXPAND_BTN_PLURAL] = 'Expand {number} Replies';
    d[K.THREAD_EXPAND_BTN_SINGULAR] = 'Expand 1 Reply';
    d[K.THREAD_REPLY_BTN] = 'Reply to Conversation';
    d[K.PERMALINK_TITLE] = 'Permalink';
    d[K.PERMALINK_BACK_BTN] = 'All';
    d[K.PERMALINK_MISSING] = 'This Sidenote is no longer visible.';

    d[K.NOTIFICATION_APPROVED] = 'Approved';
    d[K.NOTIFICATION_DELETED] = 'Deleted';
    d[K.NOTIFICATION_FLAGGED] = 'Flagged';

    d[K.FACEBOOK_SHARE_DESCRIPTION] = 'Check out this Sidenote: "{body}"';
    d[K.FACEBOOK_SHARE_DESCRIPTION_SOURCE] = '"{body}"';
    d[K.FACEBOOK_SHARE_CAPTION] = 'Sidenotes on "{title}"';

    d[K.SLIDER_COMMENT_TALLY] = 'of';
    d[K.SLIDER_INVITE_READ] = 'Read';
    d[K.SLIDER_INVITE_WRITE] = 'Write';
    d[K.SLIDER_LOADING] = 'Loading...';
    d[K.SLIDER_WRITE_TEXT] = 'What do you think? Tap to write.';

    // Errors
    d[K.ERROR_CONNECTION] = 'Uh-oh. You don\'t seem to have a good connection.';
    d[K.ERROR_DUPLICATE] = 'We like your note too, but you can\'t post it twice.';
    d[K.ERROR_GENERAL] = 'An error has occurred. Please try again.';
    d[K.ERROR_SERVER] = 'Something went wrong with our server. Try that again?';

    return d;
})();

/**
 * Get an enumeration value.
 * @param {!string} key The key of the enumeration to retrieve.
 * @return {string=} The enumeration string.
 */
TextEnumeration.prototype.get = function(key) {
    return this.values_[key];
};

/**
 * Get an enumeration value and do replacements on it.
 * @param {!string} key The key of the enumeration to retrieve.
 * @param {!Array} data The replacement data.
 * @return {string=} The enumeration string.
 */
TextEnumeration.prototype.getAndReplace = function(key, data) {
    var str = this.get(key);
    if (!str || str.indexOf('%s') === -1) {
        return str;
    }
    var len = data.length;
    for (var i=0; i<len; i++) {
        str = str.replace(/\%s/, data[i]);
    }
    return str;
};

/**
 * Reset the values back to the default.
 */
TextEnumeration.prototype.reset = function() {
    this.set(TextEnumeration.VALUES);
};

/**
 * Set an enumeration value or values.
 * @param {string|Object} key If a string, it is the key to set. If it's an
 *   Object, that is the entire set of enumerations to load.
 * @param {string=} opt_value The value of the enumeration.
 */
TextEnumeration.prototype.set = function(key, opt_value) {
    if (typeof key === 'string') {
        this.values_[key] = opt_value;
        return;
    }
    var k;
    for (k in key) {
        if (key.hasOwnProperty(k)) {
            this.set(k, key[k]);
        }
    }
};

module.exports = new TextEnumeration();

});

define('annotations/blocks/ui/counter/questionpopover',['require','exports','module','jquery','hgn!templates/blocks/questionpopover','annotations/util/dom','inherits','annotations/util/internals','annotations/ui/popover','annotations/i18n/enumeration'],function (require, exports, module) {var $ = require('jquery');
var contentTemplate = require('hgn!templates/blocks/questionpopover');
var domUtil = require('annotations/util/dom');
var inherits = require('inherits');
var internals = require('annotations/util/internals');
var Popover = require('annotations/ui/popover');
var textEnumeration = require('annotations/i18n/enumeration');

/**
 * @constructor
 * @extends {Popover}
 * @param {Object} opts
 */
function QuestionPopover(opts) {
    Popover.call(this, $.extend({

        /**
         * Amount of pixels to pad the popover with.
         * @type {number}
         */
        sidePadding: 10,

        /**
         * Amount of pixels that should be above the popover at the top of
         * the viewport.
         * @type {number}
         */
        topSpacing: 10
    }, opts));

    /**
     * The height of the popover in pixels.
     * @type {?number}
     * @private
     */
    this._height;

    /**
     * The width of the popover in pixels.
     * @type {?number}
     * @private
     */
    this._width;

    /**
     * The position of the popover.
     * @type {string}
     * @private
     */
    this._position = Popover.POSITIONS.SMART;
}
inherits(QuestionPopover, Popover);

/** @enum {string} */
QuestionPopover.CLASSES = {
    EXPLANATION: 'lf-explanation-text',
    TITLE: 'lf-title-text',
    MAIN: 'lf-question-popover'
};
$.extend(QuestionPopover.CLASSES, Popover.CLASSES);

/**
 * Don't want clicks on fake thread buttons to bubble up to be handled.
 * @param {jQuery.Event} ev
 */
QuestionPopover.prototype._handleClick = function (ev) {
    ev.stopPropagation();
};

/** @override */
QuestionPopover.prototype._getBottomPosition = function (elem) {
    this._activePosition = Popover.POSITIONS.BOTTOM;
    var top = this._boundingRect.bottom + domUtil.getScrollY() + 10;
    var left = this._boundingRect.left + domUtil.getScrollX() +
        (this._boundingRect.width / 2) - (this._width / 2);
    return {top: top, left: left};
};

/**
 * Get the context for the popover content.
 * @return {object}
 * @private
 */
QuestionPopover.prototype._getContentTemplateContext = function () {
    var KEYS = textEnumeration.KEYS;
    return {
        strings: {
            explanation: textEnumeration.get(KEYS.QUESTION_EXPLANATION),
            mockText: textEnumeration.get(KEYS.QUESTION_MOCK_TEXT),
            title: textEnumeration.get(KEYS.QUESTION_TITLE)
        }
    };
};

/** @override */
QuestionPopover.prototype._getRightPosition = function (elem) {
    this._activePosition = Popover.POSITIONS.RIGHT;
    var top = this._boundingRect.top + domUtil.getScrollY() +
        (this._boundingRect.height / 2) - (this._height / 2);
    var left = this._boundingRect.right + domUtil.getScrollX() + 10;
    return {top: top, left: left};
};

/** @override */
QuestionPopover.prototype._scrollIntoPosition = internals.nullFunction;

/** @override */
QuestionPopover.prototype._getSmartPosition = function (elem) {
    // Minimize DOM queries.
    this._boundingRect = domUtil.getBoundingClientRect(elem);
    if (!this._height) {
        var popoverBoundingRect = domUtil.getBoundingClientRect(this.el);
        this._height = popoverBoundingRect.height;
        this._width = popoverBoundingRect.width;
    }
    var position = this._getRightPosition(elem);
    if (position.top < 0) {
        return this._getBottomPosition(elem);
    }
    this._boundingRect = null;
    return position;
};

/** @override */
QuestionPopover.prototype.events = (function () {
    var events = {};
    $.extend(events, Popover.prototype.events);
    events['click'] = '_handleClick';
    return events;
})();

/** @override */
QuestionPopover.prototype.destroy = function () {
    $(document.body).off('mousedown.QuestionPopover', $.proxy(this.hide, this));
    Popover.prototype.destroy.call(this);
};

/** @override */
QuestionPopover.prototype.elClass = [
    Popover.CLASSES.BASE,
    QuestionPopover.CLASSES.MAIN
].join(' ');

/** @override */
QuestionPopover.prototype.hideInternal = function (opt_callback) {
    $(document.body).off('mousedown.QuestionPopover', $.proxy(this.hide, this));
    Popover.prototype.hideInternal.call(this, opt_callback);
};

/** @override */
QuestionPopover.prototype.render = function () {
    Popover.prototype.render.call(this);
    this.setContentNode($(contentTemplate(this._getContentTemplateContext())));
};

/** @override */
QuestionPopover.prototype.show = function(el, opt_cb) {
    var selectionCallback = $.proxy(this.hide, this);
    Popover.prototype.show.call(this, el, function() {
        $(document.body).one('mousedown.QuestionPopover', selectionCallback);
        opt_cb && opt_cb();
    });
};

module.exports = QuestionPopover;

});

define("hgn!templates/blocks/numcomments", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<span class=\"lf-action-view-wrapper\">");_.b("\n" + i);_.b("    <span class=\"fycon-action-view\"></span>");_.b("\n" + i);_.b("</span>");_.b("\n" + i);_.b("<span class=\"lf-text\">");_.b(_.v(_.f("commentCount",c,p,0)));_.b("&nbsp;");_.b(_.v(_.d("strings.appName",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("<span class=\"lf-question-wrapper\">");_.b("\n" + i);_.b("    <span class=\"fycon-question\"></span>");_.b("\n" + i);_.b("</span>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/blocks/ui/counter/numcomments',['require','exports','module','inherits','annotations/blocks/ui/counter/questionpopover','annotations/i18n/enumeration','annotations/events','annotations/util/useragent','view','annotations/enums','hgn!templates/blocks/numcomments'],function (require, exports, module) {var inherits = require('inherits');
var QuestionPopover = require('annotations/blocks/ui/counter/questionpopover');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;
var UserAgentUtil = require('annotations/util/useragent');
var View = require('view');
var viewEnum = require('annotations/enums').navigableViews;

/**
 * @param {object} opts
 * @extends {View}
 * @constructor
 */
function NumComments(opts) {
    opts = opts || {};
    View.call(this, opts);

    /**
     * @type {number}
     * @private
     */
    this._commentCount = opts.numVisible || 0;

    /**
     * @type {?QuestionPopover}
     * @private
     */
    this._questionPopover;
}
inherits(NumComments, View);

/** @enum {string} */
NumComments.CLASSES = {
    MAIN: 'lf-num-sidenotes'
};

/**
 * Show the info popover
 * @private
 */
NumComments.prototype._handleClick = function () {
    if (!this._questionPopover) {
        this._questionPopover = new QuestionPopover();
        this._questionPopover.render();
    }
    if (this._questionPopover.isShowing() || this._questionPopover.isVisible()) {
        return;
    }
    this._questionPopover.show(this.el);
};

/**
 * Show an info menu screen
 * @private
 */
NumComments.prototype._handleTouch = function () {
    this.$el.trigger(ThreadEvents.CHANGE_VIEW, {
        value: viewEnum.QUESTION
    });
};

/**
 * @param {Element} el
 */
NumComments.prototype.decorate = function (el) {
    this.render();
    el.appendChild(this.el);
};

/** @override */
NumComments.prototype.destroy = function () {
    View.prototype.destroy.call(this);
    this._questionPopover && this._questionPopover.destroy();
    this._questionPopover = null;
    this._commentCount = null;
};

/** @override */
NumComments.prototype.elClass = NumComments.CLASSES.MAIN;

/** @override */
NumComments.prototype.events = (function () {
    var events = {};
    if (!UserAgentUtil.isMobile()) {
        events['click'] = '_handleClick';
    } else {
        events['tap'] = '_handleTouch';
    }
    return events;
})();

/** @override */
NumComments.prototype.getTemplateContext = function () {
    return {
        commentCount: this._commentCount,
        strings: {
            appName: textEnumeration.get(textEnumeration.KEYS.APP_NAME)
        }
    };
};

/** @override */
NumComments.prototype.template = require('hgn!templates/blocks/numcomments');

/**
 * Adjust the number of annotations on the page.
 * @param {number} inc
 */
NumComments.prototype.updateNumAnnotations = function (inc) {
    this._commentCount += inc;
    this.render();
};

module.exports = NumComments;

});

define("hgn!templates/blocks/selectionpopover", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<a data-value=\"annotation\" class=\"lf-add-annotation fycon-write\"></a>");_.b("\n" + i);_.b("<a data-value=\"twitter\" class=\"lf-share-twitter fycon-source-twitter\"></a>");_.b("\n" + i);_.b("<a data-value=\"facebook\" class=\"lf-share-facebook fycon-source-facebook\"></a>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/blocks/ui/selectionpopover',['require','exports','module','jquery','hgn!templates/blocks/selectionpopover','annotations/util/dom','inherits','annotations/ui/popover','annotations/events'],function (require, exports, module) {/**
 * @fileoverview
 * The tooltip for sharing a selection or adding an annotation.
 */

var $ = require('jquery');
var actionsTemplate = require('hgn!templates/blocks/selectionpopover');
var domUtil = require('annotations/util/dom');
var inherits = require('inherits');
var Popover = require('annotations/ui/popover');
var SourceEvents = require('annotations/events').source;

/**
 * @constructor
 * @extends {Popover}
 * @param opts View config opts
 */
var SelectionPopover = function(opts) {
    Popover.call(this, opts);

    /**
     * Element that events will be bubbled to so that they can be handled.
     * @type {jQuery}
     */
    this.$antenna = opts.antenna;
};
inherits(SelectionPopover, Popover);

/** @enum {string} */
SelectionPopover.CLASSES = {
    ADD_ANNOTATION: 'lf-add-annotation',
    MAIN: 'lf-selection-popover',
    SHARE_FACEBOOK: 'lf-share-facebook',
    SHARE_TWITTER: 'lf-share-twitter'
};

/** @enum {string} */
SelectionPopover.EVENT_MAP = {
    'annotation': SourceEvents.ADD_ANNOTATION_CLICK,
    'facebook': SourceEvents.SHARE_CLICK,
    'twitter': SourceEvents.SHARE_CLICK
};

/** @override */
SelectionPopover.prototype.elClass = [
    Popover.prototype.elClass,
    SelectionPopover.CLASSES.MAIN
].join(' ');

/**
 * Handle the mousedown event on one of the action links.
 * @param {jQuery.Event} ev
 * @private
 */
SelectionPopover.prototype._handlePress = function(ev) {
    // Stop propagation
    Popover.prototype._handlePress.call(this, ev);
    var value = $(ev.target).attr('data-value');
    if (!value) {
        return;
    }
    this.$antenna.trigger(SelectionPopover.EVENT_MAP[value], {
        value: value
    });
    this.hide();
};

/** @override */
SelectionPopover.prototype.destroy = function() {
    $(document.body).off('mousedown.SelectionPopover', $.proxy(this.hide, this, null));
    Popover.prototype.destroy.call(this);
};

/** @override */
SelectionPopover.prototype.hideInternal = function(opt_callback) {
    $(document.body).off('mousedown.SelectionPopover', $.proxy(this.hide, this, null));
    Popover.prototype.hideInternal.call(this, opt_callback);
};

/** @override */
SelectionPopover.prototype.render = function() {
    Popover.prototype.render.call(this);
    this.setContentNode($(actionsTemplate()));
};

/** @override */
SelectionPopover.prototype.resizeAndReposition = function(range) {
    var boundingRect = domUtil.getBoundingClientRect(range);
    var top = boundingRect.top + domUtil.getScrollY() - this.$el.height();
    var midSelWidth = boundingRect.width / 2;
    var midElWidth = this.$el.width() / 2;
    var left = midSelWidth + domUtil.getScrollX() + boundingRect.left - midElWidth;
    this.$el.css({top: top, left: left});
};

/** @override */
SelectionPopover.prototype.show = function(el) {
    var selectionCallback = $.proxy(this.hide, this, null);
    Popover.prototype.show.call(this, el, function() {
        $(document.body).one('mousedown.SelectionPopover', selectionCallback);
    });
};

module.exports = SelectionPopover;

});

define("hgn!templates/blocks/thread-btn", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");if(_.s(_.f("count",c,p,1),c,p,0,10,56,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("<a class=\"fycon-action-view\">");_.b(_.v(_.f("count",c,p,0)));_.b("</a>");_.b("\n");});c.pop();}if(!_.s(_.f("count",c,p,1),c,p,1,0,0,"")){_.b("<a class=\"fycon-action-view\">");if(_.s(_.f("isMedia",c,p,1),c,p,0,119,151,"{{ }}")){_.rs(c,p,function(c,p,_){_.b(_.v(_.d("strings.emptyImageBlockTxt",c,p,0)));});c.pop();}if(!_.s(_.f("isMedia",c,p,1),c,p,1,0,0,"")){_.b(_.v(_.d("strings.emptyTextBlockTxt",c,p,0)));};_.b("\n" + i);_.b("</a>");_.b("\n");};return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/blocks/ui/thread-btn',['require','exports','module','jquery','annotations/models/block','view/event-map','inherits','observer','annotations/events','annotations/i18n/enumeration','annotations/util/useragent','view','hgn!templates/blocks/thread-btn'],function (require, exports, module) {/**
 * @fileoverview Annotation button.
 */

var $ = require('jquery');
var Block = require('annotations/models/block');
var EventMap = require('view/event-map');
var inherits = require('inherits');
var Observer = require('observer');
var SourceEvents = require('annotations/events').source;
var textEnumeration = require('annotations/i18n/enumeration');
var UserAgentUtil = require('annotations/util/useragent');
var View = require('view');

/**
 * @constructor
 * @extends {View}
 */
function ThreadBtn(opts) {
    View.call(this, opts);

    /**
     * Is this thread currently active?
     * @type {boolean}
     * @private
     */
    this._active = false;

    /**
     * The block that this thread button is attached to.
     * @type {Block}
     * @private
     */
    this._block = opts.block;

    /**
     * Rendering delegate for thread buttons.
     * @type {function()=}
     * @private
     */
    this._threadBtnDelegate = opts.threadBtnDelegate;

    /**
     * Element that events will be bubbled to so that they can be handled.
     * @type {jQuery}
     */
    this.$antenna = opts.antenna;

    Observer(this);
    this.listenTo(this._block, 'change:numAnnotations', $.proxy(this.render, this));
}
inherits(ThreadBtn, View);

/** @enum {string} */
ThreadBtn.CLASSES = {
    ACTIVE: 'lf-active',
    BUTTON: 'fycon-action-view',
    CUSTOM_BTN: 'lf-custom-thread-btn',
    HAS_NUM: 'lf-has-num',
    HOVER: 'lf-thread-vis-hover'
};

/** @enum {string} */
var ICON_VIS = {
    HOVER: 'hover',
    STATIC: 'static'
};

/** @override */
ThreadBtn.prototype.events = new EventMap(function () {
    var CLASSES = ThreadBtn.CLASSES;
    var events = {};

    if (!UserAgentUtil.isMobile()) {
        events['click .' + CLASSES.BUTTON] = '_handleThreadBtnClick';
        events['mousedown .' + CLASSES.BUTTON] = '_handleThreadBtnMousedown';
    } else {
        events['tap .' +  CLASSES.BUTTON] = '_handleThreadBtnClick';
        events['mousedown .' + CLASSES.BUTTON] = '_handleClearMobileMousedown';
        events['tapstart .' + CLASSES.BUTTON] = '_handleThreadBtnMousedown';
    }
    return events;
});

/** @override */
ThreadBtn.prototype.template = require('hgn!templates/blocks/thread-btn');

/**
 * Don't let the mousedown event propagate for mobile.
 * @private
 */
ThreadBtn.prototype._handleClearMobileMousedown = function (evt) {
    evt.stopPropagation();
};

/**
 * Handle the click event.
 * @private
 */
ThreadBtn.prototype._handleThreadBtnClick = function (evt) {
    evt.stopPropagation();
    this.$antenna.trigger(SourceEvents.THREAD_BTN_CLICK, {blockId: this._block.id});
};

/**
 * Handle the mousedown event.
 * @private
 */
ThreadBtn.prototype._handleThreadBtnMousedown = function (evt) {
    evt.stopPropagation();
    this.$antenna.trigger(SourceEvents.THREAD_BTN_MOUSEDOWN, {blockId: this._block.id});
};

/**
 * Is the block of type media?
 * @return {boolean}
 * @private
 */
ThreadBtn.prototype._isMedia = function () {
    return [Block.TYPES.MEDIA, Block.TYPES.IMAGE].indexOf(this._block.blockType) > -1;
};

/** @override */
ThreadBtn.prototype.destroy = function () {
    View.prototype.destroy.call(this);
    this.stopListening();
};

/** @override */
ThreadBtn.prototype.getTemplateContext = function () {
    var KEYS = textEnumeration.KEYS;
    return {
        active: this._active,
        blockType: this._block.blockType,
        count: Math.max(this._block.numAnnotations || 0, 0),
        isMedia: this._isMedia(),
        strings: {
            emptyImageBlockTxt: textEnumeration.get(KEYS.EMPTY_IMAGE_BLOCK_TXT),
            emptyTextBlockTxt: textEnumeration.get(KEYS.EMPTY_TEXT_BLOCK_TXT)
        }
    };
};

/**
 * Is this thread button active?
 * @return {boolean}
 */
ThreadBtn.prototype.isActive = function() {
    return this._active;
};

/** @override */
ThreadBtn.prototype.render = function() {
    var CLASSES = ThreadBtn.CLASSES;
    var rendered = false;

    if (this._threadBtnDelegate) {
        var elem = this._threadBtnDelegate(this.getTemplateContext());
        // User can pass null back which means that they want us to use our
        // template for the specific block type.
        if (elem) {
            elem = typeof elem === 'string' ? $(elem)[0] : elem;
            this.$el.html('').append(elem).addClass(CLASSES.CUSTOM_BTN);
            rendered = true;
        }
    }
    if (!rendered) {
        View.prototype.render.call(this);
    }

    var hasNum = Math.max(this._block.numAnnotations || 0, 0) > 0;
    var isHover = this.opts.iconVisibility.empty === ICON_VIS.HOVER;
    var isNumHover = this.opts.iconVisibility.num === ICON_VIS.HOVER && hasNum;

    this.$('.' + CLASSES.BUTTON).attr(Block.DATA_ID, this._block.id);
    this.$el.toggleClass(CLASSES.HAS_NUM, hasNum);
    this.$el.toggleClass(CLASSES.HOVER, isNumHover || isHover && !hasNum);
};

/**
 * Redraw with a new active state.
 * @param {boolean} isActive
 */
ThreadBtn.prototype.setActiveState = function (isActive) {
    this._active = isActive;
    this.$el.toggleClass(ThreadBtn.CLASSES.ACTIVE, isActive);
};

module.exports = ThreadBtn;

});

define('annotations/blocks/controller',['require','exports','module','jquery','annotations/controller/base','annotations/models/block','annotations/blocks/detector','annotations/events','annotations/adapters','view/event-map','annotations/blocks/highlighter','inherits','annotations/blocks/ui/counter/numcomments','annotations/util/object','annotations/blocks/ui/selectionpopover','annotations/events','annotations/util/storage','annotations/blocks/ui/thread-btn','annotations/events','annotations/util/useragent','xrange/xrange'],function (require, exports, module) {/**
 * @fileOverview Block controller.
 */

var $ = require('jquery');
var BaseController = require('annotations/controller/base');
var Block = require('annotations/models/block');
var BlockDetector = require('annotations/blocks/detector');
var BlockEvents = require('annotations/events').block;
var BootstrapKeys = require('annotations/adapters').BootstrapKeys;
var EventMap = require('view/event-map');
var Highlighter = require('annotations/blocks/highlighter');
var inherits = require('inherits');
var NumComments = require('annotations/blocks/ui/counter/numcomments');
var objectUtil = require('annotations/util/object');
var SelectionPopover = require('annotations/blocks/ui/selectionpopover');
var SourceEvents = require('annotations/events').source;
var Storage = require('annotations/util/storage');
var ThreadBtn = require('annotations/blocks/ui/thread-btn');
var ThreadEvents = require('annotations/events').thread;
var UserAgentUtil = require('annotations/util/useragent');
var XRange = require('xrange/xrange');

/**
 * Block controller.
 * @constructor
 * @extends {BaseController}
 * @param opts View config opts
 * @param opts.el An ancestor el common to all the block elements, the simplest
 *    choice would be document.body.
 * @param opts.sourceElements {Array.<Element>} The elements specified as
 *    annotation blocks.
 */
function BlockController(opts) {
    BaseController.call(this, opts);

    /**
     * The block id to the corresponding Block.
     * @param {Object.<string, ThreadBtn>}
     * @private
     */
    this._blockIdToThreadBtn = {};

    /**
     * The Element id to the corresponding Block.
     * @param {Object.<string, Block>}
     * @private
     */
    this._elementIdToBlock = {};

    /**
     * @type {?Block}
     * @private
     */
    this._highlightedBlock = null;

    /**
     * @type {?string}
     * @private
     */
    this._highlightedText = null;

    /**
     * @type {Highlighter}
     * @private
     */
    this._highlighter = new Highlighter(opts.config.selectors, this.$antenna);

    /**
     * Anchor content from the init document. This contains the list of existing
     * blocks and their counts.
     * @type {Object=}
     * @private
     */
    this._initAnchorContent = null;

    /**
     * @type {?SelectionPopover}
     * @private
     */
    this._selectionPopover = null;
}
inherits(BlockController, BaseController);

/** @enum {string} */
BlockController.CLASSES = {
    MOBILE_THREAD_BUTTON: 'lf-mobile-thread-btn',
    THREAD_BUTTON: 'lf-thread-btn'
};

/** @override */
BlockController.prototype.events = new EventMap(function () {
    var events = {};
    events[BlockEvents.UPDATE_COUNT] = '_handleUpdateBlockCount';
    events[SourceEvents.ADD_ANNOTATION_CLICK] = '_handleAddAnnotationClick';
    events[SourceEvents.TEXT_HIGHLIGHTED] = '_handleTextHighlighted';
    events[SourceEvents.THREAD_BTN_CLICK] = '_handleThreadBtnClick';
    events[ThreadEvents.ACTIVATE_BLOCK] = '_handleActivateBlock';
    events[ThreadEvents.ACTIVATE_HIGHLIGHTED_TEXT] = '_handleActivateHighlightedText';
    events[ThreadEvents.DEACTIVATE_HIGHLIGHTED_TEXT] = '_handleDeactivateHighlightedText';

    if (UserAgentUtil.isMobile()) {
        events[SourceEvents.TEXT_HIGHLIGHTED] = '_handleTextHighlightedMobile';
    }
    return events;
});

/** @override */
BlockController.prototype.globalEvents = new EventMap(function () {
    var events = {};
    events['mousedown'] = '_handleDeactivateHighlightedText';
    events[SourceEvents.THREAD_BTN_CLICK] = '_handleGlobalThreadBtnClick';
    events[ThreadEvents.DESTROY_THREAD] = '_deactivateBlock';
    return events;
});

/**
 * Activate a block. Trigger an event and toggle the thread button.
 * @param {Block} block The block to activate.
 * @private
 */
BlockController.prototype._activateBlock = function (block) {
    this.$antenna.trigger(ThreadEvents.ACTIVATE_THREAD);
    this._toggleThreadBtn(block, true);
};

/**
 * Deactivate a block.
 */
BlockController.prototype._deactivateBlock = function () {
    var block = this._getActiveBlock();
    if (!block) {
        return;
    }
    this._collection.block = null;
    this._toggleThreadBtn(block, false);
    this._unfreezeHighlight();
};

/**
 * Add span to freeze the appearance of text selection.
 * @private
 */
BlockController.prototype._freezeHighlight = function () {
    if (!this._highlightedRange) {
        return;
    }
    this._highlighter.freezeHighlight(this._highlightedRange, this._highlightedText);
};

/**
 * Handle the activate block event. This should toggle the thread button.
 * @param {jQuery.Event} ev
 * @param {Object} data
 * @private
 */
BlockController.prototype._handleActivateBlock = function (ev, data) {
    this._toggleThreadBtn(data.block, true);
};

/**
 * @param {jQuery.Event} ev
 * @param {Object} info
 * @param {string} info.blockId
 * @param {string} info.selectedText
 */
BlockController.prototype._handleActivateHighlightedText = function (ev, info) {
    if (this._highlightedRange) {
        return;
    }
    // Fall back to the collection selection when the user is currently posting a comment
    // with a selection.
    info = info || {};
    var blockId = info.blockId || this._collection.block.id;
    var selectedText = info.selectedText || this._collection.selectedText;
    this._setRangeForText(blockId, selectedText);
};

/**
 * Handles a click on the add annotation button in the selection popover.
 * @param {jQuery.Event} ev
 * @private
 */
BlockController.prototype._handleAddAnnotationClick = function (ev) {
    this._deactivateBlock();
    this._freezeHighlight();
    var block = this._collection.block = this._highlightedBlock;
    this._activateBlock(block);
};

/**
 * @param {jQuery.Event} ev
 */
BlockController.prototype._handleDeactivateHighlightedText = function (ev) {
    this._unfreezeHighlight();
};

/**
 * Handle the global thread button click event. Only deactivate the block if it
 * was triggered from a different app instance.
 * @private
 */
BlockController.prototype._handleGlobalThreadBtnClick =
    BaseController.onlyHandleExternalMessage(BlockController.prototype._deactivateBlock);

/**
 * Handles a text highlight from the highlighter.
 * @param {jQuery.Event} ev
 * @param {Object} info
 * @param {string} info.text
 * @param {Range} info.range
 * @private
 */
BlockController.prototype._handleTextHighlightedBase = function (ev, info) {
    var block = this._elementIdToBlock[info.blockId];
    var range = this._highlightedRange = info.range;
    this._collection.selectedText = this._highlightedText = info.text;
    this._highlightedBlock = block;
    return range;
};

/**
 * Activates the selection popover.
 * @param {jQuery.Event} ev
 * @param {Object} info
 * @param {string} info.text
 * @param {Range} info.range
 * @private
 */
BlockController.prototype._handleTextHighlighted = function (ev, info) {
    // Prevent highlights from conflicting with one another.
    if (this._highlightedRange) {
        return;
    }
    if (!this._selectionPopover) {
        this._selectionPopover = new SelectionPopover({
            antenna: this.$antenna
        });
    }
    var range = this._handleTextHighlightedBase(ev, info);
    this._selectionPopover.onHide($.proxy(function () {
        this._selectionPopover.show(range);
    }, this));
};

/**
 * Triggers an event that will cause the WriteCard to be displayed.
 * @param {jQuery.Event} ev
 * @param {Object} info
 * @param {string} info.text
 * @param {Range} info.range
 * @private
 */
BlockController.prototype._handleTextHighlightedMobile = function (ev, info) {
    this._handleTextHighlightedBase(ev, info);
    // Do not want to show the write card if we are already showing a thread.
    if (this._collection.block) {
        return;
    }
    var block = this._elementIdToBlock[info.blockId];
    this._collection.block = block;
    this.$antenna.trigger(ThreadEvents.ACTIVATE_THREAD, {
        forceWriteCard: true
    });
};

/**
 * Handles a click on the thread button, this results in the thread for this
 * block being displayed.
 * @param {Event} ev
 * @private
 */
BlockController.prototype._handleThreadBtnClick = function (ev, data) {
    // Prevent the touch from becoming a click.
    ev.preventDefault();
    var isActive = this._blockIdToThreadBtn[data.blockId].isActive();
    if (isActive) {
        this.$antenna.trigger(ThreadEvents.DESTROY_THREAD);
        return;
    }
    this._deactivateBlock();
    var block = this._elementIdToBlock[data.blockId];
    this._collection.block = block;
    this._collection.selectedText = null;
    this._activateBlock(block);
};

/**
 * Update the block count for the provided blockId.
 * @param {jQuery.Event} ev
 * @param {Object} data The event data.
 * @private
 */
BlockController.prototype._handleUpdateBlockCount = function (ev, data) {
    var block = Storage.get(data.blockId);
    var diff = block.updateNumAnnotations(data.inc, data.count);
    this._numComments && this._numComments.updateNumAnnotations(diff);
};

/**
 * @param {string} blockId
 * @param {string} selectedText
 */
BlockController.prototype._setRangeForText = function (blockId, selectedText) {
    var blockEl = this._blockIdToThreadBtn[blockId].el.parentNode;
    var range = XRange.getRangeByString(selectedText, blockEl);

    // No children were found that contain the selectedText.
    if (!range) {
        return;
    }

    this._highlightedRange = range;
    this._highlightedText = selectedText;
    this._freezeHighlight();
};

/**
  * Renders the thread buttuns for each block.
  * @param blocks {Array.<Block>}
  * @private
  */
BlockController.prototype._setThreadBtns = function (blocks) {
    var threadBtn;
    var self = this;

    $.each(blocks, function(i, block) {
        threadBtn = new ThreadBtn({
            antenna: self.$antenna,
            block: block,
            el: block.el.appendChild(document.createElement('span')),
            iconVisibility: self._config.iconVisibility,
            threadBtnDelegate: self._config.threadBtnDelegate
        });
        var CLASSES = BlockController.CLASSES;
        var cls = UserAgentUtil.isMobile() ? CLASSES.MOBILE_THREAD_BUTTON : CLASSES.THREAD_BUTTON;
        threadBtn.render();
        threadBtn.$el.addClass(cls);

        self._elementIdToBlock[block.id] = block;
        self._blockIdToThreadBtn[block.getId()] = threadBtn;
    });
};

/**
 * Toggle the state of a thread button.
 * @param {Block} block The block of the thread button to toggle.
 * @param {boolean} isActive
 * @private
 */
BlockController.prototype._toggleThreadBtn = function (block, isActive) {
    var threadBtn = this._blockIdToThreadBtn[block.getId()];
    threadBtn.setActiveState(isActive);
};

/**
 * Remove a span to unfreeze the appearance of text selection.
 * @private
 */
BlockController.prototype._unfreezeHighlight = function () {
    if (!this._highlightedRange) {
        return;
    }
    this._highlighter.unfreezeHighlight(this._highlightedRange, this._highlightedText);
    this._highlightedRange = null;
    this._highlightedText = null;
};

/**
 * Remove wrapper HTML from thread buttons.
 * @private
 */
BlockController.prototype._unwrapBlocks = function () {
    var blockId;
    var self = this;
    var threadBtn;
    $.each(this._elementIdToBlock, function (elemId, block) {
        blockId = block.getId();
        threadBtn = self._blockIdToThreadBtn[blockId];
        threadBtn.destroy();
        BlockDetector.unwrapBlock(block);
    });
};

/** @override */
BlockController.prototype.destroy = function () {
    BaseController.prototype.destroy.call(this);
    this._selectionPopover && this._selectionPopover.destroy();
    this._unfreezeHighlight();
    this._unwrapBlocks();
    this._elementIdToBlock = null;
    this._blockIdToThreadBtn = null;
    $('body').off('mousedown', $.proxy(this._handleDeactivateHighlightedText, this));
};

/**
 * Initialize the blocks.
 * @param {Object} initData
 */
BlockController.prototype.initialize = function (initData) {
    var anchors = initData[BootstrapKeys.ANCHORS];
    var numVisible = 0;
    var numCommentsLoc = this._config.numSidenotesEl;
    // Might be a fresh collection
    if (anchors) {
        this._initAnchorContent = anchors[BootstrapKeys.CONTENT];
        numVisible = anchors[BootstrapKeys.NUM_VISIBLE];
    }

    if (!numCommentsLoc) {
        return;
    }
    this._numComments = this._numComments || new NumComments({
        numVisible: numVisible
    });
    this._numComments.decorate(numCommentsLoc);
};

/**
 * Initialize blocks for the provided selectors. This will detect blocks, match
 * them to existing ones, and add thread buttons.
 * @param {jQuery} selectors JQuery object containing all elements that should
 *   be used when creating blocks.
 */
BlockController.prototype.initializeBlocks = function (selectors) {
    var blockDetector = new BlockDetector({
        content: this._initAnchorContent,
        selectors: selectors
    });
    this._setThreadBtns(blockDetector.detect());
};

module.exports = BlockController;

});

define('annotations/util/auth',['require','exports','module','auth','annotations/events','annotations/enums'],function (require, exports, module) {var auth = require('auth');
var ThreadEvents = require('annotations/events').thread;
var viewEnum = require('annotations/enums').navigableViews;

module.exports = {
    /**
     * Require authentication decorator. Wrapping function declarations with this
     * will allow them to require authentication before continuing their regularly
     * scheduled functions. Also stops the event so that nobody else will be able
     * to handle it since we're requiring authentication.
     * @param {function()} handler The handler to wrap.
     * @param {?string} opt_event The event to wrap.
     * @return {function()} The wrapped function.
     */
    requireAuth: function requireAuth(handler, opt_event) {
        return function(ev) {
            var event = opt_event || [ev.type, ev.namespace].join('.');
            if (!auth.get('livefyre')) {
                // Trigger a navigate event so that the ThreadController can handle
                // it and change the view to the auth menu.
                var eventTarget = this.$antenna || this.$el;
                eventTarget.trigger(ThreadEvents.NAVIGATE, {
                    event: event,
                    value: viewEnum.AUTH
                });
                return;
            }
            handler.apply(this, arguments);
        };
    }
};

});

define('annotations/util/social',['require','exports','module','jquery','annotations/i18n/enumeration'],function (require, exports, module) {/**
 * @fileOverview Tweet utilities that convert different data combinations to
 * 140 character tweets.
 */

var $ = require('jquery');
var textEnumeration = require('annotations/i18n/enumeration');

/** @const {string} */
var FACEBOOK_APP_ID = '595267417193679';

/** @type {Object} */
var Social = {};

/**
 * Clean html off of a string of content.
 * @param {string} str The string to clean.
 * @return {string} The cleaned string.
 */
function cleanHtml(str) {
    // Clean the html a little first by removing newlines and <br> elements.
    str = str.replace(/\n/g, ' ')
             .replace(/<br[ \/]?>/g, ' ')
             .replace(/\s+/g, ' ');
    // Build an element and get the text contents of it.
    return $('<div />').html(str).text();
}

/**
 * Adapt content to share to specific providers.
 * @param {Object|Comment} data The data to adapt. Keeping a similar object
 *    structure to the Comment model so that either can be used.
 * @param {string} provider The provider type being shared to.
 * @return {Object}
 */
Social.contentToShare = function(data, provider) {
    var fn = Social.contentToTweet;
    if (provider === 'facebook') {
        fn = Social.contentToFacebookMessage;
    }
    return fn(data);
};

/**
 * Adapt content to share to Facebook.
 * @param {Object|Comment} data The data to adapt.
 * @return {Object}
 */
Social.contentToFacebookMessage = function(data) {
    var KEYS = textEnumeration.KEYS;
    var desc = textEnumeration.get(KEYS.FACEBOOK_SHARE_DESCRIPTION);
    var sourceDesc = textEnumeration.get(KEYS.FACEBOOK_SHARE_DESCRIPTION_SOURCE);
    return {
        body: (data.isSource ? sourceDesc : desc).replace('{body}', cleanHtml(data.body)),
        url: data.permalink
    };
};

/**
 * Adapt content to share to Twitter.
 * @param {Object|Comment} data The data to adapt.
 * @return {Object}
 */
Social.contentToTweet = function(data) {
    var body = cleanHtml(data.body);
    var username = data.author.displayName;
    username = username ? '- ' + username : '';
    var permalink = data.permalink;
    var urlLength = 23; // 22 for the URL and 1 for the space in front of it.

    // Https t.co urls are 23 characters + 1 for the space.
    if (permalink.indexOf('https') === 0) {
        urlLength++;
    }

    // Tweets are always 140 characters.
    var remaining = 140 - urlLength - username.length;

    if (remaining < body.length + 2) {
        body = body.substring(0, remaining - 5) + '...';
    }

    return {
        body: '"' + body + '"' + username,
        url: data.permalink
    };
};

/**
 * Generate provider specific params.
 * @param {Object} params All necessary params.
 * @return {string} Url formatted params.
 */
Social.generateParams = function(params) {
    if (params.provider === 'facebook') {
        return generateFacebookParams(params);
    }
    return generateTwitterParams(params);
};

/**
 * Generate Facebook specific params.
 * @param {Object} params All necessary params.
 * @return {string} Url formatted params.
 */
function generateFacebookParams(params) {
    var caption = textEnumeration.get(textEnumeration.KEYS.FACEBOOK_SHARE_CAPTION);
    var uri = [
        window.location.protocol,
        params.assetServer,
        '/facebook-uri.html'
    ].join('');
    caption = encodeURIComponent(caption.replace('{title}', document.title));
    return ['?app_id=', FACEBOOK_APP_ID,
            '&caption=', caption,
            '&description=', encodeURIComponent(params.body),
            '&display=popup',
            '&link=', encodeURIComponent(params.url),
            '&redirect_uri=', encodeURIComponent(uri)].join('');
}

/**
 * Generate Twitter specific params.
 * @param {Object} params All necessary params.
 * @return {string} Url formatted params.
 */
function generateTwitterParams(params) {
    return ['?text=', encodeURIComponent(params.body),
            '&url=', encodeURIComponent(params.url)].join('');
}

module.exports = Social;

});

define('annotations/controller/comment',['require','exports','module','jquery','annotations/controller/base','annotations/events','inherits','annotations/util/internals','annotations/util/auth','annotations/util/social','annotations/events','annotations/events'],function (require, exports, module) {/**
 * @fileOverview Comment controller.
 */

var $ = require('jquery');
var BaseController = require('annotations/controller/base');
var CommentEvents = require('annotations/events').comment;
var inherits = require('inherits');
var internals = require('annotations/util/internals');
var requireAuth = require('annotations/util/auth').requireAuth;
var SocialUtil = require('annotations/util/social');
var SourceEvents = require('annotations/events').source;
var WriteEvents = require('annotations/events').write;

/**
 * Comment controller.
 * @param {Object} opts Config options.
 */
function CommentController(opts) {
    BaseController.call(this, opts);
}
inherits(CommentController, BaseController);

/** @enum {string} */
var COLLECTION_FN_MAP = (function () {
    var events = {};
    events[CommentEvents.GET_PERMALINK] = 'getPermalink';
    events[WriteEvents.POST_APPROVE] = 'postApprove';
    events[WriteEvents.POST_DELETE] = 'postDelete';
    events[WriteEvents.POST_EDIT] = 'postEdit';
    events[WriteEvents.POST_FLAG] = 'postFlag';
    events[WriteEvents.POST_HIDE] = 'postHide';
    events[WriteEvents.POST_VOTE] = 'postVote';
    return events;
})();

/** @enum {string} */
var SUCCESS_EVENT_MAP = (function () {
    var events = {};
    events[WriteEvents.POST_FLAG] = WriteEvents.COMMENT_FLAGGED;
    events[WriteEvents.POST_VOTE] = WriteEvents.COMMENT_VOTED;
    return events;
})();

/** @const {number} */
var SHARE_POPUP_HEIGHT = 420;

/** @const {number} */
var SHARE_POPUP_WIDTH = 550;

/** @enum {string} */
var SHARE_URLS = {
    facebook: 'https://www.facebook.com/dialog/feed',
    twitter: 'https://twitter.com/intent/tweet'
};

/** @enum {string} */
CommentController.prototype.events = (function() {
    var events = {};
    events[CommentEvents.GET_PERMALINK] = '_handleEvent';
    events[SourceEvents.SHARE_CLICK] = '_handleSourceShare';
    events[WriteEvents.POST_ANNOTATION] = '_handlePostAnnotation';
    events[WriteEvents.POST_APPROVE] = '_handleAuthenticatedEvent';
    events[WriteEvents.POST_EDIT] = '_handleAuthenticatedEvent';
    events[WriteEvents.POST_DELETE] = '_handleAuthenticatedEvent';
    events[WriteEvents.POST_FLAG] = '_handleEvent';
    events[WriteEvents.POST_HIDE] = '_handleAuthenticatedEvent';
    events[WriteEvents.POST_REPLY] = '_handlePostAnnotation';
    events[WriteEvents.POST_SHARE] = '_handleShare';
    events[WriteEvents.POST_VOTE] = '_handleAuthenticatedEvent';
    return events;
})();

/**
 * Handles the standard authenticated events that don't require additional
 * processing such as custom callbacks.
 * @param {jQuery.Event} ev
 * @param {Object} opts
 * @private
 */
CommentController.prototype._handleAuthenticatedEvent = requireAuth(function(ev, opts) {
    this._handleEvent(ev, opts);
});

/**
 * Handles the standard events that don't require additional processing.
 * @param {jQuery.Event} ev
 * @param {Object} opts
 * @private
 */
CommentController.prototype._handleEvent = function(ev, opts) {
    var event = ev.type + '.' + ev.namespace;
    var fn = COLLECTION_FN_MAP[event];
    var self = this;
    var successEvent = SUCCESS_EVENT_MAP[event];

    this._collection[fn].call(this._collection, opts, function (err, data) {
        (opts.callback || internals.nullFunction) (err, data);
        self.$antenna.trigger(CommentEvents.ACTION_SUCCESS, {event: ev});
        successEvent && self.$antenna.trigger(successEvent, opts);
    });
};

/**
 * Intercept the post event and add block data to the event object.
 * @param {Event} ev
 * @param {Object} opts
 * @param {string} opts.lftoken
 * @param {Annotation} opts.annotation
 * @private
 */
CommentController.prototype._handlePostAnnotation = requireAuth(function(ev, opts) {
    opts.postData = this._hydrateAnnotation(opts);
    var self = this;
    this._collection.postAnnotation(opts, function(err, comments) {
        err && opts.callback(err);
        if (err || !self._collection.block) {
            return;
        }
        opts.callback(err, comments);
        self._collection.push.apply(self._collection, comments);
        self.$antenna.trigger(WriteEvents.COMMENT_POSTED, comments[0]);
    });
});

/**
 * Handle the share event.
 * @param {jQuery.Event} ev
 * @param {Object} opts
 * @private
 */
CommentController.prototype._handleShare = function(ev, opts) {
    var baseUrl = SHARE_URLS[opts.value];
    var specs = [
        'height=',
        SHARE_POPUP_HEIGHT,
        ',width=',
        SHARE_POPUP_WIDTH
    ].join('');

    // Support the case where this event bubbles from someone clicking share on
    // a comment or from the selected text popover.
    var content = opts.model || {
        author: {displayName: this._config.twitterHandle || ''},
        body: opts.body || this._collection.selectedText || '',
        isSource: opts.isSource,
        permalink: window.location.href
    };
    var shareObj = SocialUtil.contentToShare(content, opts.value);
    shareObj.assetServer = this._config.servers.assets;
    shareObj.provider = opts.value;
    var params = SocialUtil.generateParams(shareObj);
    window.open(baseUrl + params, 'intent', specs);
    this.$antenna.trigger(WriteEvents.COMMENT_SHARED, $.extend({}, content, shareObj));
};

/**
 * Handle the source share event.
 * @param {jQuery.Event} ev
 * @param {Object} opts
 * @private
 */
CommentController.prototype._handleSourceShare = function(ev, opts) {
    opts.isSource = true;
    this._handleShare(ev, opts);
};

/**
 * Turn a partial annotation into a fully hydrated annotation with its block information.
 * @param {Annotation} annotation
 * @private
 */
CommentController.prototype._hydrateAnnotation = function(obj) {
    var data = {};
    var block = this._getActiveBlock();
    data.block_id = block.getId();
    data.body = obj.body;
    data._bi = Math.random();
    data.share_types = obj.shareTypes;

    // That's all that is needed for replies.
    if (obj.parentId) {
        data.parent_id = obj.parentId;
        return data;
    }

    data.block_type = block.blockType;
    data.index = block.index;
    data.hash = block.simhash;
    data.full_text = block.content;
    data.selected_text = this._collection.selectedText;
    return data;
};

module.exports = CommentController;

});

define('livefyre-auth/auth-adapters',['require','exports','module','auth','./auth-api','mout/function/bind','./user','./session'],function (require, exports, module) {
/**
 * @fileoverview Auth delegate adapters for old to new delegates.
 */
var auth = require('auth');
var authApi = require('./auth-api');
var bind = require('mout/function/bind');
var LivefyreUser = require('./user');
var session = require('./session');

/**
 * @typedef {Object} OldAuthDelegate
 * @property {function()} login
 * @property {function()} logout
 * @property {function()} viewProfile
 * @property {function()} editProfile
 * @property {function()} loginByCookie
 */

/**
 * @typedef {Object} AuthDelegate
 * @property {function()} login
 * @property {function()} logout
 * @property {function()} viewProfile
 * @property {function()} editProfile
 * @property {fucntion()} destroy
 */

/**
 * @typedef {Object} BetaAuthDelegate
 * @property {function()} login
 * @property {function()} logout
 * @property {function()} viewProfile
 * @property {function()} editProfile
 * @property {function()} restoreSession
 * @property {string} serverUrl
 */

/**
 *
 * @param {AuthDelegate|OldAuthDelegate} delegate
 * @return {boolean}
 */
function isFyreOld(delegate) {
    var isDelegateOld = typeof delegate.loginByCookie === 'function';
    var doesFyreExist = window.fyre && typeof window.fyre.conv === 'object';
    return !!isDelegateOld && !!doesFyreExist;
}

/**
 * The livefyre delegate from Sidenotes beta days
 * see https://github.com/Livefyre/auth-delegates
 * @param {AuthDelegate|BetaAuthDelegate} delegate
 * @return {boolean}
 */
function isBetaDelegate(delegate) {
    var hasRestoreSession = typeof delegate.restoreSession === 'function';
    var hasLivefyreUser = window.Livefyre && typeof window.Livefyre.user === 'object';
    return hasRestoreSession && hasLivefyreUser;
}

/**
 *
 * @param {AuthDelegate|OldAuthDelegate|BetaAuthDelegate} delegate
 * @return {boolean}
 */
function isOld(delegate) {
    return isFyreOld(delegate) || isBetaDelegate(delegate);
}

function adaptBetaDelegate(delegate) {
    var newDelegate = {};
    var Livefyre = window.Livefyre;

    function callbackHandler(callback, args) {
        if (typeof callback === 'function') {
            callback.apply(this, null, args);
        }
    }

    function handleLogin(userInfo) {
        var user = new LivefyreUser();
        // Store the serverUrl
        // TODO(jj): I am kicking myself due to this pattern of copying around the serverUrl
        // b/c it has become spaghetti code
        userInfo.serverUrl = delegate.serverUrl;
        user = authApi.updateUser(user, userInfo);
        auth.login({
            livefyre: user
        });
    }

    function handleLogout() {
        auth.emit('logout');
    }

    Livefyre.user.on('login', handleLogin);
    Livefyre.user.on('logout', handleLogout);

    newDelegate.login = (function () {
        var originalFn = delegate.login;
        return function (callback) {
            originalFn.call(delegate);
            Livefyre.user.once('login', function (userInfo) {
                callbackHandler(callback, [userInfo]);
            });
        };
    })();

    newDelegate.logout = (function () {
        var originalFn = delegate.logout;
        return function (callback) {
            originalFn.call(delegate);
            Livefyre.user.once('logout', function () {
                callbackHandler(callback);
            });
        };
    })();

    newDelegate.viewProfile = bind(delegate.viewProfile, delegate);

    newDelegate.editProfile = bind(delegate.editProfile, delegate);

    newDelegate.destroy = function () {
        Livefyre.user.removeListener('login', handleLogin);
        Livefyre.user.removeListener('logout', handleLogout);
        delegate.destroy();
    };

    return newDelegate;
}

function adaptOldDelegate(delegate) {
    var fyre = window.fyre;

    function handleChangeToken(user, token) {
        if (!token) {
            return auth.emit('logout');
        }
        auth.login({
            livefyre: session.get()
        });
    }

    fyre.conv.user.on('change:token', handleChangeToken);

    if (fyre.conv.user.id) {
        if (!auth.get('livefyre')) {
            handleChangeToken(fyre.conv.user.get('token'));
        }
    }

    var handler = {
        success: function () {},
        failure: function () {}
    };
    function callbackHandler(callback) {
        return {
            success: function () {
                if (typeof callback === 'function') {
                    callback.apply(this, null, arguments);
                }
            },
            failure: function () {
                if (typeof callback === 'function') {
                    callback.apply(this, arguments);
                }
            }
        };
    }
    var slice = Array.prototype.slice;

    var newDelegate = {};

    newDelegate.login = (function () {
        var originalFn = delegate.login;
        return function (callback) {
            originalFn.call(delegate, callbackHandler(callback));
        };
    })();

    newDelegate.logout = (function () {
        var originalFn = delegate.logout;
        return function (callback) {
            originalFn.call(delegate, handler);
            callback();
        };
    })();

    newDelegate.viewProfile = (function () {
        var originalFn = delegate.viewProfile;
        return function () {
            var args = slice.call(arguments);
            args.unshift(handler);
            originalFn.apply(delegate, args);
        };
    })();

    newDelegate.editProfile = (function () {
        var originalFn = delegate.editProfile;
        return function () {
            var args = slice.call(arguments);
            args.unshift(handler);
            originalFn.apply(delegate, args);
        };
    })();

    newDelegate.destroy = function () {
        fyre.conv.user.off('change:token', handleChangeToken);
    };

    delegate.loginByCookie(handler);

    return newDelegate;
}

/**
 * Fill in interface for old delegate to new delegate.
 * @param {OldAuthDelegate} delegate
 * @param {string} articleId
 * @param {string} siteId
 * @param {string} networkId
 * @param {string} environment
 */
function oldToNew(delegate) {
    if (isBetaDelegate(delegate)) {
        return adaptBetaDelegate(delegate);
    } else if (isFyreOld(delegate)) {
        return adaptOldDelegate(delegate);
    } else {
        return delegate;
    }
}

module.exports = {
    oldToNew: oldToNew,
    isOld: isOld
};

});

define('annotations/util/selector',['require','exports','module','jquery','hgn!templates/blocks/elementwrap'],function (require, exports, module) {/**
 * @fileOverview Parse selectors.
 */

var $ = require('jquery');
var wrap = require('hgn!templates/blocks/elementwrap');

/** @type {Object} */
var util = {};

/** @enum {string} */
var TYPES = {
    ARRAY: 'Array',
    ELEMENT: 'Element',
    JQUERY: 'Jquery',
    OBJECT: 'Object',
    STRING: 'String'
};

var ALL = [TYPES.JQUERY, TYPES.STRING, TYPES.ARRAY, TYPES.ELEMENT, TYPES.OBJECT];
var ARRAY_SUPPORTS = [TYPES.JQUERY, TYPES.STRING, TYPES.ELEMENT];
var OBJECT_INCLUDE_SUPPORTS = [TYPES.JQUERY, TYPES.STRING, TYPES.ARRAY];
var OBJECT_EXCLUDE_SUPPORTS = [TYPES.JQUERY, TYPES.STRING];

/**
 * Process array selectors. This loops through all supported objects that an
 * array supports and processes them. If none of them are successful, this
 * returns null.
 * @param {Array.<jQuery|string|Element|Node>|HTMLCollection|*} selectors
 * @return {?Array.<Element>}
 */
util.processArray = function (selectors) {
    if (!(selectors instanceof HTMLCollection) &&
        !(selectors instanceof NodeList) &&
        !$.isArray(selectors)) {
        return null;
    }

    var processed;
    var results = [];
    $.each(selectors, function(i, item) {
        processed = process(item, ARRAY_SUPPORTS);
        if (processed) {
            results.push(processed);
        }
    });

    // No results
    if (!results.length) {
        return null;
    }

    // Flatten the results array.
    var reduced = [];
    $.each(results, function (i, result) {
        reduced = reduced.concat(result);
    });
    return reduced;
};

/**
 * Process an element or text node. If the provided item is an Element, it is
 * converted into a jQuery object and returned. If it is a text node, it is
 * wrapped in a SPAN, converted to a jQuery object and returned.
 * @param {Element|Node|*} item
 * @return {?Element}
 */
util.processElement = function (item) {
    if (!(item instanceof Node)) {
        return null;
    }
    if (item.nodeName === '#text') {
        var elem = $(wrap({content: item.nodeValue}))[0];
        item.parentNode.replaceChild(elem, item);
        return elem;
    }
    return item;
};

/**
 * Process a jQuery element. If it's a valid jQuery object, pass it right
 * through. If it's not, return null;
 * @param {jQuery|*} selectors
 * @return {?Array.<Element>}
 */
util.processJquery = function (selectors) {
    if (selectors instanceof $) {
        return selectors.toArray();
    }
    return null;
};

/**
 * Process an object. This is required to have an `include` argument and can
 * optionally have an `exclude` argument. If it's not valid, it returns null.
 * @param {Object.<string, jQuery|string|Array|*>} selectors
 * @return {?Array.<Element>}
 */
util.processObject = function (selectors) {
    if (typeof selectors !== 'object') {
        return null;
    }
    if (!selectors.include) {
        return null;
    }

    var include = process(selectors.include, OBJECT_INCLUDE_SUPPORTS);
    if (!include) {
        return null;
    }

    var exclude = '';
    if (selectors.exclude) {
        exclude = process(selectors.exclude, OBJECT_EXCLUDE_SUPPORTS);
    }

    return $(include).not(exclude).toArray();
};

/**
 * Process a string selector. If the selector is a string, convert it into a
 * jQuery object.
 * @param {*} selectors
 * @return {?Array.<Element>}
 */
util.processString = function (selectors) {
    if (typeof selectors === 'string') {
        return $(selectors).toArray();
    }
    return null;
};

/**
 * Processor function map.
 * @type {Object.<string, function()>}
 */
var PROCESSOR_MAP = (function () {
    var map = {};
    map[TYPES.ARRAY] = util.processArray;
    map[TYPES.ELEMENT] = util.processElement;
    map[TYPES.JQUERY] = util.processJquery;
    map[TYPES.OBJECT] = util.processObject;
    map[TYPES.STRING] = util.processString;
    return map;
})();

/**
 * Processes all supported attribute types for a particular selector. It uses
 * the PROCESSOR_MAP to find the processor that needs to be used per supported
 * object type. If none of the processors return a valid selector, returns null.
 * @param {jQuery|string|Array|Object} selectors
 * @param {Array.<string>} supported
 * @return {?jQuery}
 */
function process (selectors, supported) {
    var result;
    for (var i=0, len=supported.length; i<len; i++) {
        result = PROCESSOR_MAP[supported[i]](selectors);
        if (result) {
            return result;
        }
    }
    return null;
}

/**
 * Parse the provided selectors.
 * @param {Array.<Element>|Object|string} selectors
 * @return {jQuery.Element}
 */
util.parseSelectors = function (selectors) {
    var result = process(selectors, ALL);
    if (!result) {
        throw new TypeError('Provided selector: "' + selectors + '" is not supported.');
    }
    return $(result);
};

/**
 * Parse the provided selectors and return the first element matched.
 * @param {Array.<Element>|Object|string} selectors
 * @return {Element}
 */
util.matchElement = function (selectors) {
    return util.parseSelectors(selectors)[0];
};

module.exports = util;

});

define('annotations/util/style',['require','exports','module','jquery','streamhub-sdk/debug'],function (require, exports, module) {/**
 * @fileOverview Custom style parser/applier.
 */

var $ = require('jquery');
var debug = require('streamhub-sdk/debug');

var log = debug('annotations');
var util = {};

/**
 * Map of user-friendly property names to the actual CSS property names.
 * @type {Object.<string, string>}
 */
var PROPERTY_MAP = {
    backgroundColor: ['background-color'],
    border: ['border'],
    borderRadius: [null, borderRadius],
    fontColor: ['color'],
    fontFamily: ['font-family'],
    fontSize: ['font-size', convertPixel],
    fontWeight: ['font-weight'],
    height: ['height'],
    left: ['left'],
    lineHeight: ['line-height'],
    padding: ['padding'],
    position: ['position'],
    right: ['right'],
    top: ['top'],
    width: ['width']
};

/** @enum {string} */
var ELEMENT = {
    BLOCK_BTN: 'blockBtn',
    BLOCK_BTN_ACTIVE: 'blockBtnActive',
    MEDIA_BLOCK_BTN: 'mediaBlockBtn',
    MEDIA_BLOCK_BTN_ACTIVE: 'mediaBlockBtnActive',
    ANONYMOUS_AVATAR: 'anonymousAvatar',
    USER_AVATAR: 'userAvatar',
    POPOVER: 'popover',
    POPOVER_ARROW_LEFT: 'popoverArrowLeft',
    POPOVER_ARROW_RIGHT: 'popoverArrowRight',
    POPOVER_ARROW_TOP: 'popoverArrowTop',
    EDITOR: 'editorTextarea',
    STREAM_QUEUE_BTN: 'streamQueueButton',
    POWERED_BY: 'streamPoweredBy',
    COMMENT_AVATAR: 'commentAvatar',
    COMMENT_BODY: 'commentBody',
    COMMENT_DISPLAY_NAME: 'commentDisplayName',
    COMMENT_TAGS: 'commentTags',
    COMMENT_UPVOTE: 'commentUpvote',
    COMMENT_DOWNVOTE: 'commentDownvote',
    COMMENT_REPLIES_EXPAND: 'commentReplyExpand',
    COMMENT_REPLY_AVATAR: 'replyAvatar',
    NUM_SIDENOTES: 'numSidenotes',
    NUM_SIDENOTES_POPOVER: 'numSidenotesPopover'
};

/**
 * Map of element to CSS selector.
 * @enum {string}
 */
var ELEMENT_TO_SELECTOR = (function() {
    var map = {};
    map[ELEMENT.BLOCK_BTN] = '.lf-thread-btn';
    map[ELEMENT.BLOCK_BTN_ACTIVE] = '.lf-thread-btn:hover, .lf-thread-btn.lf-active';
    map[ELEMENT.MEDIA_BLOCK_BTN] = '.lf-media-wrapper .lf-thread-btn';
    map[ELEMENT.MEDIA_BLOCK_BTN_ACTIVE] = [
        '.lf-media-wrapper .lf-thread-btn:hover',
        '.lf-media-wrapper .lf-thread-btn.lf-active'
    ].join(',');
    map[ELEMENT.ANONYMOUS_AVATAR] = '.lf img.lf-anon-avatar';
    map[ELEMENT.USER_AVATAR] = '.lf .lf-thread > img.lf-author-avatar';
    map[ELEMENT.POPOVER] = '.lf-thread-popover';
    map[ELEMENT.POPOVER_ARROW_LEFT] = '.lf-pos-right > .lf-popover-arrow';
    map[ELEMENT.POPOVER_ARROW_RIGHT] = '.lf-pos-left > .lf-popover-arrow';
    map[ELEMENT.POPOVER_ARROW_TOP] = '.lf-pos-bottom > .lf-popover-arrow';
    map[ELEMENT.EDITOR] = '.lf textarea.lf-editor-field';
    map[ELEMENT.STREAM_QUEUE_BTN] = '.lf .lf-thread > .lf-queue-btn';
    map[ELEMENT.POWERED_BY] = '.lf .lf-thread .lf-powered-by';
    map[ELEMENT.COMMENT_AVATAR] = '.lf article.lf-comment .lf-comment-author-avatar';
    map[ELEMENT.COMMENT_BODY] = '.lf article.lf-comment .lf-comment-body p';
    map[ELEMENT.COMMENT_DISPLAY_NAME] = '.lf article.lf-comment .lf-comment-author-name';
    map[ELEMENT.COMMENT_TAGS] = '.lf article.lf-comment .lf-tag';
    map[ELEMENT.COMMENT_UPVOTE] = [
        '.lf article.lf-comment .lf-comment-footer .lf-votes.lf-upvote .lf-count',
        '.lf article.lf-comment .lf-comment-footer .lf-votes.lf-upvote .lf-upvote'
    ].join(',');
    map[ELEMENT.COMMENT_DOWNVOTE] = [
        '.lf article.lf-comment .lf-comment-footer .lf-votes.lf-downvote .lf-count',
        '.lf article.lf-comment .lf-comment-footer .lf-votes.lf-downvote .lf-downvote'
    ].join(',');
    map[ELEMENT.COMMENT_REPLIES_EXPAND] = '.lf article.lf-comment .lf-reply-container .lf-queue-btn';
    map[ELEMENT.COMMENT_REPLY_AVATAR] = '.lf article.lf-comment.lf-reply .lf-comment-author-avatar';
    map[ELEMENT.NUM_SIDENOTES] = '.lf-num-sidenotes';
    map[ELEMENT.NUM_SIDENOTES_POPOVER] = '.lf-question-popover';
    return map;
})();

/**
 * Standard block btn properties.
 * @type {Array.<string>}
 */
var BLOCK_BTN_PROPERTIES = ['border', 'borderRadius', 'fontColor', 'fontSize',
    'height', 'left', 'lineHeight', 'padding', 'position', 'right', 'top', 'width'];

/**
 * Standard font properties.
 * @type {Array.<string>}
 */
var FONT_PROPERTIES = ['fontColor', 'fontFamily', 'fontSize', 'fontWeight', 'lineHeight'];

/**
 * Standard properties for the popover arrows.
 * @type {Array.<string>}
 */
var POPOVER_ARROW_PROPERTIES = ['backgroundImage', 'height', 'left', 'right', 'top', 'width'];

/**
 * Standard QueueButton properties.
 * @const {Array.<string>}
 */
var QUEUE_BUTTON_PROPERTIES = $.merge(
    ['backgroundColor', 'borderColor', 'borderWidth'], FONT_PROPERTIES);

/**
 * Standard NumComments and QuestionPopover properties.
 * @const {Array.<string>}
 */
var NUM_SIDENOTES_PROPERTIES = $.merge(
    ['backgroundColor', 'borderColor', 'borderWidth', 'height', 'width'], FONT_PROPERTIES);

/**
 * Map of element to supported properties.
 * @enum {string}
 */
var ELEMENT_TO_PROPERTIES = (function() {
    var map = {};
    map[ELEMENT.BLOCK_BTN] = BLOCK_BTN_PROPERTIES;
    map[ELEMENT.BLOCK_BTN_ACTIVE] = BLOCK_BTN_PROPERTIES;
    map[ELEMENT.MEDIA_BLOCK_BTN] = BLOCK_BTN_PROPERTIES;
    map[ELEMENT.MEDIA_BLOCK_BTN_ACTIVE] = BLOCK_BTN_PROPERTIES;
    map[ELEMENT.ANONYMOUS_AVATAR] = ['height', 'width'];
    map[ELEMENT.USER_AVATAR] = ['height', 'width'];
    map[ELEMENT.POPOVER] = ['backgroundColor'];
    map[ELEMENT.POPOVER_ARROW_LEFT] = POPOVER_ARROW_PROPERTIES;
    map[ELEMENT.POPOVER_ARROW_RIGHT] = POPOVER_ARROW_PROPERTIES;
    map[ELEMENT.POPOVER_ARROW_TOP] = POPOVER_ARROW_PROPERTIES;
    map[ELEMENT.EDITOR] = $.extend(['height', 'width'], FONT_PROPERTIES);
    map[ELEMENT.STREAM_QUEUE_BTN] = QUEUE_BUTTON_PROPERTIES;
    map[ELEMENT.POWERED_BY] = ['backgroundColor', 'borderColor', 'lineHeight'];
    map[ELEMENT.COMMENT_AVATAR] = ['height', 'width'];
    map[ELEMENT.COMMENT_BODY] = FONT_PROPERTIES;
    map[ELEMENT.COMMENT_DISPLAY_NAME] = FONT_PROPERTIES;
    map[ELEMENT.COMMENT_TAGS] = FONT_PROPERTIES;
    map[ELEMENT.COMMENT_UPVOTE] = ['fontColor', 'fontSize'];
    map[ELEMENT.COMMENT_DOWNVOTE] = ['fontColor', 'fontSize'];
    map[ELEMENT.COMMENT_REPLIES_EXPAND] = QUEUE_BUTTON_PROPERTIES;
    map[ELEMENT.COMMENT_REPLY_AVATAR] = ['height', 'width'];
    map[ELEMENT.NUM_SIDENOTES] = NUM_SIDENOTES_PROPERTIES;
    map[ELEMENT.NUM_SIDENOTES_POPOVER] = NUM_SIDENOTES_PROPERTIES;
    return map;
})();

/**
 * Build the border radius mapping.
 * @param {number|string} px The pixel value.
 * @return {string} Border radius.
 */
function borderRadius(px) {
    var radius = [];
    radius.push('-webkit-border-radius:' + px + ' !important;');
    radius.push('-moz-border-radius:' + px + ' !important;');
    radius.push('border-radius:' + px + ' !important;');
    return radius.join('');
}

/**
 * Convert a pixel value to a string with "px" on the end.
 * @param {number|string} px The pixel value.
 * @return {string} Converted string value.
 */
function convertPixel(px) {
    if (typeof(px) === 'number') {
        return px + 'px';
    }
    return px;
}

/**
 * Determines if a provided element is supported.
 * @param {string} elem Name of the element to check.
 * @return {boolean} If the element is supported or not.
 */
function isSupportedElement(elem) {
    return elem in ELEMENT_TO_PROPERTIES;
}

/**
 * Determines if a provided property is supported for the specific element.
 * @param {string} elem Name of the element to check.
 * @param {string} prop Name of the property to check.
 * @return {boolean} If the property is supported for the element.
 */
function isSupportedProperty(elem, prop) {
    return ELEMENT_TO_PROPERTIES[elem].indexOf(prop) > -1;
}

/**
 * Apply the styles onto the head. This is purely for testing purposes.
 * @param {string} css The CSS to add to the head.
 */
util.applyStyles = function (css) {
    $('head').append($('<style type="text/css">' + css + '</style>'));
};

/**
 * @typedef StyleRuleSet {Object.<string, string|number>}
 */

/**
 * @typedef StyleSet {Object.<string, Array.<StyleRuleSet>>}
 */

/**
 * Parse the provided custom styles.
 * @param {StyleSet} styles
 * @return {Object} parsedStyles
 */
util.parseStyles = function (styles) {
    var css = '';
    var propSet;
    var properties;

    $.each(styles, function(key, ruleSet) {
        if (!isSupportedElement(key)) {
            log(['Element', key, 'is not supported.'].join(' '));
            return;
        }

        properties = [];
        $.each(ruleSet, function(property, value) {
            if (!isSupportedProperty(key, property)) {
                log(['Property (', property, ') is not supported for element', key].join(' '));
                return;
            }
            propSet = PROPERTY_MAP[property];

            // If there is no proeprty name, then call the function because
            // it will be handled in the processor function.
            if (!propSet[0]) {
                properties.splice(properties.length, 0, propSet[1](value));
                return;
            }
            properties.splice(properties.length, 0, propSet[0], ':');
            value = propSet[1] ? propSet[1](value) : value;
            properties.splice(properties.length, 0, value, ' !important;');
        });

        if (properties.length === 0) {
            return;
        }

        properties.splice(0, 0, ELEMENT_TO_SELECTOR[key], '{');
        properties.push('}');
        css += properties.join('');
    });

    css && util.applyStyles(css);
};

module.exports = util;

});

define("hgn!templates/blocks/thread-btn-override", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<style type=\"text/css\">");_.b("\n" + i);_.b("    .lf-thread-btn:before {");_.b("\n" + i);_.b("        background-image: url('");_.b(_.v(_.f("customIcon",c,p,0)));_.b("') !important;");_.b("\n" + i);_.b("        background-size: ");_.b(_.v(_.d("customIconCfg.width",c,p,0)));_.b("px ");_.b(_.v(_.d("customIconCfg.height",c,p,0)));_.b("px !important;");_.b("\n" + i);_.b("        content: \" \" !important;");_.b("\n" + i);_.b("        height: ");_.b(_.v(_.d("customIconCfg.height",c,p,0)));_.b("px !important;");_.b("\n" + i);_.b("        margin-left: ");_.b(_.v(_.d("customIconCfg.marginLeft",c,p,0)));_.b("px !important;");_.b("\n" + i);_.b("        margin-right: ");_.b(_.v(_.d("customIconCfg.marginRight",c,p,0)));_.b("px !important;");_.b("\n" + i);_.b("        margin-top: ");_.b(_.v(_.d("customIconCfg.marginTop",c,p,0)));_.b("px !important;");_.b("\n" + i);_.b("        width: ");_.b(_.v(_.d("customIconCfg.width",c,p,0)));_.b("px !important;");_.b("\n" + i);_.b("    }");_.b("\n" + i);_.b("</style>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/config',['require','exports','module','jquery','auth','livefyre-auth/auth-adapters','base64','annotations/util/selector','annotations/util/style','annotations/i18n/enumeration','annotations/util/useragent','hgn!templates/blocks/thread-btn-override'],function (require, exports, module) {/**
 * @fileoverview Parse configuration object, checking to ensure the app has what
 * it needs to do work.
 */

var $ = require('jquery');
var ASSET_SERVER = '//cdn.livefyre.com/libs/sidenotes/v0.1.0-beta';
var auth = require('auth');
var CDN = '//cdn.livefyre.com';
var authAdapter = require('livefyre-auth/auth-adapters');
var base64 = require('base64');
var selectorUtil = require('annotations/util/selector');
var styleUtil = require('annotations/util/style');
var textEnumeration = require('annotations/i18n/enumeration');
var UserAgentUtil = require('annotations/util/useragent');

/** @const {number} */
var CUSTOM_ICON_CFG = {
    height: 12,
    marginLeft: 6,
    marginRight: 2,
    marginTop: 1,
    width: 12
};

/** @enum {string} */
var ERRORS = {
    ARTICLE_ID: 'articleId should be in collectionMeta or configuration',
    AUTH: 'auth',
    COLLECTION_META: 'collectionMeta',
    DELEGATE: 'auth delegate',
    META: 'The signed collectionMeta is not a properly formed JWT',
    META_PARSE: 'collectionMeta does not parse properly',
    MISSING: 'missing from Annotations App config',
    SELECTOR: 'selectors string, object, or element(s)',
    SITE_ID: 'siteId should be in collectionMeta or configuration',
    SUPPORTED_POSITION: 'invalid placement, supported placements are: ',
    SUPPORTED_VISIBILITY: 'invalid icon visibility, supported visibilities are: '
};

/**
 * Supported list of placement values.
 * @type {Array.<string>}
 */
var SUPPORTED_POSITION = ['smart', 'left', 'right', 'bottom'];

/**
 * Supported list of icon visibility values.
 * @type {Array.<string>}
 */
var SUPPORTED_VISIBILITY = ['hover', 'static'];

/**
 * Parses the iconVisibility config option. Returns an empty object if value
 * was not provided or falsy. If the value is a string, it will set that value
 * for both the empty and num cases. If the value is an object, it just needs
 * to validate the values first.
 * @param {Object|string=} vis The iconVisibility value.
 * @return {Object}
 * @throws {TypeError} If value is not supported.
 */
function parseIconVisibility(vis) {
    if (!vis) {
        return {empty: 'static', num: 'static'};
    }

    /**
     * Validate the icon visibility value. Throws a TypeError if invalid.
     * @param {*} val The value to check.
     * @throws {TypeError} If value is not supported.
     */
    function validate(val) {
        if ($.inArray(val, SUPPORTED_VISIBILITY) === -1) {
            throw new TypeError(ERRORS.SUPPORTED_VISIBILITY + SUPPORTED_VISIBILITY.join(', '));
        }
    }

    var result = vis;
    if (typeof vis === 'string') {
        result = {empty: vis, num: vis};
    }
    validate(result.empty);
    validate(result.num);
    return result;
}

/**
 * Throw error message.
 * @param {string} msg
 * @throws {TypeError}
 */
function throwErr(msg) {
    throw new TypeError([msg, ERRORS.MISSING].join(' '));
}

/** @type {Object} */
var util = {};

/** @type {Object} */
util.data = {
    assetServer: ASSET_SERVER,
    cdn: CDN
};

util.parseCollMeta = function (encodedMeta) {
    var parts = encodedMeta.split('.');
    if (parts.length < 3) {
        throw new TypeError(ERRORS.META);
    }

    var decodedMeta;
    try {
        decodedMeta = JSON.parse(base64.url.atob(parts[1]));
    } catch(e) {
        throw new TypeError(ERRORS.META_PARSE);
    }
    return decodedMeta;
};

/**
 * @param {Object} config
 * @return {Object}
 * @throws {TypeError}
 */
util.parseConfig = function (config) {
    var data = {};
    var originalMeta = config.collectionMeta;
    var collectionMeta = config.collectionMeta || throwErr(ERRORS.COLLECTION_META);

    if (typeof collectionMeta === 'string') {
        collectionMeta = util.parseCollMeta(collectionMeta);
    }

    // The container element for the threads
    if (config.threadContainerEl) {
        data.threadContainerEl = selectorUtil.matchElement(config.threadContainerEl);
    }

    // Placement of annotations (smart, left, right, bottom)
    if (typeof config.position === 'string') {
        if ($.inArray(config.position, SUPPORTED_POSITION) === -1) {
            throw new TypeError(ERRORS.SUPPORTED_POSITION + SUPPORTED_POSITION.join(', '));
        }
        data.position = config.position;
    }

    // Custom annotations icon
    if (typeof config.customIcon === 'string') {
        // TODO: I don't think it's a great idea to do this.
        $('head').append(require('hgn!templates/blocks/thread-btn-override')({
            customIcon: config.customIcon,
            customIconCfg: $.extend({}, CUSTOM_ICON_CFG, config.customIconCfg)
        }));
    }

    // Visibility of icon (hover or static)
    data.iconVisibility = parseIconVisibility(config.iconVisibility);

    // Don't start the stream in cases where custom developers will want to
    // start/stop it manually.
    if (typeof config.disableStream === 'boolean') {
        data.disableStream = config.disableStream;
    }
    // Stream events disabled (for now) in Mobileland
    if (!config.disableStream && UserAgentUtil.isMobile()) {
        data.disableStream = true;
    }

    // Parse and apply the custom styles.
    if (typeof config.customStyles === 'object') {
        styleUtil.parseStyles(config.customStyles || {});
    }

    // Optional comment count element
    if (config.numSidenotesEl) {
        data.numSidenotesEl = selectorUtil.matchElement(config.numSidenotesEl);
    }

    // Optional thread button delegate
    if (typeof config.threadBtnDelegate === 'function') {
        data.threadBtnDelegate = config.threadBtnDelegate;
    }

    var articleId = collectionMeta.articleId ||
                    config.articleId ||
                    config.collection.siteId ||
                    throwErr(ERRORS.ARTICLE_ID);
    var siteId = collectionMeta.siteId ||
                 config.siteId ||
                 config.collection.siteId ||
                 throwErr(ERRORS.SITE_ID);
    var networkId = collectionMeta.network ||
                    config.network ||
                    config.collection.network ||
                    'livefyre.com';

    var environment = collectionMeta.environment || config.environment || null;

    if (config.authDelegate && authAdapter.isOld(config.authDelegate)) {
        auth.delegate(authAdapter.oldToNew(config.authDelegate));
        if (window.fyre && window.fyre.conv) {
            // if comments is not here, we will need to initialize auth
            fyre.conv.initializeGlobalServices({
               articleId: articleId,
               siteId: siteId,
               networkId: networkId,
               authDelegate: config.authDelegate
            });

            if (!fyre.conv.ready.hasFired()) {
                fyre.conv.ready.trigger();
            }
        }
    }

    var strings = config.strings || {};
    textEnumeration.set(strings);

    // Option for our bookmarklet
    if (config.selectors === 'option.selectors_prompt') {
        config.selectors = window.prompt('Enter the anchor selectors for Sidenotes',
            '.article > p');
    }

    return $.extend(data, {
        collection: config.collection || {
            articleId: articleId,
            network: networkId,
            siteId: siteId,
            environment: environment
        },
        collectionMeta: originalMeta,
        defaultAvatar: ASSET_SERVER + '/images/default-avatar.png',
        selectors: selectorUtil.parseSelectors(config.selectors),
        selectorString: config.selectors,
        servers: {
            assets: ASSET_SERVER,
            cdn: CDN
        },
        strings: strings
    });
};

module.exports = util;

});

define('annotations/controller/external',['require','exports','module','jquery','auth','annotations/controller/base','annotations/events','inherits','observer','annotations/events'],function (require, exports, module) {/**
 * @fileOverview Comment controller.
 */

var $ = require('jquery');
var auth = require('auth');
var BaseController = require('annotations/controller/base');
var ExternalEvents = require('annotations/events').external;
var inherits = require('inherits');
var Observer = require('observer');
var WriteEvents = require('annotations/events').write;

/**
 * External events controller.
 * @param {Object} opts Config options.
 */
function ExternalController(opts) {
    BaseController.call(this, opts);

    /**
     * The Sidenotes app.
     * @type {AnnotationApp}
     * @private
     */
    this._app = opts.app;

    Observer(this);
    this.listenTo(auth, 'login.livefyre', $.proxy(this._onUserLoggedIn, this));
    this.listenTo(auth, 'logout', $.proxy(this._onUserLoggedOut, this));
}
inherits(ExternalController, BaseController);

/** @enum {string} */
ExternalController.prototype.events = (function () {
    var events = {};
    events[WriteEvents.COMMENT_FLAGGED] = '_onCommentFlagged';
    events[WriteEvents.COMMENT_POSTED] = '_onCommentPosted';
    events[WriteEvents.COMMENT_SHARED] = '_onCommentShared';
    events[WriteEvents.COMMENT_VOTED] = '_onCommentVoted';
    return events;
})();

/**
 * Handle the comment flagged event. This will emit an external event.
 * @param {jQuery.Event} ev The comment flagged event.
 * @param {Object} data The event data.
 * @private
 */
ExternalController.prototype._onCommentFlagged = function (ev, data) {
    this._app.emit(ExternalEvents.COMMENT_FLAGGED, {
        'targetId': data.messageId,
        'type': data.value
    });
};

/**
 * Handle the comment posted event. This will emit an external event.
 * @param {jQuery.Event} ev The comment posted event.
 * @param {Object} data The event data.
 * @private
 */
ExternalController.prototype._onCommentPosted = function (ev, data) {
    this._app.emit(ExternalEvents.COMMENT_POSTED, {
        'authorId': data.author.id,
        'bodyHtml': data.body,
        'parent': data.parentId
    });
};

/**
 * Handle the comment shared event. This will emit an external event.
 * @param {jQuery.Event} ev The comment shared event.
 * @param {Object} data The event data.
 * @private
 */
ExternalController.prototype._onCommentShared = function (ev, data) {
    this._app.emit(ExternalEvents.COMMENT_SHARED, {
        'targetId': data.id,
        'sharedToFacebook': data.provider === 'facebook',
        'sharedToTwitter': data.provider === 'twitter'
    });
};

/**
 * Handle the comment voted event. This will emit an external event.
 * @param {jQuery.Event} ev The comment voted event.
 * @param {Object} data The event data.
 * @private
 */
ExternalController.prototype._onCommentVoted = function (ev, data) {
    this._app.emit(ExternalEvents.COMMENT_VOTED, {
        'targetId': data.messageId,
        'targetAuthorId': data.authorId,
        'type': data.value
    });
};

/**
 * Handle the user logged in event. This will emit an external event.
 * @private
 */
ExternalController.prototype._onUserLoggedIn = function (user) {
    this._app.emit(ExternalEvents.USER_LOGGED_IN, {
        'avatar': user.get('avatar'),
        'displayName': user.get('displayName'),
        'id': user.get('id'),
        'isModerator': user.isMod({collectionId: this._collection.id})
    });
};

/**
 * Handle the user logged out event. This will emit an external event.
 * @private
 */
ExternalController.prototype._onUserLoggedOut = function () {
    this._app.emit(ExternalEvents.USER_LOGGED_OUT);
};

/** @override */
ExternalController.prototype.destroy = function () {
    BaseController.prototype.destroy.call(this);
    this.stopListening();
};

module.exports = ExternalController;

});

define('scriptloader/object',['require','exports','module'],function (require, exports, module) {/**
 * @fileOverview Object utilities.
 */

var ObjUtil = {};

/**
 * Checks an argument to see if it's an object.
 * @param {*} obj The argument to check.
 * @return {boolean}
 */
ObjUtil.isObject = function(obj) {
    return typeof(obj) === 'object' && obj !== null;
};

/**
 * Extend the first argument with keys and values from the second.
 * @param {object} obj
 * @param {object} obj2
 */
ObjUtil.extend = function(obj, obj2) {
    for (var key in obj2) {
        if (obj2.hasOwnProperty(key)) {
            obj[key] = obj2[key];
        }
    }
};

module.exports = ObjUtil;

});

define('scriptloader/scriptloader',['require','exports','module','scriptloader/object'],function (require, exports, module) {/**
 * @fileOverview Script loader.
 * @author Ross Pfahler
 */

var ObjUtil = require('scriptloader/object');

/**
 * Callback array. Tracks callbacks when scripts are loading
 * @type {Object.<string, Array>}
 */
var callbacks = {};

/**
 * Tracks scripts that have been loaded via the script loader.
 * @type {Object.<string, string>}
 */
var loaded = {};

/**
 * Loader object.
 * @type {object}
 */
var Loader = {};

/**
 * Adds a stylesheet to the page.
 * @param {string} src The url of the stylesheet to load.
 * @param {Document=} opt_doc
 * @param {Object=} opt_attrs Additional attributes to add to the link tag.
 * @param {Element=} opt_attachEl Optional element to attach the stylesheet
 */
Loader.loadCSS = function(src, opt_doc, opt_attrs, opt_attachEl) {
    var doc = opt_doc || document;
    var el = opt_attachEl ? opt_attachEl : doc.getElementsByTagName('head')[0];
    var link = doc.createElement('link');

    if (existsOnPage('link', 'href', src, doc)) {
        return;
    }

    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = src;
    link.media = 'all';

    if (ObjUtil.isObject(opt_attrs)) {
        ObjUtil.extend(link, opt_attrs);
    }

    el.appendChild(link);
};

/**
 * Adds a script to the page.
 * @param {string} src The url of the script to load.
 * @param {Document=} opt_doc
 * @param {object=} opt_attrs Additional attributes to add to the script tag.
 * @param {function()=} opt_callback
 * @param {Element=} opt_attachEl Optional element to attach the script
 */
Loader.loadScript = function(src, opt_doc, opt_attrs, opt_callback, opt_attachEl) {
    var callback = typeof(opt_callback) === 'function' ? opt_callback : function(){};
    var doc = opt_doc || document;
    var el = opt_attachEl ? opt_attachEl : doc.getElementsByTagName('head')[0];
    var script = doc.createElement('script');

    // If loaded..
    if (loaded[src]) {
        callback();
        return;
    }

    // If loading...
    if (callbacks[src]) {
        callbacks[src].push(callback);
        return;
    }

    script.type = 'text/javascript';
    script.src = src;
    script.async = true;
    script.defer = true;

    if (ObjUtil.isObject(opt_attrs)) {
        ObjUtil.extend(link, opt_attrs);
    }

    attachCallback(script, callback);
    el.appendChild(script);
};


/**
 * Attach a callback to be executed after the provided script has loaded.
 * @param {!Element} script
 * @param {!Function} callback
 */
var attachCallback = function(script, callback) {
    callbacks[script.src] = [callback];

    /** @this {Element} */
    script.onload = script.onreadystatechange = function() {
        if (!script.readyState || /loaded|complete/.test(script.readyState)) {
            executeCallbacks(script.src);
            loaded[script.src] = true;
            // IE memory leaks
            script.onload = script.onreadystatechange = null;
            script = undefined;
        }
    };
};

/** @param {!string} scriptSrc */
var executeCallbacks = function(scriptSrc) {
    var callbacks = callbacks[scriptSrc];
    if (callbacks.length) {
        for (var i=0, l=callbacks.length; i<l; i++) {
            callbacks[i]();
        }
    }
    delete callbacks[scriptSrc];
};

/**
 * Checks whether an element exists on the page with the given
 * tag having an attribute whose value contains the string val.
 * @param {string} tag The tag to use to search elements.
 * @param {string} attr The attribute to compare against the value.
 * @param {string} val The value.
 * @param {Document=} opt_doc
 * @return {boolean} If a matching element exists on the page.
 */
var existsOnPage = function(tag, attr, val, opt_doc) {
    var doc = opt_doc || document;
    var i = 0;
    var tags = doc.getElementsByTagName(tag);
    var len = tags.length;
    var element;

    // set to lowercase to support case insensitive matching
    val = val.toLowerCase();

    // Cannot use Array.prototype.some in this case because older versions of prototype.js may hijack it.
    // This only should matter when looping over array-like objects
    // (node lists, arguments, etc) rather than Arrays.
    for (; i<len; i++) {
        element = tags[i];
        if (typeof(element[attr]) === 'string' && element[attr].toLowerCase().indexOf(val) > -1) {
            return true;
        }
    }
    return false;
};

module.exports = Loader;

});

define('scriptloader', ['scriptloader/scriptloader'], function (main) { return main; });

define('annotations/user/controller',['require','exports','module','jquery','auth','base64','annotations/controller/base','inherits','annotations/events'],function (require, exports, module) {/**
 * @fileOverview User controller.
 */

var $ = require('jquery');
var auth = require('auth');
var base64 = require('base64');
var BaseController = require('annotations/controller/base');
var inherits = require('inherits');
var UserEvents = require('annotations/events').user;

/**
 * User controller.
 * @extends {BaseController}
 * @param {Object} opts Config options.
 */
function UserController(opts) {
    BaseController.call(this, opts);
}
inherits(UserController, BaseController);

/** @override */
UserController.prototype.events = (function () {
    var events = {};
    events[UserEvents.ADMIN] = '_handleAdmin';
    events[UserEvents.EDIT_PROFILE] = '_handleEditProfile';
    events[UserEvents.LOGIN] = '_handleLogin';
    events[UserEvents.LOGOUT] = '_handleLogout';
    events[UserEvents.VIEW_PROFILE] = '_handleViewProfile';
    return events;
})();

/**
 * Handle the admin event.
 * @private
 */
UserController.prototype._handleAdmin = function () {
    window.open(this._collection.generateAdminUrl());
};

/**
 * Handle the edit profile event.
 * @private
 */
UserController.prototype._handleEditProfile = function () {
    auth.editProfile();
};

/**
 * Handle the login event.
 * @private
 */
UserController.prototype._handleLogin = function () {
    auth.login();
};

/**
 * Handle the logout event.
 * @private
 */
UserController.prototype._handleLogout = function () {
    auth.logout();
};

/**
 * Handle the view profile event.
 * @param {jQuery.Event} ev
 * @param {Object} opts
 * @private
 */
UserController.prototype._handleViewProfile = function (ev, opts) {
    auth.viewProfile(opts.author);
};

/** @override */
UserController.prototype.destroy = function () {
    BaseController.prototype.destroy.call(this);
};

module.exports = UserController;

});

define('annotations/controller/body',['require','exports','module','annotations/controller/base','inherits','annotations/events'],function (require, exports, module) {/**
 * @fileOverview Listen for events on the document body and handle accordingly.
 */

var BaseController = require('annotations/controller/base');
var inherits = require('inherits');
var ThreadEvents = require('annotations/events').thread;

/**
 * Listens for events on the document body.
 * @constructor
 * @extends {BodyController}
 */
function BodyController(opts) {
    BaseController.call(this, opts);
}
inherits(BodyController, BaseController);

/** @override */
BodyController.prototype.globalEvents = {
    'mousedown.BodyController': '_handleBodyMousedown'
};

/**
 * Handle the body click event. If the popover was clicked, don't destroy.
 * @private
 */
BodyController.prototype._handleBodyMousedown = function() {
    this.$antenna.trigger(ThreadEvents.DESTROY_THREAD);
};

module.exports = BodyController;

});

define('annotations/mobile/controller/body',['require','exports','module','jquery','annotations/controller/body','view/delegate','inherits','annotations/events'],function (require, exports, module) {/**
 * @fileOverview Listen for events on the document body and handle accordingly.
 */

var $ = require('jquery');
var BodyController = require('annotations/controller/body');
var delegate = require('view/delegate');
var inherits = require('inherits');
var ThreadEvents = require('annotations/events').thread;

/**
 * Listens for events on the document body.
 * @constructor
 * @extends {BodyController}
 */
function MobileBodyController(opts) {
    BodyController.call(this, opts);

    /**
     * @type {boolean}
     * @private
     */
    this._isScrolling = false;

    /**
     * @type {?number}
     * @private
     */
    this._onScrollStop = null;

    // The equivalent listener on the body does not work in Chrome
    // (which is, ironically, the browser that needs to use this event)
    delegate.delegateEvents($(document), {
        'scroll': '_handleOnScoll'
    }, this._uid, this);
}
inherits(MobileBodyController, BodyController);

/** @const {number} */
MobileBodyController.SCROLL_DELAY = 250;

/** @override */
MobileBodyController.prototype.globalEvents = (function () {
    var events = {};
    events['touchend'] = '_handleScrollEnd';
    events['touchstart'] = '_handleScrollStart';
    return events;
})();

/**
 * This event is used for Chrome and browsers that do not reliably fired a touchend.
 * @private
 */
MobileBodyController.prototype._handleOnScoll = function () {
    var self = this;
    this._onScrollStop && clearTimeout(this._onScrollStop);
    this._onScrollStop = setTimeout(function () {
        self._handleScrollEnd();
    }, MobileBodyController.SCROLL_DELAY);
};

/**
 * Handle the scroll start
 * @private
 */
MobileBodyController.prototype._handleScrollStart = function () {
    if (this._isScrolling) {
        return;
    }
    this._isScrolling = true;
    this.$antenna.trigger(ThreadEvents.TUCK_THREAD);
};

/**
 * Handle the scroll end
 * @private
 */
MobileBodyController.prototype._handleScrollEnd = function () {
    if (this._isScrolling) {
        this.$antenna.trigger(ThreadEvents.UNTUCK_THREAD);
    }
    this._isScrolling = false;
};

/** @override */
MobileBodyController.prototype.destroy = function () {
    BodyController.prototype.destroy.call(this);
    delegate.undelegateEvents($(document), this._uid);
};

module.exports = MobileBodyController;

});

define('streamhub-editor/util',['require','exports','module'],function (require, exports, module) {/**
 * @fileoverview Util functions that are useful the other modules.
 */

var util = {};

/**
 * Abstract function. This is wicked awesome for ensuring that all of the
 * functions get overridden when using the inheritance pattern.
 */
util.abstractMethod = function() {
    throw 'Function must be implemented.';
};

module.exports = util;

});

define('streamhub-editor/editor',['require','exports','module','jquery','view/event-map','inherits','streamhub-editor/util','view'],function (require, exports, module) {/**
 * @fileOverview The editor view class. This contains the editor box and any
 * buttons that go along with it.
 */

var $ = require('jquery');
var EventMap = require('view/event-map');
var inherits = require('inherits');
var util = require('streamhub-editor/util');
var View = require('view');

/**
 * Editor view.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
var Editor = function(opts) {
    View.call(this, opts);
};
inherits(Editor, View);

/** @enum {string} */
Editor.prototype.classes = {
    FIELD: 'editor-field',
    POST_BTN: 'editor-post-btn'
};

/** @enum {string} */
Editor.prototype.errors = {
    BODY: 'Please enter a body'
};

/**
 * Build the post event object that will be dispatched from the editor.
 * @return {Object} The post event object.
 */
Editor.prototype.buildPostEventObj = function() {
    var event = {};
    event.body = this.$textareaEl.val();
    event.failure = $.proxy(this.handlePostFailure, this);
    event.success = $.proxy(this.handlePostSuccess, this);
    return event;
};

/** @override */
Editor.prototype.events = new EventMap((function() {
    var classes = Editor.prototype.classes;
    var events = {};
    events['click .' + classes.POST_BTN] = 'handlePostBtnClick';
    return events;
})());

/**
 * Handle the post button click event. This should validate the data and
 * dispatch a post event that a controller can handle.
 */
Editor.prototype.handlePostBtnClick = function() {
    var data = this.buildPostEventObj();
    if (!this.validate(data)) {
        return;
    }
    this.sendPostEvent(data);
};

/**
 * Post failure callback.
 * @param {Object} data The response data.
 */
Editor.prototype.handlePostFailure = util.abstractMethod;

/**
 * Post success callback.
 * @param {Object} data The response data.
 */
Editor.prototype.handlePostSuccess = util.abstractMethod;

/** @override */
Editor.prototype.render = function() {
    View.prototype.render.call(this);
    this.$textareaEl = this.$('.' + this.classes.FIELD);
};

/**
 * Send the post event.
 * @param {Object} data The post data to send.
 */
Editor.prototype.sendPostEvent = util.abstractMethod;

/**
 * Show an error message to the user.
 * @param {string} msg The error message to display.
 */
Editor.prototype.showError = util.abstractMethod;

/**
 * Validate the post data.
 * @param {Object} data The post data to be validated.
 * @return {boolean} Whether the post data is valid or not.
 */
Editor.prototype.validate = function(data) {
    if (!data.body) {
        this.showError(this.errors.BODY);
        return false;
    }
    return true;
};

module.exports = Editor;

});

define('annotations/util/editor',['require','exports','module'],function (require, exports, module) {module.exports = {
    /**
     * Convert newline chars to <p> tags
     * @param {string} content
     * @returns {string}
     */
    normalizeNewlines: function (content) {
        content = content.replace(/(\s*)$/, '');
        content = '<p>' + content.split('\n').join('</p><p>') + '</p>';
        return content;
    },

    /**
     * Convert <p> tags to newline chars
     * @param {string} content
     * @returns {string}
     */
    normalizeParagraphTags: function (content) {
        content = content.replace(/<p>/g, '');
        content = content.replace(/<\/p>/g, '\n');
        // remove trailing newline
        var suffix = '\n';
        if (content.indexOf(suffix, content.length = suffix.length) !== -1) {
            content = content.slice(0, suffix.length * -1);
        }
        return content;
    },

    /**
     * Focus a textarea and place the cursor at the end of the text.
     * @param {jQuery.Element}
     */
    focusAndPlaceCursorAtEnd: function ($textareaEl) {
        var textareaEl = $textareaEl[0];
        $textareaEl.focus();
        if (textareaEl.setSelectionRange) {
            var len = $textareaEl.val().length * 2;  // * 2 works to force the final char.
            textareaEl.setSelectionRange(len, len);
        } else {
            $textareaEl.val($textareaEl.val());
        }
    }
};

});

define('annotations/thread/ui/baseeditorview',['require','exports','module','jquery','streamhub-editor/editor','inherits','annotations/util/editor','annotations/i18n/enumeration'],function (require, exports, module) {/**
 * @fileOverview The editor view class. This contains the editor box and any
 * buttons that go along with it.
 */

var $ = require('jquery');
var Editor = require('streamhub-editor/editor');
var inherits = require('inherits');
var normalizeNewlines = require('annotations/util/editor').normalizeNewlines;
var textEnumeration = require('annotations/i18n/enumeration');

/**
 * Editor view.
 * @constructor
 * @extends {Editor}
 * @param {Object} opts Config options.
 */
function BaseEditorView(opts) {
    Editor.call(this, opts);
}
inherits(BaseEditorView, Editor);

/** @enum {string} */
BaseEditorView.TYPES = {
    EDIT: 'edit',
    REPLY: 'reply',
    WRITE: 'write'
};

/** @type {string} */
var DRAFT_PREFIX = 'draft-';

/** @type {Object} */
var DRAFTS = {};

/** @enum {string} */
BaseEditorView.ERRORS = {
    BODY: 'Please enter a body',
    GENERIC: 'There was an error'
};

/**
 * Get the contents of the editor and do any processing required.
 * @return {string}
 * @private
 */
BaseEditorView.prototype._getContents = function () {
    var content = this.$textareaEl.val();
    return normalizeNewlines(content);
};

/**
 * Build the post event object that will be dispatched from the editor.
 * @return {Object} The post event object.
 * @override
 */
BaseEditorView.prototype.buildPostEventObj = function () {
    return {
        body: this._getContents(),
        callback: $.proxy(this._handlePostComplete, this),
        model: this.opts.model,
        parentId: this.opts.parentId,
        shareTypes: []
    };
};

/**
 * Get the draft (if there is one) for a block.
 * @param {string} editorId The ID of the block/comment to retrieve the draft for.
 * @private
 * @return {?string}
 */
BaseEditorView.prototype._getDraft = function (editorId) {
    return DRAFTS[DRAFT_PREFIX + editorId];
};

/**
 * Set the draft for a block.
 * @param {string} editorId The ID of the block/comment to add a draft for.
 * @param {string} draft The text to save in memory.
 * @private
 */
BaseEditorView.prototype._setDraft = function (editorId, draft) {
    return DRAFTS[DRAFT_PREFIX + editorId] = draft;
};

/**
 * Validate the post data.
 * @param {Object} data The post data to be validated.
 * @return {boolean} Whether the post data is valid or not.
 * @override
 */
BaseEditorView.prototype.validate = function (data) {
    var body = data.body;
    if (!body) {
        this.showError(BaseEditorView.ERRORS.BODY);
        return false;
    }
    var KEYS = textEnumeration.KEYS;
    if (body === textEnumeration.get(KEYS.EDITOR_PLACEHOLDER)) {
        this.showError(BaseEditorView.ERRORS.BODY);
        return false;
    }
    return true;
};

module.exports = BaseEditorView;

});

define('livefyre-bootstrap/loader',['require','exports','module','jquery'],function (require, exports, module) {

var $ = require('jquery');

/** @type {Object} */
var loader = {};

/** @enum {string} */
var CLASSES = {
    NOT_SUPPORTED: 'lf-not-supported'
};

/**
 * All available sizes.
 * @type {string}
 */
var SIZES = {
    MINI: 'mini',
    SMALL: 'small',
    LARGE: 'large'
};

/**
 * The classname prefix.
 * @type {string}
 */
var CLASS_PREFIX = 'lf-';

/**
 * The default size.
 * @type {string}
 */
var DEFAULT_SIZE = SIZES.SMALL;

/**
 * The DOM string of the loader.
 * @type {string}
 */
var LOADER_DOM = ['<div class="lf-loader">',
    '<div /><div /><div /><div /><div /><div /><div /><div /><div />',
    '</div>'].join('');

/**
 * List of valid string sizes.
 * @type {Array.<string>}
 */
var VALID_SIZES = [SIZES.MINI, SIZES.SMALL, SIZES.LARGE];

/**
 * Determines if the CSS version of the loader is supported.
 * @return {boolean} Whether it's supported or not.
 */
loader.isSupported = function () {
    if (navigator.userAgent.match(/MSIE ([0-9]+)\./)) {
        if (RegExp.$1 <= 9) {
            return false;
        }
    }
    return true;
};

/**
 * Creates a loader with a specific size.
 * @param {Element} elem The element to decorate with the loader.
 * @param {string|number=} opt_size The size of the loader. This can be either a
 *    string size `mini, small, large` or a number that is divisible by 3
 *    since the loader is a cube.
 */
loader.decorate = function (elem, opt_size) {
    var $loader = $(LOADER_DOM);
    $(elem).html('').append($loader);

    if (!loader.isSupported()) {
        $loader.html('').addClass(CLASSES.NOT_SUPPORTED);
        return;
    }

    if (!opt_size) {
        $loader.addClass(CLASS_PREFIX + DEFAULT_SIZE);
        return;
    }

    if (typeof opt_size === 'string') {
        // Ensure that it's a valid string value.
        if (VALID_SIZES.indexOf(opt_size) === -1) {
            opt_size = DEFAULT_SIZE;
        }

        $loader.addClass(CLASS_PREFIX + opt_size);
        return;
    }

    if (typeof opt_size === 'number') {
        // It must be divisible by 3. If it's not, use the default size.
        if (opt_size % 3 !== 0) {
            $loader.addClass(CLASS_PREFIX + DEFAULT_SIZE);
            return;
        }

        $loader.height(opt_size).width(opt_size);
        return;
    }

    throw opt_size + " is not a valid argument.";
};

module.exports = loader;

});

define("hgn!templates/thread/loader", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-loader-container\"></div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/mobile/navbar", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<button type=\"button\" class=\"lf-menu-back-btn lf-btn lf-btn-sm lf-btn-default\">");_.b(_.t(_.d("strings.backBtn",c,p,0)));_.b("</button>");_.b("\n" + i);_.b("<h3>");_.b(_.t(_.d("strings.title",c,p,0)));_.b("</h3>");_.b("\n" + i);if(_.s(_.f("actionButton",c,p,1),c,p,0,160,264,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("    <button type=\"button\" class=\"lf-menu-action-btn lf-btn lf-btn-sm\">");_.b(_.v(_.d("strings.actionBtn",c,p,0)));_.b("</button>");_.b("\n");});c.pop();}return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/thread/navigablesub", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/thread/navigable", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");if(_.s(_.f("topNavEnabled",c,p,1),c,p,0,18,88,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("    <header class=\"lf-menu-head\">");_.b("\n" + i);_.b(_.rp("navbar",c,p,"        "));_.b("    </header>");_.b("\n");});c.pop();}_.b("<div class=\"lf-menu-body\">");_.b("\n" + i);_.b(_.rp("body",c,p,"    "));_.b("</div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/navigable',['require','exports','module','inherits','annotations/util/internals','annotations/i18n/enumeration','annotations/events','annotations/util/useragent','view','hgn!templates/mobile/navbar','hgn!templates/thread/navigablesub','hgn!templates/thread/navigable'],function (require, exports, module) {/**
 * @fileOverview Navigable view. This optionally adds a nav bar on the top
 * with a back button. It fires events that the NavigableContainer listens for.
 */

var inherits = require('inherits');
var internals = require('annotations/util/internals');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;
var UserAgentUtil = require('annotations/util/useragent');
var View = require('view');

/**
 * Navigable view.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
var Navigable = function(opts) {
    View.call(this, opts);

    /**
     * @param {?string}
     */
    this._actionDesc = opts.actionDesc;

    /**
     * @param {?function()}
     */
    this._actionHandler = opts.actionHandler || internals.nullFunction;

    /**
     * The event to trigger when the user clicks the back button.
     * @type {?string}
     * @private
     */
    this._backEvent = opts.backEvent;

    /**
     * The string to use for the back button.
     * @type {?string}
     * @private
     */
    this._backStr = opts.backStr;

    /**
     * Title for the menu.
     * @param {?string}
     * @private
     */
    this._title = opts.title;

    /**
     * Allows for the removal of the top nav bar. Not every subclass will want
     * one I'm guessing.
     * @type {boolean}
     * @private
     */
    this.topNavEnabled = true;
};
inherits(Navigable, View);

/** @enum {string} */
Navigable.CLASSES = {
    ACTION_BTN: 'lf-menu-action-btn',
    BACK_BTN: 'lf-menu-back-btn',
    BODY: 'lf-menu-body',
    HEADER: 'lf-menu-head',
    MENU: 'lf-menu'
};

/** @override */
Navigable.prototype.elClass = Navigable.CLASSES.MENU;

/** @override */
Navigable.prototype.events = (function() {
    var CLASSES = Navigable.CLASSES;
    var events = {};
    var event = UserAgentUtil.isMobile() ? 'tap' : 'click';
    events[event + ' .' + CLASSES.ACTION_BTN] = '_handleActionClick';
    events[event + ' .' + CLASSES.BACK_BTN] = '_handleBackClick';
    return events;
})();

/**
 * @type {function()}
 */
Navigable.prototype.navTemplate = require('hgn!templates/mobile/navbar');

/**
 * The sub template that will be used for the body of the menu template.
 * @type {function()}
 */
Navigable.prototype.subTemplate = require('hgn!templates/thread/navigablesub');

/** @override */
Navigable.prototype.template = require('hgn!templates/thread/navigable');

/**
 * Handle the back button click. This should trigger a navigate event.
 * @param {jQuery.Event} ev
 * @private
 */
Navigable.prototype._handleBackClick = function(ev) {
    // The back click takes us back to the normal DOM, and we don't want
    // to retrigger the event.
    ev.preventDefault();
    this.$el.trigger(this._backEvent || ThreadEvents.NAVIGATE_BACK);
};

/**
 * Handle the action button click. This should call an optional handler
 * @param {jQuery.Event} ev
 * @private
 */
Navigable.prototype._handleActionClick = function (ev) {
    this._actionHandler(ev);
};

/** @override */
Navigable.prototype.getTemplateContext = function () {
    var KEYS = textEnumeration.KEYS;
    return {
        actionButton: !!this._actionDesc,
        strings: {
            actionBtn: this._actionDesc,
            backBtn: this._backStr || textEnumeration.get(KEYS.MENU_BACK_BTN),
            title: this._title
        },
        topNavEnabled: this.topNavEnabled
    };
};

/** @override */
Navigable.prototype.render = function () {
    this.$el.html(this.template(this.getTemplateContext(), {
        body: this.subTemplate.template,
        navbar: this.navTemplate.template
    }));
};

module.exports = Navigable;

});

define('annotations/mobile/thread/ui/navbar',['require','exports','module','inherits','annotations/thread/ui/navigable','hgn!templates/mobile/navbar'],function (require, exports, module) {/**
 * @fileOverview NavBar view.
 */
var inherits = require('inherits');
var Navigable = require('annotations/thread/ui/navigable');

/**
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
function NavBar(opts) {
    Navigable.call(this, opts);
}
inherits(NavBar, Navigable);

/** @override */
NavBar.CLASSES = Navigable.CLASSES;

/** @override */
NavBar.prototype.elClass = Navigable.CLASSES.HEADER;

/** @override */
NavBar.prototype.template = require('hgn!templates/mobile/navbar');

/** @override */
NavBar.prototype.elTag = 'header';

module.exports = NavBar;

});

define("hgn!templates/mobile/editor", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<header class=\"lf-menu-head\"></header>");_.b("\n" + i);_.b("<textarea class='lf-editor-field'></textarea>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/mobile/thread/ui/editorview',['require','exports','module','jquery','annotations/thread/ui/baseeditorview','annotations/util/editor','inherits','livefyre-bootstrap/loader','hgn!templates/thread/loader','annotations/mobile/thread/ui/navbar','annotations/util/editor','annotations/i18n/enumeration','annotations/events','annotations/events','hgn!templates/mobile/editor'],function (require, exports, module) {/**
 * @fileOverview The mobile editor view class.
 */

var $ = require('jquery');
var BaseEditorView = require('annotations/thread/ui/baseeditorview');
var editorUtil = require('annotations/util/editor');
var inherits = require('inherits');
var loader = require('livefyre-bootstrap/loader');
var loaderTemplate = require('hgn!templates/thread/loader');
var Navbar = require('annotations/mobile/thread/ui/navbar');
var normalizeParagraphTags = require('annotations/util/editor').normalizeParagraphTags;
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;
var WriteEvents = require('annotations/events').write;

/**
 * @constructor
 * @extends {BaseEditorView}
 * @param {Object} opts
 * Text area happenings for mobile.
 */
function MobileEditorView(opts) {
    BaseEditorView.call(this, opts);
    this._setType(opts);
    this._nav = new Navbar({
        actionDesc: this._actionStr,
        actionHandler: $.proxy(this.handlePostBtnClick, this),
        title: this._titleStr
    });
}
inherits(MobileEditorView, BaseEditorView);

/** @enum {string} */
MobileEditorView.TYPES = BaseEditorView.TYPES;

/** @override */
MobileEditorView.prototype._handleNavigateBack = function() {
    this._setDraft(this.opts.editorId, this.$textareaEl.val());
};

/**
 * Update the edited comment in the callback if this was an edit.
 * Handle errors if there were any.
 * @param {Object} err
 * @private
 */
MobileEditorView.prototype._handlePostComplete = function (err) {
    if (err) {
        this.showError(BaseEditorView.ERRORS.GENERIC);
        return;
    }

    if (this._type === BaseEditorView.TYPES.EDIT) {
        this.opts.model.set({
            body: this._getContents()
        });
    }
    this._setDraft(this.opts.editorId, null);
    this.$el.trigger(ThreadEvents.NAVIGATE_TO_THREAD);
};

/**
 * Set the type of the editor, as well as the post event and ancillary data.
 * @param {Object} opts The opts passed to the view.
 * @private
 */
MobileEditorView.prototype._setType = function (opts) {
    var KEYS = textEnumeration.KEYS;
    if (opts.parentId) {
        this._postEvent = WriteEvents.POST_REPLY;
        this._titleStr = textEnumeration.get(KEYS.EDITOR_REPLY_TITLE);
        this._actionStr = textEnumeration.get(KEYS.EDITOR_POST_BTN_MOBILE);
        this._type = BaseEditorView.TYPES.REPLY;
    } else if (opts.model) {
        this._postEvent = WriteEvents.POST_EDIT;
        var titleKey = opts.model.parentId ? KEYS.EDITOR_EDIT_REPLY_TITLE : KEYS.EDITOR_EDIT_TITLE;
        this._titleStr = textEnumeration.get(titleKey);
        this._actionStr = textEnumeration.get(KEYS.EDITOR_EDIT_BTN);
        this._type = BaseEditorView.TYPES.EDIT;
    } else {
        this._postEvent = WriteEvents.POST_ANNOTATION;
        this._titleStr = textEnumeration.get(KEYS.EDITOR_TITLE);
        this._actionStr = textEnumeration.get(KEYS.EDITOR_POST_BTN_MOBILE);
        this._type = BaseEditorView.TYPES.WRITE;
    }
};

/** @enum {string} */
MobileEditorView.prototype.classes = {
    EDITOR: 'lf-mobile-editor',
    FIELD: 'lf-editor-field',
    POST_BTN: 'lf-editor-post-btn'
};

/** @override */
MobileEditorView.prototype.elClass = MobileEditorView.prototype.classes.EDITOR;

/** @override */
MobileEditorView.prototype.events = (function () {
    var events = {};
    events[ThreadEvents.NAVIGATE_BACK] = '_handleNavigateBack';
    return events;
})();

/**
 * Focus once in the DOM
 */
MobileEditorView.prototype.initialize = function () {
    if (this._type === MobileEditorView.TYPES.EDIT) {
        this.$textareaEl.val(normalizeParagraphTags(this.opts.model.body));
    }
    this.focus();
};

/** @override */
MobileEditorView.prototype.focus = function () {
    // Prevent the keyboard from messing with the viewport.
    this.$textareaEl.one('focus', function (ev) {
        window.scrollTo(0, 0);
    });
    editorUtil.focusAndPlaceCursorAtEnd(this.$textareaEl);
};

/** @override */
MobileEditorView.prototype.render = function () {
    BaseEditorView.prototype.render.call(this);
    this._nav.setElement(this.$('.' + Navbar.CLASSES.HEADER));
    this._nav.render();

    var draft = this._getDraft(this.opts.editorId);
    if (draft) {
        this.$textareaEl.val(draft);
        return;
    }
    if (this._type === BaseEditorView.TYPES.EDIT) {
        this.$textareaEl.val(normalizeParagraphTags(this.opts.model.body));
    }
    // prevent keyboard from messing with scroll by forcing scrollTop to 0.
    window.scrollTo(0, 0);
};

/** @override */
MobileEditorView.prototype.sendPostEvent = function (data) {
    this.$el.trigger(this._postEvent, data);
    var loaderContainer = $(loaderTemplate());
    loader.decorate(loaderContainer, 60);
    this.$textareaEl.replaceWith(loaderContainer);
};

/** @override */
MobileEditorView.prototype.showError = function (msg) {
    window.alert(msg);
};

/** @override */
MobileEditorView.prototype.template = require('hgn!templates/mobile/editor');

module.exports = MobileEditorView;

});

define("hgn!templates/thread/notification", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-notification-icon\" />");_.b("\n" + i);_.b("<h4 class=\"lf-notification-title\">");_.b(_.v(_.d("strings.title",c,p,0)));_.b("</h4>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/thread/notification',['require','exports','module','jquery','inherits','annotations/i18n/enumeration','view','annotations/events','hgn!templates/thread/notification'],function (require, exports, module) {/**
 * @fileOverview Notification view that shows over the thread view once an
 * action has been performed.
 */

var $ = require('jquery');
var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');
var View = require('view');
var WriteEvents = require('annotations/events').write;

/**
 * Notification view.
 * @constructor
 * @extends {View}
 * @param {Object} opts
 */
function NotificationView(opts) {
    View.call(this, opts);

    /**
     * Event name that this is notifying of it's success.
     * @type {string}
     * @private
     */
    this._event = opts.event;
}
inherits(NotificationView, View);

/** @enum {string} */
var CLASSES = {
    APPROVE: 'fycon-check-funky',
    DELETE: 'fycon-admin-delete',
    FLAG: 'fycon-admin-flag',
    ICON: 'lf-notification-icon',
    MAIN: 'lf-thread-notification',
    POPOVER: 'lf-thread-popover'
};

/** @enum {string} */
var EVENT_TO_CLASS_MAP = (function () {
    var map = {};
    map[WriteEvents.POST_APPROVE] = CLASSES.APPROVE;
    map[WriteEvents.POST_DELETE] = CLASSES.DELETE;
    map[WriteEvents.POST_FLAG] = CLASSES.FLAG;
    map[WriteEvents.POST_HIDE] = CLASSES.DELETE;
    return map;
})();

/** @enum {string} */
var EVENT_TO_ENUMERATION_MAP = (function () {
    var KEYS = textEnumeration.KEYS;
    var map = {};
    map[WriteEvents.POST_APPROVE] = KEYS.NOTIFICATION_APPROVED;
    map[WriteEvents.POST_DELETE] = KEYS.NOTIFICATION_DELETED;
    map[WriteEvents.POST_FLAG] = KEYS.NOTIFICATION_FLAGGED;
    map[WriteEvents.POST_HIDE] = KEYS.NOTIFICATION_DELETED;
    return map;
})();

/**
 * The amount of time, in ms that this component will live.
 * @type {number}
 */
var TTL = 1500;

/** @override */
NotificationView.prototype.elClass = CLASSES.MAIN;

/** @override */
NotificationView.prototype.template = require('hgn!templates/thread/notification');

/**
 * Decorate a provided DOM element by adding itself to it. Positions itself
 * within the provided element.
 * @param {jQuery.Element} elem
 */
NotificationView.prototype.decorate = function (elem) {
    this.render();
    elem.append(this.$el);
    this.position();
};

/** @override */
NotificationView.prototype.getTemplateContext = function () {
    return {
        strings: {
            title: textEnumeration.get(EVENT_TO_ENUMERATION_MAP[this._event])
        }
    };
};

/**
 * Position the notification.
 */
NotificationView.prototype.position = function () {
    var $popoverEl = this.$el.closest('.' + CLASSES.POPOVER);
    var left = ($popoverEl.width() - this.$el.outerWidth()) / 2;
    var top = ($popoverEl.height() - this.$el.outerHeight()) / 2;
    this.$el.css({'left': left + 'px', 'top': top + 'px'});
};

/** @override */
NotificationView.prototype.render = function () {
    View.prototype.render.call(this);
    this.$('.' + CLASSES.ICON).addClass(EVENT_TO_CLASS_MAP[this._event]);
    setTimeout($.proxy(this.destroy, this), TTL);
};

module.exports = NotificationView;

});

define('annotations/mobile/thread/ui/thread/notification',['require','exports','module','jquery','inherits','annotations/thread/ui/thread/notification'],function (require, exports, module) {/**
 * @fileOverview Mobile notification view.
 */

var $ = require('jquery');
var inherits = require('inherits');
var NotificationView = require('annotations/thread/ui/thread/notification');

/**
 * Mobile notification view.
 * @constructor
 * @extends {NotificationView}
 * @param {Object} opts
 */
function MobileNotificationView(opts) {
    NotificationView.call(this, opts);
}
inherits(MobileNotificationView, NotificationView);

/** @override */
MobileNotificationView.prototype.decorate = function () {
    this.render();
    $(document.body).append(this.$el);
};

module.exports = MobileNotificationView;

});

define('annotations/util/array',['require','exports','module'],function (require, exports, module) {/**
 * @fileOverview Array utilities.
 */

var array = {};

/**
 * Default comparator function.
 * @param {Object} obj1
 * @param {Object} obj2
 * @return {number} -1, 0, 1 based on if the first object is less than,
 *    equal to, or greater than the second object.
 */
array.defaultComparator = function (obj1, obj2) {
    return obj1 < obj2 ? -1 : obj1 > obj2 ? 1 : 0;
};

/**
 * Find the index in which to insert an item into an array. The user can supply
 * a comparator for custom sorting and objects.
 * @param {Array} arr The array to find the index.
 * @param {Object} item The object being inserted.
 * @param {function()=} opt_comparator Optional sorting function.
 * @return {number} The index where the item would go in the array.
 */
array.findIndex = function (arr, item, opt_comparator) {
    var compareFn = opt_comparator || array.defaultComparator;
    for (var i=0, len=arr.length; i<len; i++) {
        if (compareFn(item, arr[i]) <= 0) {
            return i;
        }
    }
    return arr.length;
};

/**
 * Searches through the provided array and compares each item with the
 * comparator function. If it returns true, then the item is returned. If none
 * of the items match, null is returned.
 * @param {Array} arr The array to loop through.
 * @param {function()} comparator The comparator function.
 * @return {?boolean} Returns the item if it exists, null otherwise.
 */
array.findItem = function (arr, comparator) {
    for (var i=0, len=arr.length; i<len; i++) {
        if (comparator(arr[i], i)) {
            return arr[i];
        }
    }
    return null;
};

module.exports = array;

});

define('annotations/util/sorting',['require','exports','module'],function (require, exports, module) {module.exports = {
    /**
     * Comment comparator. Sorts in ascending order by created date.
     * @param {string} id1 ID of the first comment to check.
     * @param {string} id2 ID of the second comment to check.
     * @return {number} -1, 0, 1 based on if the first object is less than,
     *     equal to, or greater than the second object.
     */
    createdAtComparator: function(id1, id2) {
        var val1 = this._comments[id1].getModel().createdAt;
        var val2 = this._comments[id2].getModel().createdAt;
        return val1 < val2 ? -1 : val1 > val2 ? 1 : 0;
    },

    /**
     * Comment comparator. Sorts by helpfulness
     * @param {string} id1 ID of the first comment to check.
     * @param {string} id2 ID of the second comment to check.
     * @return {number} -1, 0, 1 based on if the first object is less than,
     *     equal to, or greater than the second object.
     */
    helpfulnessComparator: function(id1, id2) {
        var m1 = this._comments[id1].getModel();
        var m2 = this._comments[id2].getModel();
        var val1 = m1.votes.helpfulness;
        var val2 = m2.votes.helpfulness;
        var result = val1 < val2 ? 1 : val1 > val2 ? -1 : 0;
        if (result !== 0) {
            return result;
        }
        val1 = m1.votes.downvotes;
        val2 = m2.votes.downvotes;
        result = val1 < val2 ? -1 : val1 > val2 ? 1 : 0;
        if (result !== 0) {
            return result;
        }
        val1 = m1.createdAt;
        val2 = m2.createdAt;
        return val1 < val2 ? 1 : val1 > val2 ? -1 : 0;
    }
};

});

define('annotations/thread/ui/basethreadcontainer',['require','exports','module','jquery','annotations/util/array','inherits','annotations/util/sorting','view'],function (require, exports, module) {/**
 * @fileOverview Thread container view. This provides functionality to add,
 * remove, and sort comments.
 */

var $ = require('jquery');
var ArrayUtil = require('annotations/util/array');
var inherits = require('inherits');
var SortingUtil = require('annotations/util/sorting');
var View = require('view');

/**
 * Thread container view.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
var BaseThreadContainer = function(opts) {
    View.call(this, opts);

    /**
     * Comment constructor.
     * @type {function()}
     * @private
     */
    this._commentConstructor = this.opts.commentConstructor;

    /**
     * Sorted set of all comment ids.
     * @type {Array.<string>}
     * @private
     */
    this._commentIds = [];

    /**
     * Set of all comments.
     * @type {Object.<string, CommentView>}
     * @private
     */
    this._comments = {};
};
inherits(BaseThreadContainer, View);

/**
 * Get the comment options that get passed into the view.
 * @param {Comment} comment The comment model for the view.
 * @return {Object}
 * @private
 */
BaseThreadContainer.prototype._getCommentOptions = function (comment) {
    return {
        assetServer: this.opts.assetServer,
        defaultAvatar: this.opts.defaultAvatar,
        model: comment
    };
};

/**
 * Adds a comment to the thread container. This will add the comment to the
 * internal list of comments that are here, create a comment view and render it.
 * @param {Comment|Array.<Comment>} comments The comment model(s) to add.
 * @param {boolean=} opt_prepend Optional prepend the comment instead of append.
 * @param {Element=} opt_el Optional element to render onto.
 */
BaseThreadContainer.prototype.addComment = function(comments, opt_prepend, opt_el) {
    var el = opt_el || this.getContainerElement();
    if (!$.isArray(comments)) {
        comments = [comments];
    }
    $.each(comments, $.proxy(this.processComment, this, !!opt_prepend, $(el)));
};

/** @override */
BaseThreadContainer.prototype.comparator = SortingUtil.createdAtComparator;

/**
 * Get the container element that the comments should be added to.
 * @return {Element}
 */
BaseThreadContainer.prototype.getContainerElement = function() {
    return this.$el;
};

/**
 * Initialize the thread container with a set of comments. These should all be
 * rendered prior to adding to the DOM so there is only 1 DOM write.
 * @param {Array.<Comment>} comments The set of comments to load.
 */
BaseThreadContainer.prototype.initialize = function(comments) {
    var currentEl = this.getContainerElement();
    var fragment = document.createDocumentFragment();
    this.addComment(comments, false, fragment);
    currentEl.append(fragment);
};

/**
 * Process a comment. Create a new view, find the index where it needs to go in
 * the sorted list, and insert it into the DOM.
 * @param {boolean} prepend To prepend or not to prepend, that is the question...
 * @param {jQuery.Element} el The containing element to add the comment view to.
 * @param {number} i The index of the array that this comment exists.
 * @param {Comment} comment The comment to process.
 */
BaseThreadContainer.prototype.processComment = function(prepend, el, i, comment) {
    if (!!this._comments[comment.id]) {
        return;
    }
    var view = new this._commentConstructor(this._getCommentOptions(comment));
    view.render();
    view.handleVisChange();
    this._comments[comment.id] = view;

    if (prepend) {
        this._commentIds.splice(0, 0, comment.id);
        el.prepend(view.$el);
        return;
    }

    var comparatorFn = $.proxy(this.comparator, this);
    var idx = ArrayUtil.findIndex(this._commentIds, comment.id, comparatorFn);

    if (idx >= this._commentIds.length) {
        this._commentIds.push(comment.id);
        el.append(view.$el);
        return;
    }
    this._commentIds.splice(idx, 0, comment.id);
    view.$el.insertBefore(el[0].childNodes[idx]);
};

/**
 * Reinitialize with the current set of comments + some new friends
 * @param {?Array.<Comment>} opt_comments The set of new comments to add.
 */
BaseThreadContainer.prototype.reinitialize = function(opt_comments) {
    opt_comments = opt_comments || [];
    var comments = [];
    var comment;
    var commentView;
    for (var i=0, len=this._commentIds.length; i < len; i++) {
        commentView = this._comments[this._commentIds[i]];
        comment = commentView.getModel();
        comments.push(comment);
        commentView.destroy();
    }
    this._commentIds = [];
    this._comments = {};

    comments.push.apply(comments, opt_comments);
    this.getContainerElement().empty();
    this.initialize(comments);
};

module.exports = BaseThreadContainer;

});

define("hgn!templates/thread/comment/votecontainer", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<span class=\"lf-count\">");_.b(_.v(_.f("count",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("<a class=\"lf-upvote fycon-arrow-up\"></a>");_.b("\n" + i);_.b("<a class=\"lf-downvote fycon-arrow-down\"></a>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/comment/votecontainer',['require','exports','module','jquery','auth','streamhub-sdk/debug','inherits','observer','view','streamhub-sdk/content/annotator-extensions','annotations/events','hgn!templates/thread/comment/votecontainer'],function (require, exports, module) {/**
 * @fileOverview The vote container class. This provides upvote and downvote
 * functionality as well as an overall helpfulness count.
 */

var $ = require('jquery');
var auth = require('auth');
var debug = require('streamhub-sdk/debug');
var inherits = require('inherits');
var Observer = require('observer');
var View = require('view');
var voteEnums = require('streamhub-sdk/content/annotator-extensions').voteEnums;
var WriteEvents = require('annotations/events').write;

var log = debug('annotations/thread/ui/comment/votecontainer');
var voteEnum = voteEnums.vote;
var voteToCount = voteEnums.voteToCount;

/**
 * Vote container component.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
var VoteContainer = function(opts) {
    View.call(this, opts);

    /**
     * The model that is backing this view.
     * @type {Comment}
     * @private
     */
    this._model = this.opts.model;

    var vote = this._hasVoted();

    /**
     * The current vote by this user.
     * @type {enumsEnum.vote}
     * @private
     */
    this._currentVote = !vote ? voteEnum.UNSET : vote.value;

    /**
     * Whether the buttons are disabled or not. This allows or disallows a
     * user from being able to vote.
     * @type {boolean}
     * @private
     */
    this._disabled = false;

    /**
     * Whether the vote is being processed or not. This is set to true when
     * there is a click and set back to false after the click has been
     * processed. This guards against people clicking in fast succession.
     * @type {boolean}
     * @private
     */
    this._processing = false;

    this._model.on('change:votes', $.proxy(this._handleVotesUpdated, this));

    Observer(this);
    this.listenTo(auth, 'login.livefyre', $.proxy(this._handleUserLogin, this));
    this.listenTo(auth, 'logout', $.proxy(this._handleUserLogout, this));
};
inherits(VoteContainer, View);

/** @enum {string} */
VoteContainer.CLASSES = {
    COUNT: 'lf-count',
    DISABLED: 'lf-disabled',
    DOWNVOTE: 'lf-downvote',
    MAIN: 'lf-votes',
    UPVOTE: 'lf-upvote',
    VOTED: 'lf-voted'
};

/** @override */
VoteContainer.prototype.events = {
    'click a': '_handleVoteClick'
};

/** @override */
VoteContainer.prototype.template = require('hgn!templates/thread/comment/votecontainer');

/**
 * Handle the user login event.
 * @private
 */
VoteContainer.prototype._handleUserLogin = function() {
    var vote = this._hasVoted();
    this._currentVote = !vote ? voteEnum.UNSET : vote.value;
    this._updateVoteStatus();
    this._updateButtonState();
};

/**
 * Handle the user logout event.
 * @private
 */
VoteContainer.prototype._handleUserLogout = function() {
    this._currentVote = voteEnum.UNSET;
    this._updateVoteStatus();
    this._updateButtonState();
};

/**
 * Handle the vote click event.
 * @param {jQuery.Event} ev
 * @private
 */
VoteContainer.prototype._handleVoteClick = function(ev) {
    if (this._disabled || this._processing) {
        return;
    }
    this._processing = true;
    var CLASSES = VoteContainer.CLASSES;
    var $target = $(ev.target);
    var isDownvote = $target.hasClass(CLASSES.DOWNVOTE);
    var typeEnum = isDownvote ? voteEnum.DOWNVOTE : voteEnum.UPVOTE;
    var value = this._currentVote === typeEnum ? voteEnum.UNSET : typeEnum;
    $target.toggleClass(CLASSES.VOTED, value !== voteEnum.UNSET);

    this.$el.trigger(WriteEvents.POST_VOTE, {
        authorId: this._model.author.id,
        callback: $.proxy(this._handleVoteComplete, this),
        lastValue:  this._currentVote,
        messageId: this._model.id,
        value: value
    });

    this._instantFeedbackRender(value);
    this._processing = false;
};

/**
 * Handle the vote complete callback.
 * @param {Object} err
 * @param {Object} data
 * @private
 */
VoteContainer.prototype._handleVoteComplete = function(err, data) {
    if (err) {
        log(err);
        // Clear the instant feedback render.
        // TODO: What about the updated counts?
        this.render();
        return;
    }
    this._setCurrentVote(data);
};

/**
 * Handle the vote complete callback.
 * @param {Object} newVotes
 * @param {Object} oldVotes
 * @private
 */
VoteContainer.prototype._handleVotesUpdated = function(newVotes, oldVotes) {
    var vote = this._hasVoted();
    this._setCurrentVote(vote);
    this.render();
};

/**
 * Checks if the current signed in user has voted on this comment.
 * @return {?Vote} Vote if user has voted, null otherwise.
 * @private
 */
VoteContainer.prototype._hasVoted = function() {
    var user = auth.get('livefyre');
    var userId = user ? user.get('id') : null;
    if (!userId) {
        return null;
    }
    var vote;
    var votes = this._model.votes.list;
    for (var i=0, len=votes.length; i<len; i++) {
        vote = votes[i];
        if (userId === vote.author) {
            return vote;
        }
    }
    return null;
};

/**
 * After a user has clicked, show the the effects of their action
 * before it is acknowlegded by the BE.
 * @param {voteEnums.vote} value
 * @private
 */
VoteContainer.prototype._instantFeedbackRender = function (value) {
    if (!auth.get('livefyre')) {
        return;
    }
    var diff = this._getDiff(value);
    this._model.votes.helpfulness += diff;

    this._updateVoteCount();
    this._updateVoteStatus(value);
};

/**
 * param {voteEnums.vote} value
 * @return {number}
 */
VoteContainer.prototype._getDiff = function (value) {
    var diff = voteToCount[this._currentVote] * -1;
    if (value !== voteEnum.UNSET) {
        diff += voteToCount[value];
    }
    return diff;
};

/**
 * Sets the current vote value.
 * param {voteEnums.vote} vote
 * @private
 */
VoteContainer.prototype._setCurrentVote = function(vote) {
    this._currentVote = !vote ? voteEnum.UNSET : vote.value;
};

/**
 * Update the disabled state of the button depending on the authentication
 * status of the current user.
 * @private
 */
VoteContainer.prototype._updateButtonState = function() {
    this._disabled = this._model.isUserAuthor();
    this.$el.toggleClass(VoteContainer.CLASSES.DISABLED, this._disabled);
};

/**
 * Update the vote count with the helpfulness score.
 * @param {number} opt_helpfullness Fake the count for instant feedback
 * @private
 */
VoteContainer.prototype._updateVoteCount = function(opt_helpfullness) {
    var count = this._model.votes.helpfulness;
    if (opt_helpfullness !== undefined) {  // Because O is falsey
        count = opt_helpfullness;
    }
    this.$('.' + VoteContainer.CLASSES.COUNT).html(count);
};

/**
 * Update the vote status of the comment. Highlight either the upvote or
 * downvote buttons based on whether the current user has upvoted or downvoted
 * this comment already.
 * @param {enumsEnum.vote} opt_currentVote
 * @private
 */
VoteContainer.prototype._updateVoteStatus = function(opt_currentVote) {
    var CLASSES = VoteContainer.CLASSES;
    var currentVote;

    if (opt_currentVote !== undefined) {  // because 0 (UNSET) is falsey
        currentVote = opt_currentVote;
    } else {
        currentVote = this._currentVote;
    }

    this.$el.attr('class', CLASSES.MAIN);
    if (currentVote === voteEnum.UNSET || this._model.isUserAuthor()) {
        return;
    }
    var cls = currentVote === voteEnum.UPVOTE ?
        CLASSES.UPVOTE :
        CLASSES.DOWNVOTE;
    this.$el.addClass(cls);
};

/** @override */
VoteContainer.prototype.destroy = function() {
    View.prototype.destroy.call(this);
    this.stopListening();
};

/** @override */
VoteContainer.prototype.getTemplateContext = function() {
    return {
        count: this._model.votes.helpfulness
    };
};

/** @override */
VoteContainer.prototype.render = function() {
    View.prototype.render.call(this);
    this._updateVoteStatus();
    this._updateButtonState();
};

module.exports = VoteContainer;

});

define("hgn!templates/thread/comment/actions", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-votes\" />");_.b("\n" + i);_.b("<span class=\"lf-separator\">&middot;</span>");_.b("\n" + i);_.b("<a class=\"lf-reply-btn\">");_.b(_.v(_.d("strings.replyBtn",c,p,0)));_.b("</a>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/comment/actions',['require','exports','module','inherits','annotations/i18n/enumeration','view','annotations/thread/ui/comment/votecontainer','hgn!templates/thread/comment/actions'],function (require, exports, module) {/**
 * @fileOverview The comment actions class. This contains all of the comment
 * actions such as votes, reply, and more. This is what gets added to top-level
 * comments.
 */

var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');
var View = require('view');
var VoteContainer = require('annotations/thread/ui/comment/votecontainer');

/**
 * Comment actions component.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
var CommentActions = function(opts) {
    View.call(this, opts);

    /**
     * The model that is backing this view.
     * @type {Comment}
     */
    this._model = opts.model;

    /**
     * The vote container view.
     * @type {VoteContainer}
     * @private
     */
    this._voteContainer = this.createVoteContainer();
};
inherits(CommentActions, View);

/** @enum {string} */
CommentActions.CLASSES = {
    ACTIONS: 'lf-comment-actions',
    REPLY_BTN: 'lf-reply-btn',
    SEPARATOR: 'lf-separator',
    VOTES: 'lf-votes'
};

CommentActions.prototype.createVoteContainer = function() {
    return new VoteContainer(this.opts);
};

/** @override */
CommentActions.prototype.template = require('hgn!templates/thread/comment/actions');

/** @override */
CommentActions.prototype.getTemplateContext = function() {
    return {
        strings: {
            replyBtn: textEnumeration.get(textEnumeration.KEYS.REPLY_BTN)
        }
    };
};

/**
 * @return {VoteContainer}
 */
CommentActions.prototype.getVoteContainer = function () {
    return this._voteContainer;
};

/**
 * Hide the reply button.
 */
CommentActions.prototype.hideReplyBtn = function() {
    this.$_replyBtn.hide();
    this.$_separator.hide();
};

/** @override */
CommentActions.prototype.render = function() {
    View.prototype.render.call(this);

    var CLASSES = CommentActions.CLASSES;
    this._voteContainer.setElement(this.$('.' + CLASSES.VOTES)[0]);
    this._voteContainer.render();
    this.$_replyBtn = this.$('.' + CLASSES.REPLY_BTN);
    this.$_separator = this.$('.' + CLASSES.SEPARATOR);
};

module.exports = CommentActions;

});

define("hgn!templates/mobile/loadercard", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-escape-button fycon-x\"></div>");_.b("\n" + i);_.b("<div class=\"lf-loader-container\"></div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/thread/comment/comment", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-comment-container\">");_.b("\n" + i);_.b(_.rp("base",c,p,"    "));_.b("</div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/thread/comment/base", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<img class=\"lf-comment-author-avatar\" src=\"");_.b(_.v(_.f("avatar",c,p,0)));_.b("\" onerror=\"javascript:this.src='");_.b(_.v(_.f("defaultAvatar",c,p,0)));_.b("';\" />");_.b("\n" + i);_.b("<header class=\"lf-comment-header\">");_.b("\n" + i);_.b("    <span class=\"lf-comment-author-name\">");_.b(_.t(_.d("author.displayName",c,p,0)));_.b("</span>");_.b("\n" + i);_.b(_.rp("tags",c,p,"    "));_.b("</header>");_.b("\n" + i);_.b("<section class=\"lf-comment-body\">");_.b("\n" + i);_.b("    ");_.b(_.t(_.f("body",c,p,0)));_.b("\n" + i);_.b("</section>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/thread/comment/etc", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<a class=\"lf-etc-btn fycon-action-etc\"></a>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/thread/comment/footer", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<footer class=\"lf-comment-footer\">");_.b("\n" + i);_.b("    <span class=\"lf-comment-actions\"></span>");_.b("\n" + i);_.b(_.rp("etc",c,p,"    "));_.b("</footer>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/thread/comment/tags", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");if(_.s(_.f("moderator",c,p,1),c,p,0,14,126,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("    <span class=\"lf-comment-author-tag lf-tag lf-label lf-label-info\">");_.b(_.v(_.d("strings.commentModeratorTag",c,p,0)));_.b("</span>");_.b("\n");});c.pop();}if(_.s(_.f("pending",c,p,1),c,p,0,153,264,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("    <span class=\"lf-comment-pending-tag lf-tag lf-label lf-label-info\">");_.b(_.v(_.d("strings.commentPendingTag",c,p,0)));_.b("</span>");_.b("\n");});c.pop();}return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/comment/baseview',['require','exports','module','jquery','annotations/adapters','auth','annotations/events','annotations/thread/ui/comment/actions','inherits','annotations/i18n/enumeration','annotations/events','annotations/events','view','annotations/enums','hgn!templates/thread/comment/comment','hgn!templates/thread/comment/base','hgn!templates/thread/comment/etc','hgn!templates/thread/comment/footer','hgn!templates/thread/comment/tags'],function (require, exports, module) {/**
 * @fileOverview The comment view class. This is what renders a single comment
 * on the page.
 */

var $ = require('jquery');
var adaptAvatar = require('annotations/adapters').adaptAvatar;
var auth = require('auth');
var BlockEvents = require('annotations/events').block;
var CommentActions = require('annotations/thread/ui/comment/actions');
var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;
var UserEvents = require('annotations/events').user;
var View = require('view');
var visEnums = require('annotations/enums').commentVisibility;

/**
 * Comment view.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
var BaseCommentView = function(opts) {
    View.call(this, opts);

    /**
     * The model that is backing this view.
     * @type {Comment}
     */
    this._model = opts.model;

    // Listen for the visibiilty change event and handle accordingly.
    this._model.on('change:visibility', $.proxy(this.handleVisChange, this));

    // Listen for body updates (edits) and rerender.
    this._model.on('change:body', $.proxy(this.render, this));

    /**
     * The comment actions for this comment.
     * @type {?CommentActions}
     * @private
     */
    this._actions = this.createActions();
};
inherits(BaseCommentView, View);

/** @enum {string} */
BaseCommentView.CLASSES = {
    ACTIONS: 'lf-comment-actions',
    AVATAR: 'lf-comment-author-avatar',
    BODY: 'lf-comment-body',
    COMMENT: 'lf-comment',
    CONTAINER: 'lf-comment-container',
    DISPLAY_NAME: 'lf-comment-author-name',
    HEADER: 'lf-comment-header',
    REPLY: 'lf-reply',
    MORE_BTN: 'lf-etc-btn',
    PENDING_TAG: 'lf-comment-pending-tag',
    FOOTER: 'lf-comment-footer'
};

/** @override */
BaseCommentView.prototype.elClass = BaseCommentView.CLASSES.COMMENT;

/** @override */
BaseCommentView.prototype.elTag = 'article';

/** @override */
BaseCommentView.prototype.events = (function() {
    var CLASSES = BaseCommentView.CLASSES;
    var events = {};
    events['click .' + CLASSES.AVATAR] = '_handleViewProfile';
    events['click .' + CLASSES.DISPLAY_NAME] = '_handleViewProfile';
    events['click .' + CLASSES.MORE_BTN] = '_handleMoreClick';
    return events;
})();

/** @override */
BaseCommentView.prototype.template = require('hgn!templates/thread/comment/comment');

/**
 * Handle the more click event.
 * @private
 */
BaseCommentView.prototype._handleMoreClick = function () {
    this.$el.trigger(ThreadEvents.CHANGE_VIEW, {
        model: this._model,
        value: 'etc'
    });
};

/**
 * Handle the view profile event. This should trigger an event that will use
 * the auth delegate to view profile.
 * @param {jQuery.Event} ev
 * @private
 */
BaseCommentView.prototype._handleViewProfile = function (ev) {
    // Necessary so that it doesn't bubble to the parent comment and trigger
    // another view profile event.
    ev.stopPropagation();
    this.$el.trigger(UserEvents.VIEW_PROFILE, {
        author: this._model.author
    });
};

/**
 * Show the comment view.
 * @private
 */
BaseCommentView.prototype._show = function () {
    this.$el.show();
};

/**
 * Trigger a vis event with the comment that was updated and the increment
 * amount for it.
 * @param {number} inc The increment amount.
 * @private
 */
BaseCommentView.prototype._triggerVisEvent = function () {
    this.$el.trigger(BlockEvents.UPDATE_COUNT, {
        blockId: this._model.blockId,
        inc: this._model.calculateCountIncrement()
    });
};

/**
 * @returns {CommentActions}
 */
BaseCommentView.prototype.createActions = function () {
    return new CommentActions({
        model: this._model
    });
};

/** @override */
BaseCommentView.prototype.destroy = function () {
    View.prototype.destroy.call(this);
    this._actions && this._actions.destroy();
    this._actions = null;
};

/**
 * Provide access to the view's model.
 * @return {Comment}
 */
BaseCommentView.prototype.getModel = function () {
    return this._model;
};

/** @override */
BaseCommentView.prototype.getTemplateContext = function () {
    var KEYS = textEnumeration.KEYS;

    return {
        author: this._model.author,
        avatar: adaptAvatar(this._model.author.avatar),
        body: this._model.body,
        defaultAvatar: this.opts.defaultAvatar,
        moderator: this._model.moderator,
        pending: this._model.isPending(),
        strings: {
            commentModeratorTag: textEnumeration.get(KEYS.COMMENT_MODERATOR_TAG),
            commentPendingTag: textEnumeration.get(KEYS.COMMENT_PENDING_TAG)
        }
    };
};

/**
 * Handle the visibility change event.
 */
BaseCommentView.prototype.handleVisChange = function () {
    this._triggerVisEvent();
    switch (this._model.visibility) {
        case visEnums.NONE:
            return this.handleVisNone();
        case visEnums.EVERYONE:
            return this.handleVisEveryone();
        case visEnums.OWNER:
            return this.handleVisOwner();
        case visEnums.GROUP:
            return this.handleVisGroup();
        default:
            throw 'Not supported visibility type: ' + this._model.visibility;
    }
};

/**
 * Handle the visible state.
 */
BaseCommentView.prototype.handleVisEveryone = function () {
    this.render();
    this._show();
};

/**
 * Handle the pending state.
 */
BaseCommentView.prototype.handleVisGroup = function () {
    var user = auth.get('livefyre');
    var isMod = user ? user.isMod({collectionId: this._model.collectionId}) : false;
    if (this._model.isUserAuthor() || isMod) {
        this.render();
        this._show();
        return;
    }
    this.hide();
};

/**
 * Handle the deleted state.
 */
BaseCommentView.prototype.handleVisNone = function () {
    this.hide();
};

/**
 * Handle the bozo state.
 */
BaseCommentView.prototype.handleVisOwner = function () {
    if (this._model.isUserAuthor()) {
        this.render();
        this._show();
        return;
    }
    this.hide();
};

/**
 * Hide the comment view. Doing this instead of destroying so that it's possible
 * to change the visibility and have the view show itself.
 */
BaseCommentView.prototype.hide = function () {
    this.$el.hide();
};

/** @override */
BaseCommentView.prototype.render = function () {
    this.$el.html(this.template(this.getTemplateContext(), {
        base: require('hgn!templates/thread/comment/base').template,
        etc: require('hgn!templates/thread/comment/etc').template,
        footer: require('hgn!templates/thread/comment/footer').template,
        tags: require('hgn!templates/thread/comment/tags').template
    }));
    this.$footerEl = this.$('.'+ BaseCommentView.CLASSES.FOOTER);
    this._actions.setElement(this.$footerEl.find('.' + BaseCommentView.CLASSES.ACTIONS));
    this._actions.render();
    this.$el.attr('id', this._model.id);
    this._model.hasBeenRendered = true;
};

/**
 * Determines if this view should be rendered. If the comment has made it this
 * far, that means that it has either been decoded (if eref) or is a non-eref
 * type which we will decide what to do with here.
 * @return {boolean}
 */
BaseCommentView.prototype.shouldRender = function () {
    var user = auth.get('livefyre');
    var isOwner = this._model.isUserAuthor();
    var isMod = user ? user.isMod({collectionId: this._model.collectionId}) : false;

    switch (this._model.visibility) {
        case visEnums.NONE:
            return false;
        case visEnums.EVERYONE:
            return true;
        case visEnums.OWNER:
            return isOwner;
        case visEnums.GROUP:
            return isMod || isOwner;
        default:
            return false;
    }
};

module.exports = BaseCommentView;

});

define("hgn!templates/mobile/votecontainer", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<a class=\"lf-upvote fycon-arrow-up\"></a>");_.b("\n" + i);_.b("<a class=\"lf-downvote fycon-arrow-down\"></a>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/mobile/thread/ui/comment/votecontainer',['require','exports','module','auth','inherits','annotations/thread/ui/comment/votecontainer','hgn!templates/mobile/votecontainer'],function (require, exports, module) {/**
 * @fileoverview Mobile vote container.
 */

var auth = require('auth');
var inherits = require('inherits');
var VoteContainer = require('annotations/thread/ui/comment/votecontainer');

/**
 * @extends {VoteContainer}
 */
function MobileVoteContainer (opts) {
    VoteContainer.call(this, opts);
}
inherits(MobileVoteContainer, VoteContainer);

/** @override */
MobileVoteContainer.CLASSES = VoteContainer.CLASSES;

/** @enum {string} */
MobileVoteContainer.EVENTS = {
    USER_VOTED: 'votes.userVoted'
};

/** @override */
MobileVoteContainer.prototype.events = {
    'tap a': '_handleVoteClick'
};

/** @override */
MobileVoteContainer.prototype.template = require('hgn!templates/mobile/votecontainer');

/**
 * In MobileLand we don't stream yet, so we REALLY fake the vote's effects.
 * @override
 */
MobileVoteContainer.prototype._instantFeedbackRender = function (value) {
    if (!auth.get('livefyre')) {
        return;
    }
    var diff = this._getDiff(value);
    this._model.votes.helpfulness += diff;
    // Trickyness here b/c the vote count is on the comment header.
    this.emit(MobileVoteContainer.EVENTS.USER_VOTED);
    this._updateVoteStatus(value);
};

module.exports = MobileVoteContainer;

});

define("hgn!templates/mobile/actions", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-votes\" />");_.b("\n" + i);_.b("<a class=\"fycon-action-reply lf-reply-btn\" />");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/mobile/thread/ui/comment/actions',['require','exports','module','annotations/thread/ui/comment/actions','inherits','annotations/mobile/thread/ui/comment/votecontainer','hgn!templates/mobile/actions'],function (require, exports, module) {var CommentActions = require('annotations/thread/ui/comment/actions');
var inherits = require('inherits');
var MobileVoteContainer = require('annotations/mobile/thread/ui/comment/votecontainer');

/**
 * @extends {CommentActions}
 */
function MobileCommentActions (opts) {
    CommentActions.call(this, opts);
}
inherits(MobileCommentActions, CommentActions);

/** @override */
MobileCommentActions.prototype.createVoteContainer = function () {
    return new MobileVoteContainer(this.opts);
};

/** @override */
MobileCommentActions.prototype.template = require('hgn!templates/mobile/actions');

module.exports = MobileCommentActions;

});

define("hgn!templates/mobile/reply", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-comment-container\">");_.b("\n" + i);_.b("    <img class=\"lf-comment-author-avatar\" src=\"");_.b(_.v(_.d("author.avatar",c,p,0)));_.b("\" />");_.b("\n" + i);_.b("    <header class=\"lf-comment-header\">");_.b("\n" + i);_.b("        <span class=\"lf-comment-author-name\">");_.b(_.t(_.d("author.displayName",c,p,0)));_.b("</span>");_.b("\n" + i);_.b(_.rp("tags",c,p,"        "));_.b("        <a class=\"lf-etc-btn fycon-action-etc\"></a>");_.b("\n" + i);_.b("    </header>");_.b("\n" + i);_.b("    <section class=\"lf-comment-body\">");_.b("\n" + i);_.b("        ");_.b(_.t(_.f("body",c,p,0)));_.b("\n" + i);_.b("    </section>");_.b("\n" + i);_.b("</div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/mobile/thread/ui/comment/reply',['require','exports','module','annotations/thread/ui/comment/baseview','inherits','annotations/events','hgn!templates/mobile/reply'],function (require, exports, module) {/**
 * @fileOverview The reply comment view class for mobile.
 */
var BaseCommentView = require('annotations/thread/ui/comment/baseview');
var inherits = require('inherits');
var ThreadEvents = require('annotations/events').thread;

/**
 * Comment view.
 * @constructor
 * @extends {BaseCommentView}
 * @param {Object} opts Config options.
 */
var MobileReplyView = function(opts) {
    BaseCommentView.call(this, opts);
};
inherits(MobileReplyView, BaseCommentView);

/**
 * The CHANGE_VIEW event doesn't work in the mobile setup.
 * @override
 */
MobileReplyView.prototype._handleMoreClick = function () {
    this.$el.trigger(ThreadEvents.NAVIGATE, {
        model: this._model,
        value: 'etc'
    });
};

/** @override */
MobileReplyView.prototype.elClass = [
    BaseCommentView.CLASSES.COMMENT,
    BaseCommentView.CLASSES.REPLY
].join(' ');

/** @override */
MobileReplyView.prototype.events = (function() {
    var CLASSES = BaseCommentView.CLASSES;
    var events = {};
    events['tap .' + CLASSES.MORE_BTN] = '_handleMoreClick';
    return events;
})();

/** @override */
MobileReplyView.prototype.template = require('hgn!templates/mobile/reply');

module.exports = MobileReplyView;

});

define("hgn!templates/mobile/readmore", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<span class=\"lf-read-more\">");_.b("\n" + i);_.b("    <span class=\"lf-read-more-gradient\"></span>");_.b("\n" + i);_.b("    <span class=\"lf-read-more-text\">");_.b(_.v(_.d("strings.readMore",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("</span>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/mobile/comment", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-comment-container\">");_.b("\n" + i);_.b("    <img class=\"lf-comment-author-avatar\" src=\"");_.b(_.v(_.d("author.avatar",c,p,0)));_.b("\" />");_.b("\n" + i);_.b("    <header class=\"lf-comment-header\">");_.b("\n" + i);_.b("        <div class=\"lf-comment-header-upper\">");_.b("\n" + i);_.b("            <span class=\"lf-comment-author-name\">");_.b(_.t(_.d("author.displayName",c,p,0)));_.b("</span>");_.b("\n" + i);_.b(_.rp("tags",c,p,"            "));_.b("            <div class=\"lf-escape-button fycon-x\"></div>");_.b("\n" + i);_.b("        </div>");_.b("\n" + i);_.b("        <div class=\"lf-comment-header-lower\">");_.b("\n" + i);_.b("            <div class=\"lf-vote-count\">");_.b(_.v(_.f("voteCount",c,p,0)));_.b(" ");_.b(_.v(_.d("strings.voteCount",c,p,0)));_.b("</div>");_.b("\n" + i);_.b("        </div>");_.b("\n" + i);_.b("    </header>");_.b("\n" + i);_.b("    <section class=\"lf-comment-body\">");_.b("\n" + i);_.b("        ");_.b(_.t(_.f("body",c,p,0)));_.b("\n" + i);_.b("    </section>");_.b("\n" + i);_.b(_.rp("footer",c,p,"    "));_.b("</div>");_.b("\n" + i);if(_.s(_.f("hasReplies",c,p,1),c,p,0,643,763,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("<footer class='lf-comment-container-footer'>");_.b("\n" + i);_.b("    <span class=\"lf-reply-count\">");_.b(_.v(_.d("strings.replyLink",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("</footer>");_.b("\n");});c.pop();}_.b("<div class=\"lf-reply-container\"></div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/mobile/thread/ui/comment/view',['require','exports','module','jquery','annotations/thread/ui/comment/baseview','annotations/thread/ui/basethreadcontainer','inherits','annotations/mobile/thread/ui/comment/actions','annotations/mobile/thread/ui/comment/reply','annotations/mobile/thread/ui/comment/votecontainer','observer','hgn!templates/mobile/readmore','annotations/i18n/enumeration','annotations/events','hgn!templates/mobile/comment'],function (require, exports, module) {/**
 * @fileOverview The top level comment view class for mobile.
 */
var $ = require('jquery');
var BaseCommentView = require('annotations/thread/ui/comment/baseview');
var BaseThreadContainer = require('annotations/thread/ui/basethreadcontainer');
var inherits = require('inherits');
var MobileCommentActions = require('annotations/mobile/thread/ui/comment/actions');
var MobileReplyView = require('annotations/mobile/thread/ui/comment/reply');
var MobileVoteContainer = require('annotations/mobile/thread/ui/comment/votecontainer');
var Observer = require('observer');
var readMoreTemplate = require('hgn!templates/mobile/readmore');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;

/**
 * Comment view.
 * @constructor
 * @extends {BaseCommentView}
 * @param {Object} opts Config options.
 */
function MobileCommentView(opts) {
    Observer(this);
    BaseCommentView.call(this, opts);
}
inherits(MobileCommentView, BaseCommentView);

/** @enum {string} */
MobileCommentView.CLASSES = {
    CARD: 'lf-card',
    READ_MORE: 'lf-read-more',
    REPLY_CONTAINER: 'lf-reply-container',
    VOTE_COUNT: 'lf-vote-count'
};

/**
 * @return {boolean}
 * @private
 */
MobileCommentView.prototype._bodyOverflow = function () {
    var bodyEl = this.$bodyEl[0];
    return bodyEl.offsetHeight < bodyEl.scrollHeight;
};

/**
 * The CHANGE_VIEW event doesn't work in the mobile setup.
 * @param {jQuery.Event} ev
 * @override
 */
MobileCommentView.prototype._handleMoreClick = function (ev) {
    // prevent the event from refiring
    ev.preventDefault();
    this.$el.trigger(ThreadEvents.NAVIGATE, {
        model: this._model,
        value: 'etc'
    });
};

/** @override */
MobileCommentView.prototype.createActions = function () {
    var commentActions = new MobileCommentActions({
        model: this._model
    });
    this.listenTo(commentActions.getVoteContainer(), MobileVoteContainer.EVENTS.USER_VOTED,
        $.proxy(this.render, this));
    return commentActions;
};

/** @override */
MobileCommentView.prototype.events = (function() {
    var CLASSES = BaseCommentView.CLASSES;
    var events = {};
    events['tap .' + CLASSES.MORE_BTN] = '_handleMoreClick';
    return events;
})();

/** @override */
MobileCommentView.prototype.enterDocument = function () {
    if (this._bodyOverflow()) {
        this.addReadMore();
    }
};

/**
 * Add the read more link if a comment is truncated by overflow.
 */
MobileCommentView.prototype.addReadMore = function () {
    var link = readMoreTemplate({
        strings: {
            readMore: textEnumeration.get(textEnumeration.KEYS.COMMENT_READ_MORE)
        }
    });
    this.$bodyEl.append($(link));
};

/** @override */
MobileCommentView.prototype.destroy = function () {
    BaseCommentView.prototype.destroy.call(this);
    this.stopListening();
};

/** @override */
MobileCommentView.prototype.getTemplateContext = function() {
    var data = BaseCommentView.prototype.getTemplateContext.call(this);
    var KEYS = textEnumeration.KEYS;
    var replyLink;
    var voteCount;

    data.voteCount = this._model.votes.helpfulness;
    data.replyCount = this._model.replyCount;
    data.hasReplies = data.replyCount > 0;

    if (data.replyCount > 1) {
        replyLink = textEnumeration.get(KEYS.COMMENT_REPLY_LINK);
        replyLink = replyLink.replace('{number}', data.replyCount);
    } else {
        replyLink = textEnumeration.get(KEYS.COMMENT_REPLY_LINK_SING);
    }

    if (data.voteCount === 1) {
        voteCount = textEnumeration.get(KEYS.COMMENT_VOTE_COUNT_SING);
    } else {
        voteCount = textEnumeration.get(KEYS.COMMENT_VOTE_COUNT);
    }

    data.strings = data.strings || {};
    data.strings.voteCount = voteCount;
    data.strings.replyLink = replyLink;

    return data;
};

/**
 * Returns the reply thread container.
 * @return {?ThreadContainer}
 */
MobileCommentView.prototype.getThreadContainer = function() {
    return this._replyContainer;
};

/** @override */
MobileCommentView.prototype.render = function () {
    BaseCommentView.prototype.render.call(this);
    this.$bodyEl = this.$('.' + BaseCommentView.CLASSES.BODY);

    this._replyContainer = new BaseThreadContainer({
        commentConstructor: MobileReplyView,
        el: this.$('.'+ MobileCommentView.CLASSES.REPLY_CONTAINER)
    });
    this._replyContainer.render();
    this.enterDocument();
};

/** @override */
MobileCommentView.prototype.template = require('hgn!templates/mobile/comment');

module.exports = MobileCommentView;

});

define("hgn!templates/mobile/streamfooter", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");if(_.s(_.f("index",c,p,1),c,p,0,10,78,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("    <span>");_.b(_.v(_.f("index",c,p,0)));_.b(" ");_.b(_.v(_.d("strings.tally",c,p,0)));_.b(" ");_.b(_.v(_.f("streamCount",c,p,0)));_.b("</span>");_.b("\n");});c.pop();}if(_.s(_.f("loading",c,p,1),c,p,0,101,141,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("    <span>");_.b(_.v(_.d("strings.loading",c,p,0)));_.b("</span>");_.b("\n");});c.pop();}if(_.s(_.f("indexOne",c,p,1),c,p,0,167,359,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("    <span class=\"lf-pull-left\">");_.b("\n" + i);_.b("        <span class=\"fycon-arrow-left\"></span><span class=\"fycon-arrow-left\"></span>");_.b("\n" + i);_.b("        <span class=\"lf-invite-text\">");_.b(_.v(_.d("strings.write",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("    </span>");_.b("\n");});c.pop();}if(_.s(_.f("inviteRead",c,p,1),c,p,0,388,582,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("    <span class=\"lf-pull-right\">");_.b("\n" + i);_.b("        <span class=\"lf-invite-text\">");_.b(_.v(_.d("strings.read",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("        <span class=\"fycon-arrow-right\"></span><span class=\"fycon-arrow-right\"></span>");_.b("\n" + i);_.b("    </span>");_.b("\n");});c.pop();}if(_.s(_.f("inviteWrite",c,p,1),c,p,0,614,809,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("    <span class=\"lf-pull-right\">");_.b("\n" + i);_.b("        <span class=\"lf-invite-text\">");_.b(_.v(_.d("strings.write",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("        <span class=\"fycon-arrow-right\"></span><span class=\"fycon-arrow-right\"></span>");_.b("\n" + i);_.b("    </span>");_.b("\n");});c.pop();}return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/mobile/thread/ui/stream/footer',['require','exports','module','inherits','annotations/i18n/enumeration','view','hgn!templates/mobile/streamfooter'],function (require, exports, module) {var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');
var View = require('view');

/**
 * @constructor
 * @param {Object} opts
 * @extends {View}
 */
function MobileStreamFooter(opts) {
    View.call(this, opts);

    /**
     * @type {number}
     * @private
     */
    this._streamCount = 0;

    /**
     * @type {number}
     * @private
     */
    this._currIndex = 0;

    /**
     * @type {boolean}
     * @private
     */
    this._loading = true;
}
inherits(MobileStreamFooter, View);

MobileStreamFooter.CLASSES = {
    STREAM_FOOTER: 'lf-stream-footer'
};

/** @override */
MobileStreamFooter.prototype.elTag = 'footer';

/** @override */
MobileStreamFooter.prototype.elClass = MobileStreamFooter.CLASSES.STREAM_FOOTER;

/**
 * @return {number}
 */
MobileStreamFooter.prototype.getIndex = function () {
    return this._currIndex;
};

/**
 * @return {number}
 */
MobileStreamFooter.prototype.getStreamCount = function () {
    return this._streamCount;
};

/** @override */
MobileStreamFooter.prototype.getTemplateContext = function () {
    var KEYS = textEnumeration.KEYS;
    var index = this.getIndex();
    var count = this.getStreamCount();
    return {
        index: index,
        indexOne: index === 1,
        inviteRead: (count > 0 && !index),
        inviteWrite: (index === this._streamCount && this._streamCount !== 1),
        loading: this._loading,
        streamCount: this.getStreamCount(),
        strings: {
            loading: textEnumeration.get(KEYS.SLIDER_LOADING),
            read: textEnumeration.get(KEYS.SLIDER_INVITE_READ),
            tally: textEnumeration.get(KEYS.SLIDER_COMMENT_TALLY),
            write: textEnumeration.get(KEYS.SLIDER_INVITE_WRITE)
        }
    };
};

/**
 * @param {number} val
 */
MobileStreamFooter.prototype.setIndex = function (val) {
    this._currIndex = val;
};

/**
 * @param {number} val
 */
MobileStreamFooter.prototype.setStreamCount = function (val) {
    this._loading = false;
    this._streamCount = val;
};

/** @override */
MobileStreamFooter.prototype.template = require('hgn!templates/mobile/streamfooter');

module.exports = MobileStreamFooter;

});

define("hgn!templates/mobile/slide", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-slide\"></div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('swipe',[], function(require, exports, module) {/*
 * Swipe 2.0
 *
 * Brad Birdsall
 * Copyright 2013, MIT License
 *
*/

function Swipe(container, options) {

  

  // utilities
  var noop = function() {}; // simple no operation function
  var offloadFn = function(fn) { setTimeout(fn || noop, 0) }; // offload a functions execution

  // check browser capabilities
  var browser = {
    addEventListener: !!window.addEventListener,
    touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,
    transitions: (function(temp) {
      var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];
      for ( var i in props ) if (temp.style[ props[i] ] !== undefined) return true;
      return false;
    })(document.createElement('swipe'))
  };

  // quit if no root element
  if (!container) return;
  var element = container.children[0];
  var slides, slidePos, width, length;
  options = options || {};
  var index = parseInt(options.startSlide, 10) || 0;
  var speed = options.speed || 300;
  options.continuous = options.continuous !== undefined ? options.continuous : true;

  function setup() {

    // cache slides
    slides = element.children;
    length = slides.length;

    // set continuous to false if only one slide
    if (slides.length < 2) options.continuous = false;

    //special case if two slides
    if (browser.transitions && options.continuous && slides.length < 3) {
      element.appendChild(slides[0].cloneNode(true));
      element.appendChild(element.children[1].cloneNode(true));
      slides = element.children;
    }

    // create an array to store current positions of each slide
    slidePos = new Array(slides.length);

    // determine width of each slide
    width = container.getBoundingClientRect().width || container.offsetWidth;

    element.style.width = (slides.length * width) + 'px';

    // stack elements
    var pos = slides.length;
    while(pos--) {

      var slide = slides[pos];

      slide.style.width = width + 'px';
      slide.setAttribute('data-index', pos);

      if (browser.transitions) {
        slide.style.left = (pos * -width) + 'px';
        move(pos, index > pos ? -width : (index < pos ? width : 0), 0);
      }

    }

    // reposition elements before and after index
    if (options.continuous && browser.transitions) {
      move(circle(index-1), -width, 0);
      move(circle(index+1), width, 0);
    }

    if (!browser.transitions) element.style.left = (index * -width) + 'px';

    container.style.visibility = 'visible';

  }

  function prev() {

    if (options.continuous) slide(index-1);
    else if (index) slide(index-1);

  }

  function next() {

    if (options.continuous) slide(index+1);
    else if (index < slides.length - 1) slide(index+1);

  }

  function circle(index) {

    // a simple positive modulo using slides.length
    return (slides.length + (index % slides.length)) % slides.length;

  }

  function slide(to, slideSpeed) {

    // do nothing if already on requested slide
    if (index == to) return;

    if (browser.transitions) {

      var direction = Math.abs(index-to) / (index-to); // 1: backward, -1: forward

      // get the actual position of the slide
      if (options.continuous) {
        var natural_direction = direction;
        direction = -slidePos[circle(to)] / width;

        // if going forward but to < index, use to = slides.length + to
        // if going backward but to > index, use to = -slides.length + to
        if (direction !== natural_direction) to =  -direction * slides.length + to;

      }

      var diff = Math.abs(index-to) - 1;

      // move all the slides between index and to in the right direction
      while (diff--) move( circle((to > index ? to : index) - diff - 1), width * direction, 0);

      to = circle(to);

      move(index, width * direction, slideSpeed || speed);
      move(to, 0, slideSpeed || speed);

      if (options.continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place

    } else {

      to = circle(to);
      animate(index * -width, to * -width, slideSpeed || speed);
      //no fallback for a circular continuous if the browser does not accept transitions
    }

    index = to;
    offloadFn(options.callback && options.callback(index, slides[index]));
  }

  function move(index, dist, speed) {

    translate(index, dist, speed);
    slidePos[index] = dist;

  }

  function translate(index, dist, speed) {

    var slide = slides[index];
    var style = slide && slide.style;

    if (!style) return;

    style.webkitTransitionDuration =
    style.MozTransitionDuration =
    style.msTransitionDuration =
    style.OTransitionDuration =
    style.transitionDuration = speed + 'ms';

    style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';
    style.msTransform =
    style.MozTransform =
    style.OTransform = 'translateX(' + dist + 'px)';

  }

  function animate(from, to, speed) {

    // if not an animation, just reposition
    if (!speed) {

      element.style.left = to + 'px';
      return;

    }

    var start = +new Date;

    var timer = setInterval(function() {

      var timeElap = +new Date - start;

      if (timeElap > speed) {

        element.style.left = to + 'px';

        if (delay) begin();

        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);

        clearInterval(timer);
        return;

      }

      element.style.left = (( (to - from) * (Math.floor((timeElap / speed) * 100) / 100) ) + from) + 'px';

    }, 4);

  }

  // setup auto slideshow
  var delay = options.auto || 0;
  var interval;

  function begin() {

    interval = setTimeout(next, delay);

  }

  function stop() {

    delay = 0;
    clearTimeout(interval);

  }


  // setup initial vars
  var start = {};
  var delta = {};
  var isScrolling;

  // setup event capturing
  var events = {

    handleEvent: function(event) {

      switch (event.type) {
        case 'touchstart': this.start(event); break;
        case 'touchmove': this.move(event); break;
        case 'touchend': offloadFn(this.end(event)); break;
        case 'webkitTransitionEnd':
        case 'msTransitionEnd':
        case 'oTransitionEnd':
        case 'otransitionend':
        case 'transitionend': offloadFn(this.transitionEnd(event)); break;
        case 'resize': offloadFn(setup); break;
      }

      if (options.stopPropagation) event.stopPropagation();

    },
    start: function(event) {

      var touches = event.touches[0];

      // measure start values
      start = {

        // get initial touch coords
        x: touches.pageX,
        y: touches.pageY,

        // store time to determine touch duration
        time: +new Date

      };

      // used for testing first move event
      isScrolling = undefined;

      // reset delta and end measurements
      delta = {};

      // attach touchmove and touchend listeners
      element.addEventListener('touchmove', this, false);
      element.addEventListener('touchend', this, false);

    },
    move: function(event) {

      // ensure swiping with one touch and not pinching
      if ( event.touches.length > 1 || event.scale && event.scale !== 1) return

      if (options.disableScroll) event.preventDefault();

      var touches = event.touches[0];

      // measure change in x and y
      delta = {
        x: touches.pageX - start.x,
        y: touches.pageY - start.y
      }

      // determine if scrolling test has run - one time test
      if ( typeof isScrolling == 'undefined') {
        isScrolling = !!( isScrolling || Math.abs(delta.x) < Math.abs(delta.y) );
        isScrolling || options.slideMove && options.slideMove.call(event, slides[index]);
      }

      // if user is not trying to scroll vertically
      if (!isScrolling) {

        // prevent native scrolling
        event.preventDefault();

        // stop slideshow
        stop();

        // increase resistance if first or last slide
        if (options.continuous) { // we don't add resistance at the end

          translate(circle(index-1), delta.x + slidePos[circle(index-1)], 0);
          translate(index, delta.x + slidePos[index], 0);
          translate(circle(index+1), delta.x + slidePos[circle(index+1)], 0);

        } else {

          delta.x =
            delta.x /
              ( (!index && delta.x > 0               // if first slide and sliding left
                || index == slides.length - 1        // or if last slide and sliding right
                && delta.x < 0                       // and if sliding at all
              ) ?
              ( Math.abs(delta.x) / width + 1 )      // determine resistance level
              : 1 );                                 // no resistance if false

          // translate 1:1
          translate(index-1, delta.x + slidePos[index-1], 0);
          translate(index, delta.x + slidePos[index], 0);
          translate(index+1, delta.x + slidePos[index+1], 0);
        }

      }

    },
    end: function(event) {

      // measure duration
      var duration = +new Date - start.time;

      // determine if slide attempt triggers next/prev slide
      var isValidSlide =
            Number(duration) < 250               // if slide duration is less than 250ms
            && Math.abs(delta.x) > 20            // and if slide amt is greater than 20px
            || Math.abs(delta.x) > width/2;      // or if slide amt is greater than half the width

      // determine if slide attempt is past start and end
      var isPastBounds =
            !index && delta.x > 0                            // if first slide and slide amt is greater than 0
            || index == slides.length - 1 && delta.x < 0;    // or if last slide and slide amt is less than 0

      if (options.continuous) isPastBounds = false;

      // determine direction of swipe (true:right, false:left)
      var direction = delta.x < 0;

      // if not scrolling vertically
      if (!isScrolling) {

        if (isValidSlide && !isPastBounds) {

          if (direction) {

            if (options.continuous) { // we need to get the next in this direction in place

              move(circle(index-1), -width, 0);
              move(circle(index+2), width, 0);

            } else {
              move(index-1, -width, 0);
            }

            move(index, slidePos[index]-width, speed);
            move(circle(index+1), slidePos[circle(index+1)]-width, speed);
            index = circle(index+1);

          } else {
            if (options.continuous) { // we need to get the next in this direction in place

              move(circle(index+1), width, 0);
              move(circle(index-2), -width, 0);

            } else {
              move(index+1, width, 0);
            }

            move(index, slidePos[index]+width, speed);
            move(circle(index-1), slidePos[circle(index-1)]+width, speed);
            index = circle(index-1);

          }

          options.callback && options.callback(index, slides[index]);

        } else {

          if (options.continuous) {

            move(circle(index-1), -width, speed);
            move(index, 0, speed);
            move(circle(index+1), width, speed);

          } else {

            move(index-1, -width, speed);
            move(index, 0, speed);
            move(index+1, width, speed);
          }

        }

      }

      // kill touchmove and touchend event listeners until touchstart called again
      element.removeEventListener('touchmove', events, false)
      element.removeEventListener('touchend', events, false)

    },
    transitionEnd: function(event) {

      if (parseInt(event.target.getAttribute('data-index'), 10) == index) {

        if (delay) begin();

        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);

      }

    }

  }

  // trigger setup
  setup();

  // start auto slideshow if applicable
  if (delay) begin();


  // add event listeners
  if (browser.addEventListener) {

    // set touchstart event on element
    if (browser.touch) element.addEventListener('touchstart', events, false);

    if (browser.transitions) {
      element.addEventListener('webkitTransitionEnd', events, false);
      element.addEventListener('msTransitionEnd', events, false);
      element.addEventListener('oTransitionEnd', events, false);
      element.addEventListener('otransitionend', events, false);
      element.addEventListener('transitionend', events, false);
    }

    // set resize event on window
    window.addEventListener('resize', events, false);

  } else {

    window.onresize = function () { setup() }; // to play nice with old IE

  }

  // expose the Swipe API
  return {
    setup: function() {

      setup();

    },
    slide: function(to, speed) {

      // cancel slideshow
      stop();

      slide(to, speed);

    },
    prev: function() {

      // cancel slideshow
      stop();

      prev();

    },
    next: function() {

      // cancel slideshow
      stop();

      next();

    },
    stop: function() {

      // cancel slideshow
      stop();

    },
    getPos: function() {

      // return current index position
      return index;

    },
    getNumSlides: function() {

      // return total number of slides
      return length;
    },
    kill: function() {

      // cancel slideshow
      stop();

      // reset element
      element.style.width = '';
      element.style.left = '';

      // reset slides
      var pos = slides.length;
      while(pos--) {

        var slide = slides[pos];
        slide.style.width = '';
        slide.style.left = '';

        if (browser.transitions) translate(pos, 0, 0);

      }

      // removed event listeners
      if (browser.addEventListener) {

        // remove current event listeners
        element.removeEventListener('touchstart', events, false);
        element.removeEventListener('webkitTransitionEnd', events, false);
        element.removeEventListener('msTransitionEnd', events, false);
        element.removeEventListener('oTransitionEnd', events, false);
        element.removeEventListener('otransitionend', events, false);
        element.removeEventListener('transitionend', events, false);
        window.removeEventListener('resize', events, false);

      }
      else {

        window.onresize = null;

      }

    }
  }

}


if ( window.jQuery || window.Zepto ) {
  (function($) {
    $.fn.Swipe = function(params) {
      return this.each(function() {
        $(this).data('Swipe', new Swipe($(this)[0], params));
      });
    }
  })( window.jQuery || window.Zepto )
}
 module.exports = Swipe;});
define("hgn!templates/mobile/writeslide", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<header class=\"lf-write-header\">");_.b("\n" + i);_.b("    <span class=\"lf-write-title\">");_.b(_.v(_.d("strings.title",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("    <div class=\"lf-escape-button fycon-x\"></div>");_.b("\n" + i);if(_.s(_.f("userLoggedIn",c,p,1),c,p,0,161,250,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("        <div class=\"lf-user-settings\"><div class=\"fycon-settings-gear\"></div></div>");_.b("\n");});c.pop();}_.b("</header>");_.b("\n" + i);_.b("<section class=\"lf-write-body\">");_.b("\n" + i);_.b("    <span class=\"lf-write-text\">");_.b(_.v(_.d("strings.text",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("</section>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/mobile/thread/ui/stream/writeslide',['require','exports','module','jquery','auth','inherits','observer','annotations/i18n/enumeration','annotations/events','view','hgn!templates/mobile/writeslide'],function (require, exports, module) {var $ = require('jquery');
var auth = require('auth');
var inherits = require('inherits');
var Observer = require('observer');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;
var View = require('view');

/**
 * @constructor
 * @extends {View}
 * @param {Object} opts
 */
function WriteSlide (opts) {
    View.call(this, opts);
    Observer(this);
    this.listenTo(auth, 'login.livefyre', $.proxy(this.render, this));
    this.listenTo(auth, 'logout', $.proxy(this.render, this));
}
inherits(WriteSlide, View);

/** @enum {string} */
WriteSlide.CLASSES = {
    USER_SETTINGS: 'lf-user-settings'
};

/**
 * @param {jQuery.Event} ev
 * @private
 */
WriteSlide.prototype._handleSettingsTap = function (ev) {
    ev.stopPropagation();
    this.$el.trigger(ThreadEvents.NAVIGATE, {
        value: 'user'
    });
};

/** @override */
WriteSlide.prototype.elClass = 'lf-write-card';

/** @override */
WriteSlide.prototype.events = (function () {
    var events = {};
    events['tap .' + WriteSlide.CLASSES.USER_SETTINGS] = '_handleSettingsTap';
    return events;
})();

/** @override */
WriteSlide.prototype.template = require('hgn!templates/mobile/writeslide');

/** @override */
WriteSlide.prototype.getTemplateContext = function () {
    var KEYS = textEnumeration.KEYS;
    return {
        userLoggedIn: auth.get('livefyre'),
        strings: {
            title: textEnumeration.get(KEYS.EDITOR_TITLE),
            text: textEnumeration.get(KEYS.SLIDER_WRITE_TEXT)
        }
    };
};

/** @override */
WriteSlide.prototype.destroy = function () {
    View.prototype.destroy.call(this);
    this.stopListening();
};

module.exports = WriteSlide;

});

define("hgn!templates/mobile/stream", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-swipe-wrapper\"></div>");_.b("\n" + i);_.b("<footer class=\"lf-stream-footer\"></footer>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/mobile/thread/ui/stream/view',['require','exports','module','jquery','annotations/util/array','annotations/thread/ui/basethreadcontainer','annotations/thread/ui/comment/actions','view/delegate','inherits','livefyre-bootstrap/loader','hgn!templates/mobile/loadercard','annotations/mobile/thread/ui/comment/view','annotations/mobile/thread/ui/stream/footer','annotations/util/auth','hgn!templates/mobile/slide','annotations/util/sorting','swipe','annotations/events','view','annotations/enums','annotations/events','annotations/mobile/thread/ui/stream/writeslide','hgn!templates/mobile/stream'],function (require, exports, module) {/**
 * @fileOverview The stream view class. For mobile, we only display one top level comment
 * at a time.
 */

var $ = require('jquery');
var ArrayUtil = require('annotations/util/array');
var BaseThreadContainer = require('annotations/thread/ui/basethreadcontainer');
var CommentActions = require('annotations/thread/ui/comment/actions');
var delegate = require('view/delegate');
var inherits = require('inherits');
var loader = require('livefyre-bootstrap/loader');
var loadercardTemplate = require('hgn!templates/mobile/loadercard');
var MobileCommentView = require('annotations/mobile/thread/ui/comment/view');
var MobileStreamFooter = require('annotations/mobile/thread/ui/stream/footer');
var requireAuth = require('annotations/util/auth').requireAuth;
var slideTemplate = require('hgn!templates/mobile/slide');
var SortingUtil = require('annotations/util/sorting');
var Swipe = require('swipe');
var ThreadEvents = require('annotations/events').thread;
var View = require('view');
var viewEnum = require('annotations/enums').navigableViews;
var WriteEvents = require('annotations/events').write;
var WriteSlide = require('annotations/mobile/thread/ui/stream/writeslide');

/**
 * Stream view.
 * @constructor
 * @extends {BaseThreadContainer}
 * @param {Object} opts Config options.
 */
var MobileStreamView = function (opts) {
    opts = opts || {};
    opts.commentConstructor = MobileCommentView;
    BaseThreadContainer.call(this, opts);

    /**
     * Set of all the replies mapped to their parent comments
     * @type {Object}
     * @private
     */
    this._replies = {};

    /**
     * Set of all the replies that we know about
     * @type {Object}
     * @private
     */
    this._replyIds = {};

    /**
     * @type {?Swipe}
     * @private
     */
    this._swipe = null;

    /**
     * @type {MobileStreamFooter}
     * @private
     */
    this._streamFooter = new MobileStreamFooter();
};
inherits(MobileStreamView, BaseThreadContainer);

/** @enum {string} */
MobileStreamView.CLASSES = {
    CONTAINER_FOOTER: 'lf-comment-container-footer',
    ESCAPE: 'lf-escape-button',
    LOADER: 'lf-loader-container',
    LOADER_CARD: 'lf-loader-card',
    SLIDE: 'lf-slide',
    STREAM: 'lf-stream',
    STREAM_FOOTER: 'lf-stream-footer',
    WRAPPER: 'lf-swipe-wrapper'
};

/** @const {number} */
MobileStreamView.SLIDE_OFFSET = 1;

/** @const {number} */
MobileStreamView.MAX_COMMENT_HEIGHT = 250;

/**
 * Slide to the position of the added comment (unless it was pending)
 * @param {Comment} comment
 * @private
 */
MobileStreamView.prototype._handleNewComment = function(comment) {
    if (comment.isPending()) {
        return;
    }
    var idx = this._commentIds.indexOf(comment.id);
    if (idx === -1 && comment.parentId) {
        idx = this._commentIds.indexOf(comment.parentId);
    }
    if (idx === -1) {
        return;
    }
    this._swipe.slide(idx + MobileStreamView.SLIDE_OFFSET);
};

/**
 * @param {View} view
 * @param {number} idx
 * @param {jQuery.Element=} opt_el
 * @private
 */
MobileStreamView.prototype._addSlide = function (view, idx, opt_el) {
    var $el = opt_el || this.getContainerElement();
    var children = $el.children();
    view.render();
    var slide = $(slideTemplate());
    slide.append(view.$el);
    if (idx >= children.length) {
        $el.append(slide);
    } else {
        children.eq(idx).before(slide);
    }
};

/**
 * @param {jQuery.Element} ev
 * @param {Object} opts
 * @private
 */
MobileStreamView.prototype._handleReplyClick = requireAuth(function (ev, opts) {
    var currComment = this.getCurrentComment();
    this.$el.trigger(ThreadEvents.NAVIGATE, {
        value: viewEnum.EDITOR,
        parentId: currComment.id,
        editorId: currComment.id
    });
}, WriteEvents.POST_REPLY);

/**
 * The first card, links out to the editor.
 * @param {jQuery.Element=|Element} opt_el
 * @private
 */
MobileStreamView.prototype._addWriteCard = function (opt_el) {
    this._writeSlide = new WriteSlide();
    this._addSlide(this._writeSlide, 0, $(opt_el));
};

/**
 * @private
 */
MobileStreamView.prototype._handleSlideMove = function () {
    this._setMaxHeight();
};

/**
 * @private
 */
MobileStreamView.prototype._handleShowReplies = function () {
    var currComment = this.getCurrentComment();
    this.$el.trigger(ThreadEvents.NAVIGATE, {
        value: viewEnum.REPLIES,
        topComment: currComment,
        replies: this._replies[currComment.id] || []
    });
};

/**
 * Handle a slide change
 * @private
 */
MobileStreamView.prototype._handleSlideChange = function () {
    var currComment = this.getCurrentComment();
    this._highlightSelection(currComment);

    this._streamFooter.setIndex(this._swipe.getPos());
    this._streamFooter.render();
};

/**
 * @param {jQuery.Element} ev
 * @param {Object} opts
 * @private
 */
MobileStreamView.prototype._handleWriteClick = function (ev, opts) {
    if (ev.target.className.indexOf(MobileStreamView.CLASSES.ESCAPE) > -1) {
        return;
    }

    this._handlePostAnnotation(ev, opts);
};

/**
 * Navigate to the editor after auth.
 * @param {jQuery.Element} ev
 * @param {Object} opts
 * @private
 */
MobileStreamView.prototype._handlePostAnnotation = requireAuth(function (ev, opts) {
    this.$el.trigger(ThreadEvents.NAVIGATE, {
        value: viewEnum.EDITOR,
        editorId: this.opts.blockId
    });
}, WriteEvents.POST_ANNOTATION);

/**
 * Handle the escape click event.
 * @param {jQuery.Element} ev
 * @private
 */
MobileStreamView.prototype._handleThreadEscape = function (ev) {
    // prevent the event from firing once the thread is closed.
    ev.preventDefault();
    this.$el.trigger(ThreadEvents.DESTROY_THREAD);
};

/**
 * @private
 * @param {Comment} currComment
 */
MobileStreamView.prototype._highlightSelection = function (currComment) {
    var selectedText;
    if (currComment) {
        // Could be the WriteCard
        selectedText = currComment.selectedText;
    }
    this.$el.trigger(ThreadEvents.DEACTIVATE_HIGHLIGHTED_TEXT);
    if (selectedText) {
        this.$el.trigger(ThreadEvents.ACTIVATE_HIGHLIGHTED_TEXT, {
            selectedText: selectedText,
            blockId: currComment.blockId
        });
    }
};

/**
 * Set the wrapper to the height of the contained comment
 * @private
 */
MobileStreamView.prototype._matchSlideHeight = function () {
    var pos = this._swipe.getPos();
    var slideHeight = $(this.$wrapperEl.children()[pos].firstChild).outerHeight();
    this.$wrapperEl.height(slideHeight);
};

/**
 * Set the wrapper to the max comment height
 * @private
 */
MobileStreamView.prototype._setMaxHeight = function () {
    this.$wrapperEl.height(MobileStreamView.MAX_COMMENT_HEIGHT);
};

/** @override */
MobileStreamView.prototype.addComment = function (comments) {
    // Slider is not amenable (ATM) to dynamic additions.
    if (!$.isArray(comments)) {
        comments = [comments];
    }
    this.reinitialize(comments);
    this._handleNewComment(comments[0]);
};

/** @override */
MobileStreamView.prototype.comparator = SortingUtil.helpfulnessComparator;

/** @override */
MobileStreamView.prototype.destroy = function () {
    BaseThreadContainer.prototype.destroy.call(this);
    this._streamFooter && this._streamFooter.destroy();
    this._swipe.kill();
};

/** @override */
MobileStreamView.prototype.elClass = MobileStreamView.CLASSES.STREAM;

/** @override */
MobileStreamView.prototype.elTag = 'section';

/** @override */
MobileStreamView.prototype.enterDocument = function () {
    var commentView;
    var commentId;
    for (var i = this._commentIds.length - 1; i >= 0; i--) {
        commentId = this._commentIds[i];
        commentView = this._comments[commentId];
        commentView.enterDocument();
    }
};

/**
 * Overriden so that swipe "owns" the root el and can stopPropagation there.
 * @override
 */
MobileStreamView.prototype.delegateEvents = function (events) {
    if (!this.$wrapperEl) return;
    if (!(events || (events = this.events))) {
        return this;
    }
    delegate.delegateEvents(this.$wrapperEl, events, this.uid, this);
    return this;
};


/** @override */
MobileStreamView.prototype.events = (function () {
    var events = {};
    events['tap .' + MobileStreamView.CLASSES.ESCAPE] = '_handleThreadEscape';
    events['tap .' + MobileStreamView.CLASSES.CONTAINER_FOOTER] = '_handleShowReplies';
    events['tap .' + MobileCommentView.CLASSES.READ_MORE] = '_handleShowReplies';
    events['tap .' + CommentActions.CLASSES.REPLY_BTN] = '_handleReplyClick';
    events['tap .' + WriteSlide.prototype.elClass] = '_handleWriteClick';
    events[ThreadEvents.SLIDE_TO_COMMENT] = '_handleNewComment';
    return events;
})();

/** @override */
MobileStreamView.prototype.getContainerElement = function () {
    return this.$wrapperEl;
};

/**
 * @return {Comment=}
 */
MobileStreamView.prototype.getCurrentComment = function () {
    var pos = this._swipe.getPos();
    var commentId = this._commentIds[pos - MobileStreamView.SLIDE_OFFSET];
    // ensure is not the WriteCard or NaN
    if (commentId) {
        return this._comments[commentId].getModel();
    }
};

/** @override */
MobileStreamView.prototype.initialize = function (comments) {
    // Cleanup the loader
    this._loaderView && this._loaderView.destroy();
    this._loaderView = null;
    var comment;
    var parentId;
    var topComments = [];
    comments = comments || [];
    for (var i = comments.length - 1; i >= 0; i--) {
        comment = comments[i];
        parentId = comment.parentId;
        if (parentId) {
            this._replies[parentId] = this._replies[parentId] || [];
            !this._replyIds[comment.id] && this._replies[parentId].push(comment);
            this._replyIds[comment.id] = true;
            continue;
        }
        if (!comment.isVisible()) {
            continue;
        }
        topComments.push(comment);
    }
    var fragment = document.createDocumentFragment();
    $.each(topComments, $.proxy(this.processComment, this, false, $(fragment)));
    this._addWriteCard(fragment);
    this.getContainerElement().append(fragment);
    this.enterDocument();

    var startSlide = this._commentIds.length > 0 ? 1 : 0;
    this._swipe = Swipe(this.el, {
        callback: $.proxy(this._handleSlideChange, this),
        continuous: topComments.length > 1,
        disableScroll: true,
        slideMove: $.proxy(this._handleSlideMove, this),
        startSlide: startSlide,
        stopPropagation: true,
        transitionEnd: $.proxy(this._matchSlideHeight, this)
    });
    this._streamFooter.setStreamCount(this._commentIds.length);
    this._handleSlideChange();
    this._matchSlideHeight();
    this.delegateEvents();
};

/** override */
MobileStreamView.prototype.reinitialize = function(comments) {
    this._swipe && this._swipe.kill();
    this._setMaxHeight();
    BaseThreadContainer.prototype.reinitialize.call(this, comments);
};

/** override */
MobileStreamView.prototype.template = require('hgn!templates/mobile/stream');

/** @override */
MobileStreamView.prototype.processComment = function (prepend, el, i, comment) {
    if (!!this._comments[comment.id]) {
        return;
    }

    var replyCount = this._replies[comment.id];  // hackety hack
    if (replyCount) {
        comment.replyCount = replyCount.length;
    }

    var commentView = new this._commentConstructor(this._getCommentOptions(comment));
    this._comments[comment.id] = commentView;

    var comparatorFn = $.proxy(this.comparator, this);
    var idx = ArrayUtil.findIndex(this._commentIds, comment.id, comparatorFn);
    this._addSlide(commentView, idx, el);

    if (idx >= this._commentIds.length) {
        this._commentIds.push(comment.id);
        return;
    }
    this._commentIds.splice(idx, 0, comment.id);
};

/** @override */
MobileStreamView.prototype.render = function () {
    View.prototype.render.call(this);
    var CLASSES = MobileStreamView.CLASSES;
    this._streamFooter.setElement(this.$('.' + CLASSES.STREAM_FOOTER));
    this._streamFooter.render();
    this.$wrapperEl = this.$('.' + CLASSES.WRAPPER);

    this._loaderView = new View();
    this._loaderView.template = loadercardTemplate;
    this._loaderView.$el.addClass(MobileStreamView.CLASSES.LOADER_CARD);
    this._loaderView.render();
    loader.decorate(this._loaderView.$('.' + MobileStreamView.CLASSES.LOADER), 60);

    this._streamFooter.$el.before(this._loaderView.$el);
};

module.exports = MobileStreamView;

});

define("hgn!templates/mobile/threadpopover", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf lf-popover-content\"></div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/mobile/thread/ui/threadpopover',['require','exports','module','jquery','annotations/util/dom','inherits','annotations/mobile/thread/ui/stream/view','annotations/ui/popover','hgn!templates/mobile/threadpopover'],function (require, exports, module) {/**
 * @fileoverview The thread card popover for the mobile threadview.
 */
var $ = require('jquery');
var domUtil = require('annotations/util/dom');
var inherits = require('inherits');
var MAX_COMMENT_HEIGHT = require('annotations/mobile/thread/ui/stream/view').MAX_COMMENT_HEIGHT;
var Popover = require('annotations/ui/popover');

/**
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
function MobileThreadPopover (opts) {
    opts = opts || {};
    Popover.call(this, $.extend({
        minPopoverInView: MAX_COMMENT_HEIGHT,
        scrollDuration: 500,
        topSpacing: 10
    }, opts));

    /**
     * @type {?jQuery}
     */
    this.$_contentElements = null;

    var rootContentEl = opts.rootContentEl || document.body;
    /**
     * @type {jQuery.Element}
     */
    this.$_rootContentEl = $(rootContentEl);
}
inherits(MobileThreadPopover, Popover);

/** @enum {string} */
MobileThreadPopover.CLASSES = (function () {
    var CLASSES = {};
    $.extend(CLASSES, Popover.CLASSES);
    CLASSES.FULLSCREEN = 'lf-fullscreen';
    CLASSES.LF = 'lf';
    CLASSES.MAIN = 'lf-thread-popover';
    CLASSES.POPOVER = 'lf-mobile-popover';
    return CLASSES;
})();

/** @override */
MobileThreadPopover.prototype.elClass = [
    MobileThreadPopover.CLASSES.POPOVER,
    MobileThreadPopover.CLASSES.MAIN
].join(' ');

/** @override */
MobileThreadPopover.prototype.template = require('hgn!templates/mobile/threadpopover');

/** @override */
MobileThreadPopover.prototype.resizeAndReposition = function (blockEl) {
    var boundingRect = domUtil.getBoundingClientRect(blockEl);
    var top = boundingRect.bottom + domUtil.getScrollY() + 10;
    this._scrollIntoPosition(top);
};

/**
 * Set a class so that that popover takes up the entire screen.
 */
MobileThreadPopover.prototype.setFullScreen = function () {
    var CLASSES = MobileThreadPopover.CLASSES;
    this.$el.addClass(CLASSES.FULLSCREEN);
    this.$_contentNode.addClass(CLASSES.FULLSCREEN);
    this.$el.children().addClass(CLASSES.FULLSCREEN);
    if (this.$_contentElements) {
        return;
    }
    this.$_contentElements = this.$_rootContentEl.children().filter(function () {
        return this.className.indexOf(CLASSES.LF) === -1 && $(this).is(':visible');
    });
    this.$_contentElements.hide();
    this.$el.show();
};

/**
 * Back to regular size
 */
MobileThreadPopover.prototype.unsetFullScreen = function () {
    var CLASSES = MobileThreadPopover.CLASSES;
    this.$el.removeClass(CLASSES.FULLSCREEN);
    this.$_contentNode.removeClass(CLASSES.FULLSCREEN);
    this.$el.children().removeClass(CLASSES.FULLSCREEN);
    if (!this.$_contentElements) {
        return;
    }
    this.$_contentElements.show();
    this.$_contentElements = null;
};

module.exports = MobileThreadPopover;

});

define('annotations/thread/ui/thread/baseview',['require','exports','module','jquery','annotations/util/internals','auth','inherits','observer','view'],function (require, exports, module) {/**
 * @fileOverview The thread view class. This is the base view that loads the
 * editor and stream views. This is what gets loaded when the popover shows.
 */

var $ = require('jquery');
var abstractMethod = require('annotations/util/internals').abstractMethod;
var auth = require('auth');
var inherits = require('inherits');
var Observer = require('observer');
var View = require('view');

/**
 * Stream view.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
var ThreadView = function(opts) {
    View.call(this, opts);

    /**
     * Stream view.
     * @type {StreamView}
     * @private
     */
    this._streamView = this.createStreamView();

    // Bind login and logout events.
    Observer(this);
    this.listenTo(auth, 'login.livefyre', $.proxy(this._handleUserLogin, this));
    this.listenTo(auth, 'logout', $.proxy(this._handleUserLogout, this));
};
inherits(ThreadView, View);

/** @enum {string} */
ThreadView.CLASSES = {
    LOADER: 'lf-loader',
    THREAD: 'lf-thread'
};

/** @override */
ThreadView.prototype.elClass = ThreadView.CLASSES.THREAD;

/** @override */
ThreadView.prototype.elTag = 'section';

/**
 * Handle the user login event.
 * @abstract
 * @private
 */
ThreadView.prototype._handleUserLogin = abstractMethod;

/**
 * Handle the user logout event.
 * @abstract
 * @private
 */
ThreadView.prototype._handleUserLogout = abstractMethod;


/** @override */
ThreadView.prototype.destroy = function() {
    View.prototype.destroy.call(this);
    this.stopListening();
};

/**
 * Handle the thread retrieval failure response.
 * @abstract
 * @param {string} err Err info.
 */
ThreadView.prototype.handleFetchThreadFailure = abstractMethod;

/**
 * Handle the thread retrieval success response, or the case of a new thread
 * with no content yet. Load the thread view the way FSM intended, with an
 * editor and content.
 * @abstract
 * @param {?Array.<Comment>} opt_comments Thread data.
 */
ThreadView.prototype.handleFetchThreadSuccess = abstractMethod;

/**
 * @return {StreamView}
 */
ThreadView.prototype.getStreamView = function () {
    return this._streamView;
};

/**
 * @abstract
 * @return {StreamView}
 */
ThreadView.prototype.createStreamView = abstractMethod;

module.exports = ThreadView;

});

define('annotations/mobile/thread/ui/thread/view',['require','exports','module','inherits','annotations/mobile/thread/ui/stream/view','annotations/util/internals','annotations/thread/ui/thread/baseview'],function (require, exports, module) {var inherits = require('inherits');
var MobileStreamView = require('annotations/mobile/thread/ui/stream/view');
var nullFunction = require('annotations/util/internals').nullFunction;
var ThreadView = require('annotations/thread/ui/thread/baseview');

/**
 * Stream view.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
var MobileThreadView = function(opts) {
    ThreadView.call(this, opts);
};
inherits(MobileThreadView, ThreadView);

/**
 * Handle the user login event.
 * @private
 */
MobileThreadView.prototype._handleUserLogin = nullFunction;

/**
 * Handle the user logout event.
 * @private
 */
MobileThreadView.prototype._handleUserLogout = nullFunction;

/** @override */
MobileThreadView.prototype.createStreamView = function () {
    return new MobileStreamView({
        blockId: this.opts.blockId
    });
};

/** @override */
MobileThreadView.prototype.handleFetchThreadSuccess = function (opt_comments) {
    // If there are comments show the streamview
    this._streamView.initialize(opt_comments);
};

/** @return {MobileStreamView} */
MobileThreadView.prototype.getThreadContainer = function () {
    return this._streamView;
};

/** @override */
MobileThreadView.prototype.render = function () {
    ThreadView.prototype.render(this);
    this._streamView.render();
    this.$el.prepend(this._streamView.$el);
};

module.exports = MobileThreadView;

});

define('annotations/mobile/thread/ui/menu/question',['require','exports','module','jquery','inherits','annotations/thread/ui/navigable','annotations/i18n/enumeration','hgn!templates/blocks/questionpopover'],function (require, exports, module) {/**
 * @fileOverview Auth menu view. This shows when a user tries to do something
 * that requires authentication.
 */

var $ = require('jquery');
var inherits = require('inherits');
var Navigable = require('annotations/thread/ui/navigable');
var textEnumeration = require('annotations/i18n/enumeration');

/**
 * Mobile equivalent of the question popover, explains Sidenotes.
 * @constructor
 * @extends {Navigable}
 * @param {Object} opts Config options.
 */
function QuestionMenu(opts) {
    Navigable.call(this, opts);
}
inherits(QuestionMenu, Navigable);

/** @override */
QuestionMenu.prototype.events = Navigable.prototype.events;

/** @override */
QuestionMenu.prototype.getTemplateContext = function () {
    var data = Navigable.prototype.getTemplateContext.call(this);
    var KEYS = textEnumeration.KEYS;
    $.extend(data.strings, {
        explanation: textEnumeration.get(KEYS.QUESTION_EXPLANATION),
        mockText: textEnumeration.get(KEYS.QUESTION_MOCK_TEXT),
        title: textEnumeration.get(KEYS.QUESTION_TITLE)
    });
    return data;
};

/** @override */
QuestionMenu.prototype.subTemplate = require('hgn!templates/blocks/questionpopover');

module.exports = QuestionMenu;

});

define("hgn!templates/thread/threadcontainer", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<section class=\"lf-thread-container\"></section>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/thread/editorerror", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-editor-error\">");_.b("\n" + i);_.b("    <a class=\"lf-close fycon-x\"></a>");_.b("\n" + i);_.b("    <span>");_.b(_.t(_.f("msg",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("</div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/thread/editor", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-editor-resize\" />");_.b("\n" + i);_.b("<textarea class='lf-editor-field'></textarea>");_.b("\n" + i);_.b("<a class='lf-editor-post-btn'>");_.b(_.v(_.d("strings.postBtn",c,p,0)));_.b("</a>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/editorview',['require','exports','module','jquery','annotations/thread/ui/baseeditorview','annotations/events','annotations/util/editor','hgn!templates/thread/editorerror','inherits','annotations/i18n/enumeration','annotations/events','hgn!templates/thread/editor'],function (require, exports, module) {/**
 * @fileOverview The editor view class. This contains the editor box and any
 * buttons that go along with it.
 */

var $ = require('jquery');
var BaseEditorView = require('annotations/thread/ui/baseeditorview');
var EditorEvents = require('annotations/events').editor;
var editorUtil = require('annotations/util/editor');
var errorTemplate = require('hgn!templates/thread/editorerror');
var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;

/**
 * Editor view.
 * @constructor
 * @extends {BaseEditorView}
 * @param {Object} opts Config options.
 */
function EditorView(opts) {
    BaseEditorView.call(this, opts);

    /**
     * Hide the editor when it blurs and there is no content.
     * @type {boolean}
     */
    this._hideOnBlur = !!opts.hideOnBlur;

    /**
     * Whether the post button is visible or not.
     * @type {boolean}
     * @private
     */
    this._isPostBtnVisible = true;

    /**
     * Currently posting a comment.
     * @type {boolean}
     * @private
     */
    this._isPosting = false;

    /**
     * The original height of the editor. This is set in the render function
     * so that we know how big to reset the height to. We could use a constant
     * here but customers can modify the height of the field, so that would be
     * a bad idea.
     * @type {?number}
     * @private
     */
    this._originalHeight = null;

    /**
     * Whether placeholders are supported or not.
     * @type {boolean}
     * @private
     */
    this._placeholderSupported = true;

    /**
     * The mode of the editor (edit, reply, etc)
     * @type {string}
     * @private
     */
    this._type = this.opts.type;
}
inherits(EditorView, BaseEditorView);

/** @enum {string} */
EditorView.TYPES = BaseEditorView.TYPES;

/** @enum {string} */
EditorView.prototype.classes = {
    EDITOR: 'lf-editor',
    FIELD: 'lf-editor-field',
    FOCUS: 'lf-editor-focus',
    POST_BTN: 'lf-editor-post-btn',
    RESIZE: 'lf-editor-resize'
};

/** @override */
EditorView.prototype.elClass = EditorView.prototype.classes.EDITOR;

/** @override */
EditorView.prototype.events = (function() {
    var classes = EditorView.prototype.classes;
    var events = {};
    events['blur .' + classes.FIELD] = '_handleEditorBlur';
    events['click .' + classes.POST_BTN] = 'handlePostBtnClick';
    events['focus .' + classes.FIELD] = '_handleEditorFocus';
    events['keydown .' + classes.FIELD] = '_handleEditorKeydown';
    events['keyup .' + classes.FIELD] = '_handleEditorKeyup';
    return events;
})();

/** @override */
EditorView.prototype.template = require('hgn!templates/thread/editor');

/**
 * Get the display text for the post button.
 * @private
 * @return {string}
 */
EditorView.prototype._getPostBtnText = function () {
    var KEYS = textEnumeration.KEYS;
    var str;
    if (this._isPosting && this._type === BaseEditorView.TYPES.EDIT) {
        str = textEnumeration.get(KEYS.EDITOR_EDIT_POSTING);
    } else if (this._isPosting) {
        str = textEnumeration.get(KEYS.EDITOR_POSTING);
    } else if (this._type === BaseEditorView.TYPES.REPLY) {
        str = textEnumeration.get(KEYS.EDITOR_REPLY_BTN);
    } else if (this._type === BaseEditorView.TYPES.EDIT) {
        str = textEnumeration.get(KEYS.EDITOR_EDIT_BTN);
    } else {
        str = textEnumeration.get(KEYS.EDITOR_POST_BTN);
    }
    return str;
};

/**
 * Handle the blur event in the textarea.
 * @private
 */
EditorView.prototype._handleEditorBlur = function () {
    if (this._hideOnBlur && !this.$textareaEl.val()) {
        this.$el.hide();
        this.$el.trigger(EditorEvents.HIDE);
        return;
    }
    this.$el.toggleClass(this.classes.FOCUS, false);

    if (this._placeholderSupported || this.$textareaEl.val() !== '') {
        return;
    }
    var KEYS = textEnumeration.KEYS;
    var placeholderText = textEnumeration.get(KEYS.EDITOR_PLACEHOLDER);
    this.$textareaEl.val(placeholderText);
};

/**
 * Handle the focus event in the textarea.
 * @private
 */
EditorView.prototype._handleEditorFocus = function () {
    this.$el.toggleClass(this.classes.FOCUS, true);

    if (this._placeholderSupported) {
        return;
    }

    var KEYS = textEnumeration.KEYS;
    var placeholderText = textEnumeration.get(KEYS.EDITOR_PLACEHOLDER);
    if (this.$textareaEl.val() !== placeholderText) {
        return;
    }
    this.$textareaEl.val('');
};

/**
 * Handle the keydown event in the textarea.
 * @param {jQuery.Event} ev
 * @private
 */
EditorView.prototype._handleEditorKeydown = function (ev) {
    ev.stopPropagation();
    this._resize();
    var isEnter = ev.keyCode === 13;
    if (!isEnter || ev.shiftKey) {
        return;
    }
    ev.preventDefault();
    this.handlePostBtnClick();
};

/**
 * Handle the keyup event in the textarea.
 * @param {jQuery.Event} ev
 * @private
 */
EditorView.prototype._handleEditorKeyup = function (ev) {
    ev.preventDefault();
    ev.stopPropagation();
    var textVal = this.$textareaEl.val();
    this._setDraft(this.opts.editorId, textVal);
    this._resize();
    if (textVal.length === 0) {
        this._hidePostBtn();
        return;
    }
    this._showPostBtn();
};

/**
 * Callback for post completion. This handles both the success and error cases.
 * @param {Object} err
 * @param {Object} data
 * @private
 */
EditorView.prototype._handlePostComplete = function (err, data) {
    this._isPosting = false;
    this._updatePostBtnText();

    if (err) {
        this.showError(err);
        return;
    }

    if (this._type === BaseEditorView.TYPES.EDIT) {
        this.opts.model.set({
            body: this._getContents()
        });
        this.$el.trigger(ThreadEvents.NAVIGATE_TO_THREAD);
    }
    this.reset();
};

/**
 * Hide the post button and set a flag.
 * @private
 */
EditorView.prototype._hidePostBtn = function () {
    this._isPostBtnVisible && this.$postBtnEl.hide();
    this._isPostBtnVisible = false;
};

/**
 * Process the placeholder shenanigans that need to happen because IE 9- doesn't
 * support placeholders on textareas.
 * @private
 */
EditorView.prototype._processPlaceholders = function () {
    var KEYS = textEnumeration.KEYS;
    var placeholderText = textEnumeration.get(KEYS.EDITOR_PLACEHOLDER);
    if (this.$textareaEl[0].placeholder !== undefined) {
        this.$textareaEl.attr('placeholder', placeholderText);
        return;
    }
    this._placeholderSupported = false;
    this.$textareaEl.val(placeholderText);
};

/**
 * Resize the editor.
 * @private
 */
EditorView.prototype._resize = function () {
    var content = this.$textareaEl.val();
    var height = 0;
    this.$resizeEl[0].innerHTML = editorUtil.normalizeNewlines(content);
    $.each(this.$resizeEl.children(), function (i, child) {
        height += $(child).height();
    });
    this.$textareaEl.height(height);
};

/**
 * Show the post button and set a flag.
 * @private
 */
EditorView.prototype._showPostBtn = function () {
    this._isPostBtnVisible || this.$postBtnEl.show();
    this._isPostBtnVisible = true;
};

/**
 * Update the post button's text.
 * @private
 */
EditorView.prototype._updatePostBtnText = function () {
    this.$postBtnEl.html(this._getPostBtnText());
};

/**
 * Focus on the textarea.
 */
EditorView.prototype.focus = function () {
    editorUtil.focusAndPlaceCursorAtEnd(this.$textareaEl);
};

/** @override */
EditorView.prototype.getTemplateContext = function () {
    return {
        strings: {
            postBtn: this._getPostBtnText()
        }
    };
};

/**
 * Initialize the editor view. This keeps track of the original height of the
 * field and focuses on the textarea.
 */
EditorView.prototype.initialize = function () {
    this._originalHeight = this.$textareaEl.height();
    if (this._type !== BaseEditorView.TYPES.EDIT) {
        this._hidePostBtn();
    }
    this.focus();
};

/** @override */
EditorView.prototype.render = function () {
    BaseEditorView.prototype.render.call(this);
    this.$postBtnEl = this.$('.' + this.classes.POST_BTN);
    this.$resizeEl = this.$('.' + this.classes.RESIZE);

    var editModel = this.opts.model;
    if (editModel) {
        this.$textareaEl.val(editorUtil.normalizeParagraphTags(editModel.body));
        return;
    }
    var draft = this._getDraft(this.opts.editorId);
    if (draft) {
        this.$textareaEl.val(draft);
        return;
    }
    this._processPlaceholders();
};

/**
 * Reset the editor back to it's original state.
 */
EditorView.prototype.reset = function () {
    this.$resizeEl.html('');
    this.$textareaEl.val('');
    this._hidePostBtn();
    this.$textareaEl.height(this._originalHeight);
    this._setDraft(this.opts.editorId, null);
};

/**
 * Send the post event.
 * @param {Object} data The post data to send.
 * @override
 */
EditorView.prototype.sendPostEvent = function (data) {
    if (this._isPosting) {
        return;
    }
    this._isPosting = true;
    this._updatePostBtnText();
    this.$el.trigger(this.opts.postEvent, data);
};

/**
 * Show an error message to the user.
 * @param {string} msg The error message to display.
 * @override
 */
EditorView.prototype.showError = function (msg) {
    if (this.$errorEl) {
        return;
    }

    // TODO (mark): Eventually we'll want to have a map for error event types
    // but the SDK only returns error message strings which are useless to us.
    this.$errorEl = $(errorTemplate({msg: BaseEditorView.ERRORS.GENERIC}));
    this.$el.append(this.$errorEl);
    this.$errorEl.fadeTo(500, 0.98);
    this.$textareaEl.blur();

    this.$errorEl.one('click', $.proxy(function (ev) {
        ev.stopPropagation();
        this.$errorEl.remove();
        this.$errorEl = null;
        this.focus();
    }, this));
};

module.exports = EditorView;

});

define("hgn!templates/thread/queuebutton", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<span class=\"lf-btn-text\" />");_.b("\n" + i);_.b("<span class=\"fycon-arrow-down\" />");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/queuebutton',['require','exports','module','inherits','annotations/events','view','hgn!templates/thread/queuebutton'],function (require, exports, module) {/**
 * @fileOverview The queue button class.
 */

var inherits = require('inherits');
var ThreadEvents = require('annotations/events').thread;
var View = require('view');

/**
 * Queue button.
 * @constructor
 * @extends {View}
 * @param {Object} opts
 */
var QueueButton = function(opts) {
    View.call(this, opts);

    /**
     * The number of queued comments.
     * @type {number}
     * @private
     */
    this._count = opts.count || 0;

    /**
     * @type {string}
     * @private
     */
    this._plural = opts.plural;

    /**
     * @type {string}
     * @private
     */
    this._singular = opts.singular;
};
inherits(QueueButton, View);

/** @enum {string} */
QueueButton.CLASSES = {
    DOWN_ARROW: 'fycon-arrow-down',
    MAIN: 'lf-queue-btn',
    REPLY: 'lf-reply-queue-btn',
    TEXT: 'lf-btn-text'
};

/** @override */
QueueButton.prototype.elClass = QueueButton.CLASSES.MAIN;

/** @override */
QueueButton.prototype.events = {
    'click': '_handleClick'
};

/** @override */
QueueButton.prototype.template = require('hgn!templates/thread/queuebutton');

/**
 * Handle the button click event.
 * @private
 */
QueueButton.prototype._handleClick = function() {
    this.$el.trigger(ThreadEvents.SHOW_QUEUED_CONTENT);
};

/**
 * Hide the queue button.
 */
QueueButton.prototype.hide = function() {
    this.$el.hide();
};

/** @override */
QueueButton.prototype.render = function() {
    View.prototype.render.call(this);
    this._btnTextEl = this.$('.' + QueueButton.CLASSES.TEXT);
    this.setCount();
    return this;
};

/**
 * Update the count of the queue. Also, ensures that it can't go negative.
 * @param {number=} opt_count
 */
QueueButton.prototype.setCount = function(opt_count) {
    this._count = opt_count || 0;
    var str = this._count === 1 ? this._singular : this._plural;
    this._btnTextEl.html(str.replace('{number}', this._count));
};

/**
 * Sets this button as a reply button. This adds the reply class.
 */
QueueButton.prototype.setReplyBtn = function() {
    this.$el.addClass(QueueButton.CLASSES.REPLY);
};

/**
 * Show the queue button.
 */
QueueButton.prototype.show = function() {
    this.$el.show();
};

module.exports = QueueButton;

});

define("hgn!templates/thread/expandablethreadcontainer", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-expandable-container\"></div>");_.b("\n" + i);_.b("<div class=\"lf-expandable-footer\">");_.b("\n" + i);_.b("    <a class=\"lf-expand-reply-btn\">");_.b(_.v(_.d("strings.replyBtnText",c,p,0)));_.b("</a>");_.b("\n" + i);_.b("</div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/expandablethreadcontainer',['require','exports','module','jquery','inherits','annotations/thread/ui/basethreadcontainer','annotations/thread/ui/queuebutton','annotations/i18n/enumeration','annotations/events','hgn!templates/thread/expandablethreadcontainer'],function (require, exports, module) {/**
 * @fileOverview Expandable thread container view. This provides functionality
 * to show more and show less comments in a single thread.
 */

var $ = require('jquery');
var inherits = require('inherits');
var BaseThreadContainer = require('annotations/thread/ui/basethreadcontainer');
var QueueButton = require('annotations/thread/ui/queuebutton');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;

/**
 * Expandable thread container view.
 * @constructor
 * @extends {BaseThreadContainer}
 * @param {Object} opts Config options.
 */
var ExpandableThreadContainer = function(opts) {
    BaseThreadContainer.call(this, opts);

    /**
     * State of the thread container. Initially it's expanded since all empty
     * thread containers are technically expanded.
     * @type {boolean}
     * @private
     */
    this._expanded = true;

    /**
     * Index of the oldest collapsed visible comment. This is used to keep track
     * of which comments need to be displayed at any given time.
     * @type {number}
     * @private
     */
    this._oldestCollapsedVisibleIdx = 0;

    var KEYS = textEnumeration.KEYS;

    /**
     * Queue toggle button.
     * @type {QueueButton}
     * @private
     */
    this._toggleBtn = new QueueButton({
        plural: textEnumeration.get(KEYS.THREAD_EXPAND_BTN_PLURAL),
        singular: textEnumeration.get(KEYS.THREAD_EXPAND_BTN_SINGULAR)
    });
};
inherits(ExpandableThreadContainer, BaseThreadContainer);

/**
 * The number of comments that show when collapsed.
 * @const {number}
 */
ExpandableThreadContainer.NUM_COLLAPSED_COMMENTS = 2;

/** @enum {string} */
ExpandableThreadContainer.CLASSES = {
    CONTAINER: 'lf-expandable-container',
    MAIN: 'lf-expandable-thread-container',
    REPLY_BTN: 'lf-expand-reply-btn',
    TOGGLE_BTN: 'lf-expand-toggle-btn',
    TOGGLE_BTN_TEXT: 'lf-expand-toggle-text'
};

/** @enum {string} */
ExpandableThreadContainer.EVENTS = {
    HIDE_REPLY_BTN: 'hideReplyBtn'
};

/** @override */
ExpandableThreadContainer.prototype.elClass = ExpandableThreadContainer.CLASSES.MAIN;

/** @override */
ExpandableThreadContainer.prototype.events = (function() {
    var CLASSES = ExpandableThreadContainer.CLASSES;
    var events = {};
    events['click .' + CLASSES.REPLY_BTN] = '_handleReplyClick';
    events[ThreadEvents.SHOW_QUEUED_CONTENT] = '_handleToggleClick';
    return events;
})();

/** @override */
ExpandableThreadContainer.prototype.template =
    require('hgn!templates/thread/expandablethreadcontainer');

/**
 * Handle the reply button click. Should hide the reply button.
 * @private
 */
ExpandableThreadContainer.prototype._handleReplyClick = function() {
    this._$replyBtnEl.hide();
};

/**
 * Handle the toggle expand/collapse button cilck.
 * @private
 */
ExpandableThreadContainer.prototype._handleToggleClick = function() {
    if (this._expanded) {
        return;
    }
    this._expanded = true;
    this.expand();
    this._updateButtonText();
};

/**
 * Update the comment count in the expand button.
 * @private
 */
ExpandableThreadContainer.prototype._updateButtonText = function() {
    if (this._expanded) {
        return;
    }
    this._toggleBtn.setCount(this.getNumQueued());
};

/** @override */
ExpandableThreadContainer.prototype.addComment = function(comments, opt_prepend, opt_el) {
    BaseThreadContainer.prototype.addComment.apply(this, arguments);
    this.updateButtonVisibility();
};

/**
 * Expand the thread of comments.
 */
ExpandableThreadContainer.prototype.expand = function() {
    var el = document.createDocumentFragment();
    var ids = this._commentIds.slice(0, this._oldestCollapsedVisibleIdx);
    var self = this;
    var view;

    $.each(ids, function(i, id) {
        view = self._comments[id];
        view.render();
        el.appendChild(view.el);
    });

    this.getContainerElement().prepend(el.childNodes);
    this._toggleBtn.hide();
};

/** @override */
ExpandableThreadContainer.prototype.getContainerElement = function() {
    return this._$containerEl;
};

/**
 * Get the total number of queued comments.
 * @return {number} The number of queued comments.
 */
ExpandableThreadContainer.prototype.getNumQueued = function() {
    return this._commentIds.length - ExpandableThreadContainer.NUM_COLLAPSED_COMMENTS;
};

/**
 * Get the reply button element.
 * @return {Element}
 */
ExpandableThreadContainer.prototype.getReplyButton = function() {
    return this._$replyBtnEl;
};

/** @override */
ExpandableThreadContainer.prototype.getTemplateContext = function() {
    var KEYS = textEnumeration.KEYS;
    return {
        strings: {
            replyBtnText: textEnumeration.get(KEYS.THREAD_REPLY_BTN),
            toggleBtnText: textEnumeration.get(KEYS.THREAD_EXPAND_BTN_SINGULAR)
        }
    };
};

/** @override */
ExpandableThreadContainer.prototype.initialize = function(comments) {
    comments.sort(function(c1, c2) {
        var created1 = c1.createdAt;
        var created2 = c2.createdAt;
        return created1 < created2 ? -1 : created1 > created2 ? 1 : 0;
    });

    var containerEl = this.getContainerElement();
    var len = comments.length;
    var view;
    var visCount = 0;

    $.each(comments.reverse(), $.proxy(function(i, comment) {
        if (!!this._comments[comment.id]) {
            return;
        }
        view = new this._commentConstructor(this._getCommentOptions(comment));
        this._comments[comment.id] = view;

        // Prepending the id since the list was reversed to make it easier to
        // process in this function.
        this._commentIds.splice(0, 0, comment.id);

        if (visCount === ExpandableThreadContainer.NUM_COLLAPSED_COMMENTS) {
            return;
        }

        if (visCount === 1) {
            this._oldestCollapsedVisibleIdx = len - i - 1;
        }

        view.render();
        containerEl.prepend(view.$el);
        view.shouldRender() && visCount++;
    }, this));

    // Update the expanded variable based on the number of comments loaded
    // initially to determine whether the replies will be collapsed or not.
    var num = this._commentIds.length;
    this._expanded = num <= ExpandableThreadContainer.NUM_COLLAPSED_COMMENTS;

    this._updateButtonText();
    this.updateButtonVisibility();
};

/** @override */
ExpandableThreadContainer.prototype.render = function() {
    BaseThreadContainer.prototype.render.call(this);

    this._toggleBtn.render();
    this.$el.prepend(this._toggleBtn.$el);

    var CLASSES = ExpandableThreadContainer.CLASSES;
    this._$containerEl = this.$('.' + CLASSES.CONTAINER);
    // HACK: Needs to be inline-block and this._$replyBtnEl.show() sets it
    // to inline.
    this._$replyBtnEl = this.$('.' + CLASSES.REPLY_BTN).css('display', 'inline-block');
    this.updateButtonVisibility();
};

/**
 * Toggle the visibility of the buttons.
 */
ExpandableThreadContainer.prototype.updateButtonVisibility = function() {
    var len = this._commentIds.length;
    if (!len) {
        this._toggleBtn.hide();
        this._$replyBtnEl.hide();
        return;
    }
    this.$el.trigger(ExpandableThreadContainer.EVENTS.HIDE_REPLY_BTN);
    if (len <= ExpandableThreadContainer.NUM_COLLAPSED_COMMENTS) {
        this._toggleBtn.hide();
        this._$replyBtnEl.show();
        return;
    }
    this._toggleBtn.show();
    this._$replyBtnEl.show();
};

module.exports = ExpandableThreadContainer;

});

define('annotations/thread/ui/queued-expandable-thread-container',['require','exports','module','jquery','annotations/models/comment','annotations/thread/ui/expandablethreadcontainer','inherits','annotations/thread/ui/queuebutton','annotations/i18n/enumeration','annotations/events'],function (require, exports, module) {/**
 * @fileOverview ExpandableThreadContainer-ish object that supports queueing.
 */

var $ = require('jquery');
var Comment = require('annotations/models/comment');
var ExpandableThreadContainer = require('annotations/thread/ui/expandablethreadcontainer');
var inherits = require('inherits');
var QueueButton = require('annotations/thread/ui/queuebutton');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;

/**
 * Queued Expandable Thread Container.
 * @constructor
 * @extends {ExpandableThreadContainer}
 * @param {Object} opts Config options.
 */
var QueuedExpandableThreadContainer = function(opts) {
    ExpandableThreadContainer.call(this, opts);
    var KEYS = textEnumeration.KEYS;

    /**
     * Queue button that shows in the footer of a top level comment. This shows
     * up only when there are no replies.
     * @type {QueueButton}
     * @private
     */
    this._commentQueueBtn = opts.commentQueueBtn;
    this._commentQueueBtn.setReplyBtn();

    /**
     * Footer queue button. This shows up when all replies are expanded and new
     * content streams in.
     * @type {QueueButton}
     * @private
     */
    this._footerQueueBtn = new QueueButton({
        plural: textEnumeration.get(KEYS.QUEUED_REPLIES_PLURAL),
        singular: textEnumeration.get(KEYS.QUEUED_REPLIES_SINGULAR)
    });
    this._footerQueueBtn.setReplyBtn();

    /**
     * Array for the non-expand queue buttons. This includes the one underneath
     * the thread container (next to the reply button) and the one in the
     * comment footer.
     * @type {Array.<QueueButton>}
     * @private
     */
    this._queueBtns = [opts.commentQueueBtn];

    /**
     * List of queued comments. These are all comments that were streamed in
     * and can't be displayed yet.
     * @type {Array.<Comment>}
     * @private
     */
    this._queuedComments = [];
};
inherits(QueuedExpandableThreadContainer, ExpandableThreadContainer);

/** @enum {string} */
QueuedExpandableThreadContainer.CLASSES = {
    FOOTER: 'lf-expandable-footer',
    NEW: 'lf-toggle-btn-new'
};
$.extend(QueuedExpandableThreadContainer.CLASSES, ExpandableThreadContainer.CLASSES);

/** @enum {string} */
QueuedExpandableThreadContainer.EVENTS = ExpandableThreadContainer.EVENTS;

/**
 * Add a queue notifier icon to each queue button. This needs to be inserted
 * after the first child element for the expand toggle button since it has the
 * extra DOM node for the down arrow fycon.
 * @param {QueueButton} btn
 */
function addQueueNotifier(btn) {
    var CLASSES = QueuedExpandableThreadContainer.CLASSES;
    if (btn.$el.has('.' + CLASSES.NEW).length) {
        return;
    }
    var elem = document.createElement('span');
    elem.className = CLASSES.NEW;
    btn.$el.find(':first-child').after(elem);
}

/**
 * Queue a comment. Show the queue button.
 * @param {Comment} comment The comment to queue.
 * @private
 */
QueuedExpandableThreadContainer.prototype._queueComment = function(comment) {
    this._queuedComments.push(comment);
    var self = this;

    var callback = function(i, btn, opt_count) {
        btn.setCount(opt_count || self._queuedComments.length);
        addQueueNotifier(btn);
    };

    callback(null, this._toggleBtn, this.getNumQueued());
    $.each(this._queueBtns, callback);
    this.updateButtonVisibility();
};

/**
 * Show all queued comments. Hide the queue button. Doesn't have to be a handler
 * of an event, but if it is, it should stop the event in it's tracks.
 * @param {jquery.Event=} opt_ev
 * @private
 */
QueuedExpandableThreadContainer.prototype._showQueuedComments = function(opt_ev) {
    opt_ev && opt_ev.stopPropagation();
    var elem = this.getContainerElement();

    $.each(this._queuedComments, $.proxy(function(i, comment) {
        this.processComment(false, elem, null, comment, true);
    }, this));

    this._queuedComments = [];
    this.updateButtonVisibility();
};

/** @override */
QueuedExpandableThreadContainer.prototype.destroy = function() {
    ExpandableThreadContainer.prototype.destroy.call(this);
    var callback = $.proxy(this._showQueuedComments, this);
    this.$el.off(ThreadEvents.SHOW_QUEUED_CONTENT, callback);
};

/** @override */
QueuedExpandableThreadContainer.prototype.expand = function() {
    ExpandableThreadContainer.prototype.expand.call(this);
    this._showQueuedComments();
};

/** @override */
QueuedExpandableThreadContainer.prototype.getNumQueued = function() {
    var count = ExpandableThreadContainer.prototype.getNumQueued.call(this);
    return count + this._queuedComments.length;
};

/** @override */
QueuedExpandableThreadContainer.prototype.processComment =
        function(prepend, el, i, comment, opt_force) {
    // If the current author posted, don't queue their comment.
    opt_force = comment.isUserAuthor() || opt_force;
    // Streamed comments should be added to the queue.
    if (!opt_force && comment.origin === Comment.ORIGIN.STREAM) {
        this._queueComment(comment);
        return;
    }
    ExpandableThreadContainer.prototype.processComment.call(this, prepend, el, i, comment);
};

/** @override */
QueuedExpandableThreadContainer.prototype.render = function() {
    ExpandableThreadContainer.prototype.render.call(this);

    this._footerQueueBtn.render().hide();
    this._queueBtns.push(this._footerQueueBtn);
    this.$('.' + QueuedExpandableThreadContainer.CLASSES.FOOTER).append(this._footerQueueBtn.$el);

    var callback = $.proxy(this._showQueuedComments, this);
    this.$el.on(ThreadEvents.SHOW_QUEUED_CONTENT, callback);
};

/** @override */
QueuedExpandableThreadContainer.prototype.updateButtonVisibility = function() {
    var expandLen = this._commentIds.length;
    var hasQueued = this._queuedComments.length > 0;

    this._toggleBtn.hide();
    this._$replyBtnEl.hide();
    this._footerQueueBtn.hide();
    this._commentQueueBtn.hide();

    // There are no comments, so none of the thread container buttons should
    // show. If there are queued comments, however, the comment queue button
    // should show.
    if (!expandLen) {
        hasQueued && this._commentQueueBtn.show();
        return;
    }

    // There are comments, so none of the comment view buttons should show.
    this.$el.trigger(ExpandableThreadContainer.EVENTS.HIDE_REPLY_BTN);

    // There are comments, but not enough to show the expand button. We still
    // want to show the thread container reply button and possibly the queue
    // button in the footer if there are queued comments.
    if (expandLen <= ExpandableThreadContainer.NUM_COLLAPSED_COMMENTS) {
        this._$replyBtnEl.show();
        hasQueued && this._footerQueueBtn.show();
        return;
    }

    // There are some comments, but if we've already expanded the replies, the
    // toggle button shouldn't be shown again.
    !this._expanded && this._toggleBtn.show();
    this._$replyBtnEl.show();

    // If the replies have been expanded and there are queued comments, the
    // footer queue button should show.
    if (this._expanded && hasQueued) {
        this._footerQueueBtn.show();
    }
};

module.exports = QueuedExpandableThreadContainer;

});

define('annotations/thread/ui/comment/replyview',['require','exports','module','jquery','annotations/thread/ui/comment/baseview','hgn!templates/thread/comment/etc','inherits','hgn!templates/thread/comment/comment'],function (require, exports, module) {/**
 * @fileOverview The comment reply view class.
 */

var $ = require('jquery');
var BaseCommentView = require('annotations/thread/ui/comment/baseview');
var etcTemplate = require('hgn!templates/thread/comment/etc');
var inherits = require('inherits');

/**
 * Reply view.
 * @constructor
 * @extends {BaseCommentView}
 * @param {Object} opts Config options.
 */
var ReplyView = function(opts) {
    BaseCommentView.call(this, opts);
};
inherits(ReplyView, BaseCommentView);

/** @override */
ReplyView.prototype.elClass = [
    BaseCommentView.CLASSES.COMMENT,
    BaseCommentView.CLASSES.REPLY
].join(' ');

/** @override */
ReplyView.prototype.template = require('hgn!templates/thread/comment/comment');

/** @override */
ReplyView.prototype.render = function() {
    BaseCommentView.prototype.render.call(this);
    var $body = this.$('.' + BaseCommentView.CLASSES.BODY);
    var lastChild = $body.children().last();
    lastChild.append($(etcTemplate()));
};

module.exports = ReplyView;

});

define("hgn!templates/thread/comment/topcomment", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-comment-container\">");_.b("\n" + i);_.b(_.rp("base",c,p,"    "));_.b(_.rp("footer",c,p,"    "));_.b("</div>");_.b("\n" + i);_.b("<div class=\"lf-reply-container\"></div>");_.b("\n" + i);_.b("<div class=\"lf-editor-container\"></div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/comment/topview',['require','exports','module','jquery','auth','annotations/thread/ui/comment/baseview','annotations/thread/ui/comment/actions','annotations/events','annotations/events','annotations/thread/ui/editorview','annotations/thread/ui/queued-expandable-thread-container','inherits','annotations/util/internals','annotations/thread/ui/queuebutton','annotations/thread/ui/comment/replyview','annotations/i18n/enumeration','annotations/events','annotations/enums','annotations/events','hgn!templates/thread/comment/topcomment'],function (require, exports, module) {/**
 * @fileOverview Top level comment view. These are the main annotation comments
 * that have footers and aren't indented.
 */

var $ = require('jquery');
var auth = require('auth');
var BaseCommentView = require('annotations/thread/ui/comment/baseview');
var CommentActions = require('annotations/thread/ui/comment/actions');
var CommentEvents = require('annotations/events').comment;
var EditorEvents = require('annotations/events').editor;
var EditorView = require('annotations/thread/ui/editorview');
var QueuedExpandableThreadContainer =
        require('annotations/thread/ui/queued-expandable-thread-container');
var inherits = require('inherits');
var internals = require('annotations/util/internals');
var QueueButton = require('annotations/thread/ui/queuebutton');
var ReplyCommentView =require('annotations/thread/ui/comment/replyview');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;
var viewEnum = require('annotations/enums').navigableViews;
var WriteEvents = require('annotations/events').write;

/**
 * Top level comment view.
 * @constructor
 * @extends {BaseCommentView}
 * @param {Object} opts Config options.
 */
var TopCommentView = function(opts) {
    BaseCommentView.call(this, opts);

    /**
     * Whether the mouse enter and leave events are disabled for this view.
     * @type {boolean}
     * @private
     */
    this._mouseEventsDisabled = false;

    /**
     * Reply container view.
     * @type {?QueuedExpandableThreadContainer}
     * @private
     */
    this._replyContainer = null;

    /**
     * Reply editor.
     * @type {?EditorView}
     * @private
     */
    this._replyEditor = null;
};
inherits(TopCommentView, BaseCommentView);

/** @enum {string} */
TopCommentView.CLASSES = {
    EDITOR_CONTAINER: 'lf-editor-container',
    REPLY_CONTAINER: 'lf-reply-container'
};
$.extend(TopCommentView.CLASSES, BaseCommentView.CLASSES);

/** @override */
TopCommentView.prototype.events = (function() {
    var events = {};
    var THREAD_EVENTS = QueuedExpandableThreadContainer.EVENTS;
    events['click .' + CommentActions.CLASSES.REPLY_BTN] = '_toggleReplyEditor';
    events['click .' + QueuedExpandableThreadContainer.CLASSES.REPLY_BTN] = '_toggleReplyEditor';
    events[WriteEvents.POST_REPLY] = '_interceptReply';
    events[THREAD_EVENTS.HIDE_REPLY_BTN] = '_handleHideReplyBtn';
    events[ThreadEvents.SHOW_QUEUED_CONTENT] = '_handleShowQueuedContent';
    events['mouseenter'] = 'handleMouseEnter';
    events['mouseleave'] = 'handleMouseLeave';
    return events;
})();
$.extend(TopCommentView.prototype.events, BaseCommentView.prototype.events);

/** @override */
TopCommentView.prototype.template = require('hgn!templates/thread/comment/topcomment');

/**
 * Hide the reply button.
 * @private
 */
TopCommentView.prototype._handleHideReplyBtn = function() {
    this._actions.hideReplyBtn();
};

/**
 * Handle the show queued content event.
 * @param {jQuery.Event} ev
 * @private
 */
TopCommentView.prototype._handleShowQueuedContent = function(ev) {
    ev.stopPropagation();
    this._replyContainer.$el.trigger(ThreadEvents.SHOW_QUEUED_CONTENT);
};

/**
 * Intercept the reply event and add a success callback to it.
 * @param {jQuery.Event} ev
 * @param {Object} opts
 * @private
 */
TopCommentView.prototype._interceptReply = function(ev, opts) {
    var self = this;
    var callbackFn = opts.callback || function() {};
    opts.callback = function(err, comment) {
        callbackFn(err, comment);
        if (err) {
            return;
        }
        self.$_editorContainerEl.hide();
        self.getThreadContainer().addComment(comment);
    };
    opts.parentId = this._model.id;
};

/**
 * Toggle the display of the reply editor.
 * @param {Event} ev
 * @private
 */
TopCommentView.prototype._toggleReplyEditor = function(ev) {
    var self = this;
    function showReplyBtn() {
        self.getThreadContainer().getReplyButton().show();
    }

    if (!auth.get('livefyre')) {
        showReplyBtn();
        this.$el.trigger(ThreadEvents.NAVIGATE, {
            event: WriteEvents.POST_REPLY,
            value: viewEnum.AUTH
        });
        return;
    }

    if (this._replyEditor && this.$_editorContainerEl.is(':visible')) {
        this.$_editorContainerEl.hide();
        return;
    }

    if (!this._replyEditor) {
        this._replyEditor = new EditorView({
            editorId: this._model.id,
            el: this.$_editorContainerEl,
            hideOnBlur: true,
            postEvent: WriteEvents.POST_REPLY,
            type: EditorView.TYPES.REPLY
        });
        this._replyEditor.render();
    } else {
        this._replyEditor.reset();
    }

    this.$_editorContainerEl.show();
    this._replyEditor.initialize();

    if (!$(ev.target).hasClass(QueuedExpandableThreadContainer.CLASSES.REPLY_BTN)) {
        return;
    }

    this._replyEditor.$el.one(EditorEvents.HIDE, showReplyBtn);
};

/** @override */
TopCommentView.prototype.destroy = function() {
    BaseCommentView.prototype.destroy.call(this);
    this._replyEditor && this._replyEditor.destroy();
    this._replyEditor = null;
};

/**
 * Disable mouse events.
 * @param {boolean} disable To disable or not to disable ...
 */
TopCommentView.prototype.disableMouseEvents = function (disable) {
    this._mouseEventsDisabled = disable;
};

/**
 * Returns the reply thread container.
 * @return {?ThreadContainer}
 */
TopCommentView.prototype.getThreadContainer = function() {
    return this._replyContainer;
};

/**
 * Handle a hover (possibly highlight selected text).
 * @param {jQuery.Event} ev
 */
TopCommentView.prototype.handleMouseEnter = function (ev) {
    if (this._mouseEventsDisabled) {
        return;
    }
    var selectedText = this._model.selectedText;
    if (!selectedText) {
        return;
    }
    var self = this;
    // Using a setTimeout here to make this fire after the thread container's
    // mouseenter, which hides the user's selected text. If this doesn't have
    // a setTimeout, it's possible that this fires first and gets deactivated
    // by the thread container's event.
    setTimeout(function () {
        self.$el.trigger(ThreadEvents.ACTIVATE_HIGHLIGHTED_TEXT, {
            selectedText: selectedText,
            blockId: self._model.blockId
        });
    }, 1);
};

/**
 * Handle a hover (possibly unhighlight selected text).
 * @param {jQuery.Event} ev
 */
TopCommentView.prototype.handleMouseLeave = function (ev) {
    if (!this._model.selectedText || this._mouseEventsDisabled) {
        return;
    }
    this.$el.trigger(ThreadEvents.DEACTIVATE_HIGHLIGHTED_TEXT);
};

/**
 * Hide the comment view. Doing this instead of destroying so that it's possible
 * to change the visibility and have the view show itself.
 */
TopCommentView.prototype.hide = function () {
    BaseCommentView.prototype.hide.call(this);
    this.$el.trigger(CommentEvents.HIDDEN, this._model);
};

/** @override */
TopCommentView.prototype.render = function() {
    var CLASSES = TopCommentView.CLASSES;
    var KEYS = textEnumeration.KEYS;
    BaseCommentView.prototype.render.call(this);

    this.$_editorContainerEl = this.$('.' + CLASSES.EDITOR_CONTAINER);

    var btn = new QueueButton({
        plural: textEnumeration.get(KEYS.QUEUED_REPLIES_PLURAL),
        singular: textEnumeration.get(KEYS.QUEUED_REPLIES_SINGULAR)
    });
    btn.render().hide();
    this.$footerEl.append(btn.$el);

    this._replyContainer = new QueuedExpandableThreadContainer({
        assetServer: this.opts.assetServer,
        commentConstructor: ReplyCommentView,
        commentQueueBtn: btn,
        defaultAvatar: this.opts.defaultAvatar,
        el: this.$('.'+ CLASSES.REPLY_CONTAINER)
    });
    this._replyContainer.render();
};

/** @override */
TopCommentView.prototype.renderEtc = internals.nullFunction;

module.exports = TopCommentView;

});

define('annotations/thread/ui/threadcontainer',['require','exports','module','jquery','annotations/thread/ui/basethreadcontainer','streamhub-sdk/debug','inherits','annotations/util/sorting','hgn!templates/thread/threadcontainer','annotations/events','annotations/thread/ui/comment/topview'],function (require, exports, module) {/**
 * @fileOverview The stream view class. This is what all of the comments on the
 * page live within.
 */

var $ = require('jquery');
var BaseThreadContainer = require('annotations/thread/ui/basethreadcontainer');
var debug = require('streamhub-sdk/debug');
var inherits = require('inherits');
var SortingUtil = require('annotations/util/sorting');
var template = require('hgn!templates/thread/threadcontainer');
var ThreadEvents = require('annotations/events').thread;
var TopCommentView = require('annotations/thread/ui/comment/topview');

var log = debug('annotations/thread/ui/threadcontainer');

/**
 * Stream view.
 * @constructor
 * @extends {BaseThreadContainer}
 * @param {Object} opts Config options.
 */
var ThreadContainer = function(opts) {
    opts = opts || {};
    opts.commentConstructor = TopCommentView;
    BaseThreadContainer.call(this, opts);
};
inherits(ThreadContainer, BaseThreadContainer);

/** @enum {string} */
ThreadContainer.CLASSES = {
    BASE: 'lf-thread-container',
    GRADIENT: 'lf-thread-gradient'
};

/** @override */
ThreadContainer.prototype.elClass = ThreadContainer.CLASSES.BASE;

/** @override */
ThreadContainer.prototype.elTag = 'section';

/** @override */
ThreadContainer.prototype.events = {
    'mouseenter': '_handleMouseEnter',
    'mouseleave': '_handleMouseLeave'
};

/**
 * Get the thread container component that lives within a comment.
 * @param {string} commentId The ID of the comment to get the container for.
 * @return {?ThreadContainer}
 * @private
 */
ThreadContainer.prototype._getParentThreadContainer = function(commentId) {
    var comment = this._comments[commentId];
    if (!comment) {
        return null;
    }
    return comment.getThreadContainer();
};

/**
 * Handle a hover (possibly unhighlight selected text).
 * @private
 */
ThreadContainer.prototype._handleMouseEnter = function () {
    this.$el.trigger(ThreadEvents.DEACTIVATE_HIGHLIGHTED_TEXT);
};

/**
 * Handle a hover (possibly highlight selected text).
 * @private
 */
ThreadContainer.prototype._handleMouseLeave = function () {
    this.$el.trigger(ThreadEvents.ACTIVATE_HIGHLIGHTED_TEXT);
};

/** @type {function()} */
ThreadContainer.prototype.comparator = SortingUtil.helpfulnessComparator;

/**
 * Initialize the thread container with a set of comments. These should all be
 * rendered prior to adding to the DOM so there is only 1 DOM write.
 * @param {Array.<Comment>} comments The set of comments to load.
 */
ThreadContainer.prototype.initialize = function(comments) {
    var el = $(template());
    var commentMap = {};
    var parent, parentId;

    $.each(comments, function(i, comment) {
        parentId = comment.parentId || 'root';
        if (!commentMap[parentId]) {
            commentMap[parentId] = [];
        }
        commentMap[parentId].push(comment);
    });

    BaseThreadContainer.prototype.initialize.call(this, commentMap['root'], el);

    delete commentMap['root'];

    for (parentId in commentMap) {  // jshint ignore:line
        if (commentMap.hasOwnProperty(parentId)) {
            parent = this._getParentThreadContainer(parentId);
            parent && parent.initialize(commentMap[parentId]);
        }
    }
};

/** @override */
ThreadContainer.prototype.processComment = function(prepend, el, i, comment) {
    if (!comment.parentId) {
        BaseThreadContainer.prototype.processComment.call(this, prepend, el, i, comment);
        return;
    }

    var threadContainer = this._getParentThreadContainer(comment.parentId);
    if (!threadContainer) {
        log('no parent');
        return;
    }
    threadContainer.addComment(comment, false);
};

module.exports = ThreadContainer;

});

define("hgn!templates/mobile/repliesthreadcontainer", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<header class=\"lf-menu-head\"></header>");_.b("\n" + i);_.b("<div class=\"lf-thread-wrapper\">");_.b("\n" + i);_.b("    <div class=\"lf-thread\"></div>");_.b("\n" + i);_.b("    <button type=\"button\" class=\"lf-reply-btn lf-btn-lg lf-btn-default\"><span class=\"fycon-action-reply\"></span>");_.b(_.v(_.d("strings.reply",c,p,0)));_.b("</button>");_.b("\n" + i);_.b("</div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/mobile/thread/ui/stream/repliesthreadcontainer',['require','exports','module','inherits','annotations/mobile/thread/ui/comment/view','annotations/mobile/thread/ui/navbar','annotations/util/auth','annotations/util/sorting','annotations/i18n/enumeration','annotations/thread/ui/threadcontainer','annotations/events','annotations/enums','annotations/events','hgn!templates/mobile/repliesthreadcontainer'],function (require, exports, module) {/**
 * @fileOverview Displays a top comment and all its replies on mobile.
 */

var inherits = require('inherits');
var MobileCommentView = require('annotations/mobile/thread/ui/comment/view');
var Navbar = require('annotations/mobile/thread/ui/navbar');
var requireAuth = require('annotations/util/auth').requireAuth;
var SortingUtil = require('annotations/util/sorting');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadContainer = require('annotations/thread/ui/threadcontainer');
var ThreadEvents = require('annotations/events').thread;
var viewEnum = require('annotations/enums').navigableViews;
var WriteEvents = require('annotations/events').write;

/**
 * Stream view.
 * @constructor
 * @extends {ThreadContainer}
 * @param {Object} opts Config options.
 */
var RepliesThreadContainer = function (opts) {
    opts = opts || {};
    ThreadContainer.call(this, opts);

    this._commentConstructor = MobileCommentView;

    this._topComment = opts.topComment;
    this._replies = opts.replies;

    var KEYS = textEnumeration.KEYS;
    this._nav = new Navbar({
        backEvent: opts.permalinkView && ThreadEvents.PERMALINK_BACK,
        backStr: opts.permalinkView && textEnumeration.get(KEYS.PERMALINK_BACK_BTN),
        title: textEnumeration.get(KEYS.MENU_REPLIES_VIEW_TITLE)
    });
};
inherits(RepliesThreadContainer, ThreadContainer);

/** @enum {string} */
RepliesThreadContainer.CLASSES = {
    COMMENT_REPLIES: 'lf-comment-replies',
    THREAD: 'lf-thread',
    REPLY_BUTTON: 'lf-reply-btn'
};

/**
 * Handle a reply click
 */
RepliesThreadContainer.prototype._handleReplyClick = requireAuth(function () {
    this.$el.trigger(ThreadEvents.NAVIGATE, {
        value: viewEnum.EDITOR,
        parentId: this._topComment.id,
        editorId: this._topComment.id
    });
}, WriteEvents.POST_REPLY);

/** @override */
RepliesThreadContainer.prototype.comparator = SortingUtil.createdAtComparator;

/** @override */
RepliesThreadContainer.prototype.elClass = RepliesThreadContainer.CLASSES.COMMENT_REPLIES;

/** @override */
RepliesThreadContainer.prototype.elTag = 'section';

/** @override */
RepliesThreadContainer.prototype.events = (function () {
    var events = {};
    events['tap .' + RepliesThreadContainer.CLASSES.REPLY_BUTTON] = '_handleReplyClick';
    return events;
})();

/** @override */
RepliesThreadContainer.prototype.getContainerElement = function () {
    return this.$('.' + RepliesThreadContainer.CLASSES.THREAD);
};

/** @override */
RepliesThreadContainer.prototype.getTemplateContext = function () {
    var KEYS = textEnumeration.KEYS;
    return {
        strings: {
            backBtn: textEnumeration.get(KEYS.MENU_BACK_BTN),
            reply: textEnumeration.get(KEYS.MENU_REPLIES_VIEW_REPLY)
        }
    };
};

/** @override */
RepliesThreadContainer.prototype.initialize = function (comments) {
    if (!comments) {
        comments = [];
        comments.push(this._topComment);
        comments.push.apply(comments, this._replies);
    }
    if (!this._topComment) {
        for (var i=0, len=comments.length; i<len; i++) {
            if (!(this._topComment = comments[i]).parentId) {
                break;
            }
        }
    }
    ThreadContainer.prototype.initialize.call(this, comments);
};

/** @override */
RepliesThreadContainer.prototype.render = function() {
    ThreadContainer.prototype.render.call(this);
    this._nav.setElement(this.$('.' + Navbar.CLASSES.HEADER));
    this._nav.render();
};

/** @override */
RepliesThreadContainer.prototype.template = require('hgn!templates/mobile/repliesthreadcontainer');

module.exports = RepliesThreadContainer;

});

define("hgn!templates/thread/menu/link", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<li data-value=\"");_.b(_.v(_.f("key",c,p,0)));_.b("\" class=\"lf-");_.b(_.v(_.f("key",c,p,0)));_.b(" ");_.b(_.v(_.f("cls",c,p,0)));_.b("\">");_.b(_.v(_.f("str",c,p,0)));_.b("</li>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/menu/base',['require','exports','module','jquery','inherits','hgn!templates/thread/menu/link','annotations/thread/ui/navigable','annotations/util/useragent'],function (require, exports, module) {/**
 * @fileOverview Base menu. This provides menu-specific abilities.
 */

var $ = require('jquery');
var inherits = require('inherits');
var linkTemplate = require('hgn!templates/thread/menu/link');
var Navigable = require('annotations/thread/ui/navigable');
var UserAgentUtil = require('annotations/util/useragent');

/**
 * Base menu.
 * @constructor
 * @extends {Navigable}
 * @param {Object} opts Config options.
 */
var BaseMenu = function(opts) {
    Navigable.call(this, opts);

    /**
     * Comment model.
     * @type {Comment}
     * @private
     */
    this._model = opts.model;

    /**
     * The post event type for this class.
     * @type {string}
     * @private
     */
    this.postEvent = null;
};
inherits(BaseMenu, Navigable);

/** @enum {string} */
BaseMenu.CLASSES = Navigable.CLASSES;

/** @override */
BaseMenu.prototype.events = (function() {
    var events = {};
    var event = UserAgentUtil.isMobile() ? 'tap' : 'click';
    events[event + ' .' + BaseMenu.CLASSES.BODY + ' > li'] = 'handleOptionClick';
    return events;
})();
$.extend(BaseMenu.prototype.events, Navigable.prototype.events);

/**
 * Iterate over the list of link configs and build a document fragment from them.
 * @return {?DocumentFragment}
 * @private
 */
BaseMenu.prototype._buildMenuLinks = function() {
    var linkConfig = this.getLinkConfig();
    if (!linkConfig.length) {
        return null;
    }
    var frag = document.createDocumentFragment();
    $.each(linkConfig, function(i, cfg) {
        frag.appendChild($(linkTemplate(cfg))[0]);
    });
    return frag;
};

/**
 * Build the event data object.
 * @param {jQuery.Event} ev
 * @return {Object}
 */
BaseMenu.prototype.buildEventData = function(ev) {
    return {
        messageId: this._model.id,
        model: this._model,
        value: $(ev.currentTarget).attr('data-value')
    };
};

/**
 * Config for the user-clickable links.
 * @type {function(): Array.<Object>}
 */
BaseMenu.prototype.getLinkConfig = function() {
    return [];
};

/**
 * Handle the option click event. This should trigger a write event that will
 * flag the comment.
 * @param {jQuery.Event} ev
 */
BaseMenu.prototype.handleOptionClick = function(ev) {
    ev.stopPropagation();
    this.$el.trigger(this.postEvent, this.buildEventData(ev));
};

/**
 * Load menu links onto the page.
 */
BaseMenu.prototype.loadMenuLinks = function() {
    var frag = this._buildMenuLinks();
    frag && this.$('.' + BaseMenu.CLASSES.BODY).prepend(frag);
};

/** @override */
BaseMenu.prototype.render = function() {
    Navigable.prototype.render.call(this);
    this.loadMenuLinks();
};

module.exports = BaseMenu;

});

define("hgn!templates/thread/menu/auth", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"fycon-icon-sidenotes\" />");_.b("\n" + i);_.b("<span class=\"lf-signed-in\">");_.b(_.t(_.d("strings.signedInMsg",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("<button class=\"lf-signin-btn lf-btn lf-btn-default\">");_.b(_.t(_.d("strings.signInBtn",c,p,0)));_.b("</span>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/menu/auth',['require','exports','module','jquery','annotations/thread/ui/menu/base','inherits','annotations/thread/ui/navigable','annotations/i18n/enumeration','annotations/events','annotations/util/useragent','annotations/events','annotations/events','hgn!templates/thread/menu/auth'],function (require, exports, module) {/**
 * @fileOverview Auth menu view. This shows when a user tries to do something
 * that requires authentication.
 */

var $ = require('jquery');
var BaseMenu = require('annotations/thread/ui/menu/base');
var inherits = require('inherits');
var Navigable = require('annotations/thread/ui/navigable');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;
var UserAgentUtil = require('annotations/util/useragent');
var UserEvents = require('annotations/events').user;
var WriteEvents = require('annotations/events').write;

/**
 * Auth menu.
 * @constructor
 * @extends {BaseMenu}
 * @param {Object} opts Config options.
 */
var AuthMenu = function(opts) {
    BaseMenu.call(this, opts);
};
inherits(AuthMenu, BaseMenu);

/** @enum {string} */
AuthMenu.CLASSES = {
    AUTH: 'lf-auth',
    SIGNED_IN: 'lf-signed-in',
    SIGNIN_BTN: 'lf-signin-btn'
};

/** @enum {string} */
var EVENT_TO_ACTION_MAP = (function() {
    var map = {};
    map[WriteEvents.POST_ANNOTATION] = 'Post';
    map[WriteEvents.POST_APPROVE] = 'Approve';
    map[WriteEvents.POST_DELETE] = 'Delete';
    map[WriteEvents.POST_HIDE] = 'Hide';
    map[WriteEvents.POST_REPLY] = 'Reply';
    map[WriteEvents.POST_VOTE] = 'Vote';
    return map;
})();

/** @override */
AuthMenu.prototype.elClass = [
    BaseMenu.CLASSES.MENU,
    AuthMenu.CLASSES.AUTH
].join(' ');

/** @override */
AuthMenu.prototype.events = (function() {
    var events = {};
    var event = UserAgentUtil.isMobile() ? 'tap' : 'click';
    events[event + ' .' + AuthMenu.CLASSES.SIGNIN_BTN] = '_handleLoginClick';
    return events;
})();
$.extend(AuthMenu.prototype.events, Navigable.prototype.events);

/**
 * Handle the login click event. Go back to the previous screen.
 * @private
 */
AuthMenu.prototype._handleLoginClick = function() {
    this.$el.trigger(UserEvents.LOGIN);
    this.$el.trigger(ThreadEvents.NAVIGATE_BACK);
};

/** @override */
AuthMenu.prototype.getTemplateContext = function() {
    var data = BaseMenu.prototype.getTemplateContext.call(this);
    var KEYS = textEnumeration.KEYS;
    var msg = textEnumeration.get(KEYS.MENU_AUTH_SIGNED_IN_MSG);
    $.extend(data.strings, {
        signedInMsg: msg.replace('{action}', EVENT_TO_ACTION_MAP[this.opts.event]),
        signInBtn: textEnumeration.get(KEYS.MENU_AUTH_SIGN_IN_BTN)
    });
    return data;
};

/** @override */
AuthMenu.prototype.subTemplate = require('hgn!templates/thread/menu/auth');

module.exports = AuthMenu;

});

define('annotations/thread/ui/menu/confirm',['require','exports','module','annotations/thread/ui/menu/base','inherits','annotations/i18n/enumeration'],function (require, exports, module) {/**
 * @fileOverview Flag menu view. This provides all of the flagging options to
 * the user so that they can flag a piece of content.
 */

var BaseMenu = require('annotations/thread/ui/menu/base');
var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');

/**
 * Flag menu.
 * @constructor
 * @extends {BaseMenu}
 * @param {Object} opts Config options.
 */
var ConfirmMenu = function (opts) {
    BaseMenu.call(this, opts);

    /** @override */
    this.postEvent = opts.postEvent;

    /**
     * A callback defined by the action being confirmed.
     * @type {?function()}
     */
    this.callback = opts.callback;
};
inherits(ConfirmMenu, BaseMenu);

/** @override */
ConfirmMenu.prototype.getLinkConfig = function () {
    var KEYS = textEnumeration.KEYS;
    var msg = textEnumeration.get(KEYS.MENU_CONFIRM_ACCEPT);
    return [
        {
            key: 'confirm',
            str: msg.replace('{action}', this.opts.actionStr)
        }, {
            key: 'cancel',
            str: textEnumeration.get(KEYS.MENU_CONFIRM_CANCEL)
        }
    ];
};

/** @override */
ConfirmMenu.prototype.getTemplateContext = function () {
    var data = BaseMenu.prototype.getTemplateContext.call(this);
    var KEYS = textEnumeration.KEYS;
    data.strings.title = textEnumeration.get(KEYS.MENU_CONFIRM_TITLE);
    return data;
};

/** @override */
ConfirmMenu.prototype.handleOptionClick = function (ev) {
    var data = this.buildEventData(ev);
    data.callback = this.callback;
    if (data.value === 'cancel') {
        this._handleBackClick(ev);
        return;
    }
    this.$el.trigger(this.postEvent, data);
};

module.exports = ConfirmMenu;

});

define('annotations/thread/ui/menu/edit',['require','exports','module','annotations/thread/ui/menu/base','annotations/thread/ui/editorview','inherits','annotations/i18n/enumeration','annotations/events'],function (require, exports, module) {/**
 * @fileOverview Etc menu view. This is the main view someone sees when they
 * click on the `...` button on a comment. This has all of the options for the
 * comment.
 */
var BaseMenu = require('annotations/thread/ui/menu/base');
var EditorView = require('annotations/thread/ui/editorview');
var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');
var WriteEvents = require('annotations/events').write;

/**
 * Etc menu.
 * @constructor
 * @extends {BaseMenu}
 * @param {Object} opts Config options.
 */
function EditMenu(opts) {
    BaseMenu.call(this, opts);

    /** @override */
    this.postEvent = WriteEvents.POST_EDIT;
}
inherits(EditMenu, BaseMenu);

/** @override */
EditMenu.prototype.getTemplateContext = function () {
    var data = BaseMenu.prototype.getTemplateContext.call(this);
    var KEYS = textEnumeration.KEYS;
    data.strings.title = this._model.parentId ?
        textEnumeration.get(KEYS.EDITOR_EDIT_REPLY_TITLE) :
        textEnumeration.get(KEYS.EDITOR_EDIT_TITLE);
    return data;
};

/** @override */
EditMenu.prototype.render = function () {
    BaseMenu.prototype.render.call(this);
    this._editorView = new EditorView({
        hideOnBlur: false,
        model: this._model,
        postEvent: this.postEvent,
        type: EditorView.TYPES.EDIT
    });
    this._editorView.render();
    this.$('.' + BaseMenu.CLASSES.BODY).append(this._editorView.$el);
};

/**
 * Implement the initialize so that the editor can initialze when actually in the DOM.
 */
EditMenu.prototype.initialize = function () {
    this._editorView.initialize();
};

module.exports = EditMenu;

});

define('annotations/util/date',['require','exports','module','annotations/i18n/enumeration'],function (require, exports, module) {var textEnumeration = require('annotations/i18n/enumeration');

/** @type {Object} */
var util = {};

/**
 * Get a pretty date.
 * @param {Date} date
 * @return {string}
 */
util.getPrettyDate = function (date) {
    var KEYS = textEnumeration.KEYS;
    return [
        textEnumeration.get(KEYS.DATETIME_MONTHS)[date.getMonth()],
        ' ',
        date.getDate(),
        ', ',
        date.getFullYear()
    ].join('');
};

module.exports = util;

});

define("hgn!templates/thread/menu/editlink", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<li data-value=\"");_.b(_.v(_.f("key",c,p,0)));_.b("\" class=\"lf-");_.b(_.v(_.f("key",c,p,0)));_.b(" ");_.b(_.v(_.f("cls",c,p,0)));_.b("\">");_.b("\n" + i);_.b("    <span>");_.b(_.v(_.f("str",c,p,0)));_.b("</span>");_.b("\n" + i);if(_.s(_.f("showTimeRemaining",c,p,1),c,p,0,112,253,"{{ }}")){_.rs(c,p,function(c,p,_){_.b("        <span class=\"lf-edit-timer\">");_.b("\n" + i);_.b("            <span class=\"fycon-clock lf-edit-countdown\">");_.b(_.v(_.f("timeRemaining",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("        </span>");_.b("\n");});c.pop();}_.b("</li>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/mobile/etcmenu", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<span class=\"lf-menu-foot\">");_.b(_.t(_.d("strings.postedAt",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("<a class=\"lf-powered-by\" href=\"http://livefyre.com\" target=\"_blank\">");_.b("\n" + i);_.b("    <span>");_.b(_.v(_.d("strings.appName",c,p,0)));_.b(" powered by</span>");_.b("\n" + i);_.b("</a>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define("hgn!templates/thread/menu/etc", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<span class=\"lf-menu-foot\">");_.b(_.t(_.d("strings.postedAt",c,p,0)));_.b("</span>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/menu/etc',['require','exports','module','jquery','auth','annotations/thread/ui/menu/base','annotations/util/date','hgn!templates/thread/menu/editlink','inherits','annotations/i18n/enumeration','annotations/events','annotations/util/useragent','annotations/enums','annotations/enums','annotations/events','hgn!templates/mobile/etcmenu','hgn!templates/thread/menu/etc'],function (require, exports, module) {/**
 * @fileOverview Etc menu view. This is the main view someone sees when they
 * click on the `...` button on a comment. This has all of the options for the
 * comment.
 */

var $ = require('jquery');
var auth = require('auth');
var BaseMenu = require('annotations/thread/ui/menu/base');
var dateUtil = require('annotations/util/date');
var editLinkTemplate = require('hgn!templates/thread/menu/editlink');
var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;
var userAgentUtil = require('annotations/util/useragent');
var viewEnum = require('annotations/enums').navigableViews;
var visEnums = require('annotations/enums').commentVisibility;
var WriteEvents = require('annotations/events').write;

/**
 * Check if the user is a moderator
 * @param {string} collId
 * @return {boolean}
 */
function isMod(collId) {
    var user = auth.get('livefyre');
    return user ? user.isMod({collectionId: collId}) : false;
}

/**
 * Etc menu.
 * @constructor
 * @extends {BaseMenu}
 * @param {Object} opts Config options.
 */
function EtcMenu(opts) {
    BaseMenu.call(this, opts);

    /** @override */
    this.postEvent = ThreadEvents.NAVIGATE;
}
inherits(EtcMenu, BaseMenu);

/** @enum {string} */
var EVENT_MAP = {
    'approve': WriteEvents.POST_APPROVE,
    'edit': ThreadEvents.NAVIGATE,
    'flag': ThreadEvents.NAVIGATE,
    'share': ThreadEvents.NAVIGATE
};

/** @enum {string} */
EtcMenu.CLASSES = {
    EDIT_COUNTDOWN: 'lf-edit-countdown',
    POWERED_BY: 'lf-powered-by'
};

/** @override */
EtcMenu.prototype._buildMenuLinks = function () {
    var frag = BaseMenu.prototype._buildMenuLinks.call(this);
    if (!this._isEditable()) {
        return frag;
    }
    var showTimeRemaining = !isMod(this._model.meta.collectionId);
    this.$editLink = $(editLinkTemplate({
        key: 'edit',
        str: textEnumeration.get(textEnumeration.KEYS.MENU_ETC_OPTION_EDIT),
        showTimeRemaining: showTimeRemaining,
        timeRemaining: this._getEditTimeRemaining()
    }));
    if (showTimeRemaining) {
        this.$editCountdownEl = this.$editLink.find('.' + EtcMenu.CLASSES.EDIT_COUNTDOWN);
        this._editCountDown = setInterval($.proxy(this._updateEditTimeRemaining, this), 1000);
    }
    frag.appendChild(this.$editLink[0]);
    return frag;
};

/**
 * Build the posted at string.
 * @return {string}
 * @private
 */
EtcMenu.prototype._buildPostedAt = function () {
    var dateStr = dateUtil.getPrettyDate(this._model.createdAt);
    var i18nStr = textEnumeration.get(textEnumeration.KEYS.MENU_ETC_POSTED_AT);
    return i18nStr.replace('{date}', dateStr);
};

/**
 * @return {string} A formatted date object of the time remaining for edit.
 * @private
 */
EtcMenu.prototype._getEditTimeRemaining = function () {
    var editWindow = this._getEditWindow();
    var now = new Date();
    var minDiff = new Date(editWindow - now).getMinutes();
    return minDiff + textEnumeration.get(textEnumeration.KEYS.DATETIME_MINUTE_ABBREVIATION);
};

/**
 * @return {Date}
 * @private
 */
EtcMenu.prototype._getEditWindow = function () {
    var editWindow = new Date(this._model.createdAt);
    var minutesToEdit = this.opts.collection.settings.editCommentInterval;
    return new Date(editWindow.setMinutes(editWindow.getMinutes() + minutesToEdit));
};

/**
 * Handle the delete click event. Determine if the comment should be hidden or
 * deleted depending on whether the current user is the owner of the comment.
 */
EtcMenu.prototype._handleDeleteClick = function () {
    var KEYS = textEnumeration.KEYS;
    var postEvent = WriteEvents.POST_HIDE;

    if (this._isAuthor()) {
        postEvent = WriteEvents.POST_DELETE;
    }

    var model = this._model;
    function cb () {
        model.set({
            lastVisibility: model.visibility,
            visibility: visEnums.NONE
        });
    }
    this.$el.trigger(this.postEvent, {
        actionStr: textEnumeration.get(KEYS.MENU_ETC_OPTION_DELETE),
        model: model,
        postEvent: postEvent,
        value: viewEnum.CONFIRM,
        callback: cb
    });
};

/**
 * Handle a click on the powered by button. Show info about Sidenotes, with version etc.
 * @param {jQuery.Event} ev
 * @private
 */
EtcMenu.prototype._handlePoweredByClick = function (ev) {
    if (this.opts.collection.isCustomNetwork()) {
        return;
    }
    ev.preventDefault();
    this.$el.trigger(ThreadEvents.NAVIGATE, {
        value: viewEnum.INFO
    });
};

/**
 * Determines if the current user can approve this comment.
 * @return {boolean}
 * @private
 */
EtcMenu.prototype._isApprovable = function () {
    var collectionId = this._model.meta.collectionId;
    return this._model.isPending() && isMod(collectionId);
};

/**
 * Determines if the current user is the owner of the current comment.
 * @return {boolean}
 * @private
 */
EtcMenu.prototype._isAuthor = function () {
    return this._model.isUserAuthor();
};

/**
 * Determine if the current user can delete this comment.
 * @return {boolean}
 * @private
 */
EtcMenu.prototype._isDeletable = function () {
    var collectionId = this._model.meta.collectionId;
    return isMod(collectionId) || this._isAuthor();
};

/**
 * Determine if the current user can edit this comment.
 * @return {boolean}
 * @private
 */
EtcMenu.prototype._isEditable = function () {
    var enabled = this.opts.collection.settings.allowEditComments;
    var collectionId = this._model.meta.collectionId;
    var approved = this._model.visibility === visEnums.EVERYONE &&
        this._model.lastVisibility === visEnums.GROUP;
    return !approved && enabled && (isMod(collectionId) || this._isInEditWindow());
};

/**
 * Determine if the current user can flag this comment.
 * @return {boolean}
 * @private
 */
EtcMenu.prototype._isFlaggable = function () {
    return !this._model.isUserAuthor();
};

/**
 * Determine if the comment is still editable.
 * @return {boolean}
 * @private
 */
EtcMenu.prototype._isInEditWindow = function () {
    if (!this._isAuthor()) {
        return false;
    }
    return new Date() < this._getEditWindow();
};

/**
 * Update the time remaining until the edit window is closed.
 * @private
 */
EtcMenu.prototype._updateEditTimeRemaining = function () {
    if (!this._isEditable()) {
        this.$editLink.remove();
        clearInterval(this._editCountDown);
        return;
    }
    if (isMod(this._model.meta.collectionId)) {
        this.$editCountdownEl.remove();
        clearInterval(this._editCountDown);
        return;
    }
    this.$editCountdownEl.html(this._getEditTimeRemaining());
};

/** @override */
EtcMenu.prototype.destroy = function () {
    BaseMenu.prototype.destroy.call(this);
    this.$editCountdownEl = null;
    this.$editLink = null;
    clearInterval(this._editCountDown);
};

/** @override */
EtcMenu.prototype.events = (function() {
    var events = {};
    if (userAgentUtil.isMobile()) {
        events['tap .' + EtcMenu.CLASSES.POWERED_BY] = '_handlePoweredByClick';
    }
    return events;
})();
$.extend(EtcMenu.prototype.events, BaseMenu.prototype.events);

/** @override */
EtcMenu.prototype.getLinkConfig = function () {
    var KEYS = textEnumeration.KEYS;
    var cfg = [{
        key: 'share',
        str: textEnumeration.get(KEYS.MENU_ETC_OPTION_SHARE)
    }];
    if (this._isFlaggable()) {
        cfg.push({
            key: 'flag',
            str: textEnumeration.get(KEYS.MENU_ETC_OPTION_FLAG)
        });
    }
    if (this._isDeletable()) {
        cfg.push({
            key: 'delete',
            str: textEnumeration.get(KEYS.MENU_ETC_OPTION_DELETE)
        });
    }
    if (this._isApprovable()) {
        cfg.push({
            key: 'approve',
            str: textEnumeration.get(KEYS.MENU_ETC_OPTION_APPROVE)
        });
    }
    return cfg;
};

/** @override */
EtcMenu.prototype.getTemplateContext = function () {
    var data = BaseMenu.prototype.getTemplateContext.call(this);
    var KEYS = textEnumeration.KEYS;
    $.extend(data.strings, {
        appName: textEnumeration.get(KEYS.APP_NAME),
        postedAt: this._buildPostedAt(),
        title: textEnumeration.get(KEYS.MENU_ETC_TITLE)
    });
    return data;
};

/** @override */
EtcMenu.prototype.handleOptionClick = function (ev) {
    var $target = $(ev.currentTarget);
    var value = $target.attr('data-value');

    if (value === 'delete') {
        return this._handleDeleteClick();
    }

    this.postEvent = EVENT_MAP[value];
    BaseMenu.prototype.handleOptionClick.call(this, ev);
};

/** @override */
EtcMenu.prototype.subTemplate = userAgentUtil.isMobile() ? require('hgn!templates/mobile/etcmenu') :
    require('hgn!templates/thread/menu/etc');

module.exports = EtcMenu;

});

define('annotations/thread/ui/menu/flag',['require','exports','module','annotations/thread/ui/menu/base','inherits','annotations/i18n/enumeration','annotations/events'],function (require, exports, module) {/**
 * @fileOverview Flag menu view. This provides all of the flagging options to
 * the user so that they can flag a piece of content.
 */

var BaseMenu = require('annotations/thread/ui/menu/base');
var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');
var WriteEvents = require('annotations/events').write;

/**
 * Flag menu.
 * @constructor
 * @extends {BaseMenu}
 * @param {Object} opts Config options.
 */
var FlagMenu = function(opts) {
    BaseMenu.call(this, opts);

    /** @override */
    this.postEvent = WriteEvents.POST_FLAG;
};
inherits(FlagMenu, BaseMenu);

/** @override */
FlagMenu.prototype.getLinkConfig = function() {
    var KEYS = textEnumeration.KEYS;
    return [
        {
            key: 'spam',
            str: textEnumeration.get(KEYS.MENU_FLAG_OPTION_SPAM)
        }, {
            key: 'offensive',
            str: textEnumeration.get(KEYS.MENU_FLAG_OPTION_OFFENSIVE)
        }, {
            key: 'disagree',
            str: textEnumeration.get(KEYS.MENU_FLAG_OPTION_DISAGREE)
        }, {
            key: 'off-topic',
            str: textEnumeration.get(KEYS.MENU_FLAG_OPTION_OFF_TOPIC)
        }
    ];
};

/** @override */
FlagMenu.prototype.getTemplateContext = function() {
    var data = BaseMenu.prototype.getTemplateContext.call(this);
    data.strings.title = textEnumeration.get(textEnumeration.KEYS.MENU_FLAG_TITLE);
    return data;
};

module.exports = FlagMenu;

});

define("hgn!templates/thread/menu/info", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"fycon-icon-sidenotes\" />");_.b("\n" + i);_.b("<h3>");_.b(_.v(_.d("strings.appName",c,p,0)));_.b("</h3>");_.b("\n" + i);_.b("<span class=\"lf-powered-by\">powered by</span>");_.b("\n" + i);_.b("<span class=\"lf-version\">");_.b(_.v(_.d("strings.version",c,p,0)));_.b("</span>");_.b("\n" + i);_.b("<a href=\"http://web.livefyre.com\" target=\"_blank\">");_.b(_.v(_.d("strings.livefyreLink",c,p,0)));_.b("</a>");_.b("\n" + i);_.b("<a href=\"http://support.livefyre.com\" target=\"_blank\" class=\"lf-help fycon-question\">");_.b(_.v(_.d("strings.helpLink",c,p,0)));_.b("</a>");_.b("\n" + i);_.b("<label class=\"lf-copyright lf-menu-foot\">");_.b(_.t(_.d("strings.copyright",c,p,0)));_.b("</label>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/menu/info',['require','exports','module','jquery','annotations/thread/ui/menu/base','inherits','annotations/i18n/enumeration','hgn!templates/thread/menu/info'],function (require, exports, module) {/**
 * @fileOverview Annotations/Livefyre info menu.
 */

var $ = require('jquery');
var BaseMenu = require('annotations/thread/ui/menu/base');
var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');

/**
 * Info menu.
 * @constructor
 * @extends {BaseMenu}
 * @param {Object} opts Config options.
 */
var InfoMenu = function(opts) {
    BaseMenu.call(this, opts);
};
inherits(InfoMenu, BaseMenu);

/** @enum {string} */
InfoMenu.CLASSES = {
    INFO: 'lf-info'
};

/** @override */
InfoMenu.prototype.elClass = [
    BaseMenu.CLASSES.MENU,
    InfoMenu.CLASSES.INFO
].join(' ');

/** @override */
InfoMenu.prototype.getLinkConfig = function() {
    return [];
};

/** @override */
InfoMenu.prototype.getTemplateContext = function() {
    var data = BaseMenu.prototype.getTemplateContext.call(this);
    var KEYS = textEnumeration.KEYS;
    $.extend(data.strings, {
        appName: textEnumeration.get(KEYS.APP_NAME),
        copyright: textEnumeration.get(KEYS.MENU_INFO_COPYRIGHT),
        helpLink: textEnumeration.get(KEYS.MENU_INFO_HELP),
        livefyreLink: textEnumeration.get(KEYS.MENU_INFO_LF_LINK),
        version: textEnumeration.get(KEYS.APP_VERSION)
    });
    return data;
};

/** @override */
InfoMenu.prototype.handleOptionClick = function(ev) {
    ev.stopPropagation();
};

/** @override */
InfoMenu.prototype.subTemplate = require('hgn!templates/thread/menu/info');

module.exports = InfoMenu;

});

define("hgn!templates/thread/permalinkmissing", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"fycon-composer-sad\" />");_.b("\n" + i);_.b("<h4 class=\"lf-permalink-missing\">");_.b(_.v(_.f("doesNotExist",c,p,0)));_.b("</h4>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/permalinkthreadcontainer',['require','exports','module','jquery','annotations/models/comment','annotations/events','inherits','annotations/mobile/thread/ui/navbar','hgn!templates/thread/permalinkmissing','annotations/i18n/enumeration','annotations/thread/ui/threadcontainer','annotations/events','hgn!templates/thread/threadcontainer'],function (require, exports, module) {/**
 * @fileOverview Permalink thread container.
 */

var $ = require('jquery');
var Comment = require('annotations/models/comment');
var CommentEvents = require('annotations/events').comment;
var inherits = require('inherits');
var NavBar = require('annotations/mobile/thread/ui/navbar');
var permalinkMissingTemplate = require('hgn!templates/thread/permalinkmissing');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadContainer = require('annotations/thread/ui/threadcontainer');
var ThreadEvents = require('annotations/events').thread;

/**
 * Permalink thread container.
 * @extends {ThreadContainer}
 * @param {Object} opts
 */
function PermalinkThreadContainer(opts) {
    ThreadContainer.call(this, opts);

    /**
     * The navbar component.
     * @type {?NavBar}
     * @private
     */
    this._navbar = null;
}
inherits(PermalinkThreadContainer, ThreadContainer);

/** @enum {string} */
var CLASSES = {
    MAIN: 'lf-permalink',
    STREAM: 'lf-thread-container'
};

/** @override */
PermalinkThreadContainer.prototype.elClass = CLASSES.MAIN;

/** @override */
PermalinkThreadContainer.prototype.elTag = 'section';

/** @override */
PermalinkThreadContainer.prototype.events = (function () {
    var events = {};
    events[CommentEvents.HIDDEN] = '_handleTopCommentHidden';
    return events;
})();
$.extend(PermalinkThreadContainer.prototype.events, ThreadContainer.prototype.events);

/** @override */
PermalinkThreadContainer.prototype.template = require('hgn!templates/thread/threadcontainer');

/**
 * Handle the comment hidden event. Check if the comment is top level and then
 * show the empty message since there is only 1 top level comment.
 * @param {jQuery.Event} ev
 * @param {Comment} comment
 * @private
 */
PermalinkThreadContainer.prototype._handleTopCommentHidden = function (ev, comment) {
    comment.id === this._topComment.id && this._showEmptyPermalinkMessage();
};

/**
 * Show the permalink does not exist message.
 * @private
 */
PermalinkThreadContainer.prototype._showEmptyPermalinkMessage = function () {
    this.getContainerElement().html(permalinkMissingTemplate({
        doesNotExist: textEnumeration.get(textEnumeration.KEYS.PERMALINK_MISSING)
    }));
};

/** @override */
PermalinkThreadContainer.prototype.addComment = function(comments, opt_prepend, opt_el) {
    var comment = $.isArray(comments) ? comments[0] : comments;
    // Don't allow comments to stream in. The permalink comments will always
    // have bootstrap as their origin.
    if (!comment || comment.origin === Comment.ORIGIN.STREAM) {
        return;
    }
    ThreadContainer.prototype.addComment.apply(this, arguments);
};

/** @override */
PermalinkThreadContainer.prototype.destroy = function () {
    ThreadContainer.prototype.destroy.call(this);
    this._navbar && this._navbar.destroy();
};

/** @override */
PermalinkThreadContainer.prototype.getContainerElement = function () {
    return this.$('.' + CLASSES.STREAM);
};

/**
 * This class is used as a view in the ThreadController. When it asks for the
 * thread container, it just needs to return itself.
 * @return {PermalinkThreadContainer}
 */
PermalinkThreadContainer.prototype.getThreadContainer = function () {
    return this;
};

/** @override */
PermalinkThreadContainer.prototype.initialize = function (comments) {
    if (this._initialized) {
        return;
    }
    this._initialized = true;
    // It's possible that there are no comments. In this case we should show
    // a 404 screen.
    if (!comments || !comments.length) {
        this._showEmptyPermalinkMessage();
        return;
    }

    ThreadContainer.prototype.initialize.call(this, comments);

    // Grab the only top level comment in the array of comments. Don't need to
    // iterate over all of them since there will only ever be 1.
    for (var i=0, len=comments.length; i<len; i++) {
        this._topComment = comments[i];
        if (!this._topComment.parentId) {
            break;
        }
    }

    // Get the TopCommentView for this top level comment, highlight it's
    // selected text if it has some and then disable mouse events on the comment
    // so that it won't unhighlight.
    var commentView = this._comments[this._topComment.id];
    commentView.handleMouseEnter();
    commentView.disableMouseEvents(true);
};

/** @override */
PermalinkThreadContainer.prototype.render = function () {
    ThreadContainer.prototype.render.call(this);

    var KEYS = textEnumeration.KEYS;
    this._navbar = new NavBar({
        backEvent: ThreadEvents.PERMALINK_BACK,
        backStr: textEnumeration.get(KEYS.PERMALINK_BACK_BTN),
        title: textEnumeration.get(KEYS.PERMALINK_TITLE)
    });

    this._navbar.render();
    this.$el.prepend(this._navbar.$el);
};

module.exports = PermalinkThreadContainer;

});

define('annotations/util/permalink',['require','exports','module','jquery','annotations/util/dom'],function (require, exports, module) {/**
 * @fileOverview Permalink processing.
 */

var $ = require('jquery');
var domUtil = require('annotations/util/dom');

/** @type {Object} */
var util = {};

/**
 * Scroll the view to the permalink. This calculates the scroll position of the
 * permalink's block on the page, the duration required to get the page scrolled
 * there, and then animates.
 * @param {Element} el The element to scroll to.
 * @param {function()} callback The callback function.
 */
util.scrollToPermalink = function (el, callback) {
    var scrollTop = el.offsetTop - 20;
    var duration = Math.min(Math.abs(domUtil.getScrollY() - scrollTop) * 2, 1000);
    $('body').animate({ scrollTop: scrollTop }, duration, callback);
};

module.exports = util;

});

define("hgn!templates/thread/menu/share", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<footer class=\"lf-menu-foot\">");_.b("\n" + i);_.b("    <textarea readonly>");_.b(_.v(_.f("permalink",c,p,0)));_.b("</textarea>");_.b("\n" + i);_.b("</footer>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/menu/share',['require','exports','module','jquery','annotations/thread/ui/menu/base','annotations/events','inherits','livefyre-bootstrap/loader','hgn!templates/thread/loader','annotations/util/internals','hgn!templates/thread/menu/share','annotations/i18n/enumeration','annotations/events'],function (require, exports, module) {/**
 * @fileOverview Flag menu view. This provides all of the flagging options to
 * the user so that they can flag a piece of content.
 */

var $ = require('jquery');
var BaseMenu = require('annotations/thread/ui/menu/base');
var CommentEvents = require('annotations/events').comment;
var inherits = require('inherits');
var loader = require('livefyre-bootstrap/loader');
var loaderTemplate = require('hgn!templates/thread/loader');
var nullFunction = require('annotations/util/internals').nullFunction;
var shareTemplate = require('hgn!templates/thread/menu/share');
var textEnumeration = require('annotations/i18n/enumeration');
var WriteEvents = require('annotations/events').write;

/**
 * Flag menu.
 * @constructor
 * @extends {BaseMenu}
 * @param {Object} opts Config options.
 */
function ShareMenu(opts) {
    BaseMenu.call(this, opts);

    /** @override */
    this.postEvent = WriteEvents.POST_SHARE;
}
inherits(ShareMenu, BaseMenu);

/** @enum {string} */
ShareMenu.CLASSES = {
    FOOTER: 'lf-menu-foot',
    LINK: 'lf-link',
    SHARE: 'lf-share'
};

/** @override */
ShareMenu.prototype.elClass = [
    BaseMenu.CLASSES.MENU,
    ShareMenu.CLASSES.SHARE
].join(' ');

/** @override */
ShareMenu.prototype.events = (function() {
    var events = {};
    events['click .' + ShareMenu.CLASSES.FOOTER] = '_handleTextareaClick';
    return events;
})();
$.extend(ShareMenu.prototype.events, BaseMenu.prototype.events);

/**
 * Fetches permalink data.
 * @private
 */
ShareMenu.prototype._fetchPermalink = function () {
    if (this._model.permalink) {
        this._renderContent();
        return;
    }

    this.$el.trigger(CommentEvents.GET_PERMALINK, {
        callback: $.proxy(this._handleFetchSuccess, this),
        messageId: this._model.id
    });
};

/**
 * Successfully fetched the permalink. Show the menu.
 * @param {?string} err
 * @param {?string} permalink
 * @private
 */
ShareMenu.prototype._handleFetchSuccess = function (err, permalink) {
    this._model.permalink = permalink;
    this._renderContent();
};

/**
 * Handle the textarea click. Select the contents of the textarea.
 * @private
 */
ShareMenu.prototype._handleTextareaClick = function () {
    this.$textarea.select();
};


/**
 * Render in full.
 */
ShareMenu.prototype._renderContent = function () {
    var frag = this._buildMenuLinks();
    var $shareBody = $(shareTemplate({permalink: this._model.permalink}));
    this.$textarea = $shareBody.children().first();
    frag.appendChild($shareBody[0]);
    this.$('.' + BaseMenu.CLASSES.BODY).html('').append(frag);

    this.delegateEvents();
};

/** @override */
ShareMenu.prototype.getLinkConfig = function () {
    return [
        {
            cls: 'fycon-source-twitter',
            key: 'twitter',
            str: 'Twitter'
        }, {
            cls: 'fycon-source-facebook',
            key: 'facebook',
            str: 'Facebook'
        }
    ];
};

/** @override */
ShareMenu.prototype.getTemplateContext = function () {
    var data = BaseMenu.prototype.getTemplateContext.call(this);
    var KEYS = textEnumeration.KEYS;
    data.strings.title = textEnumeration.get(KEYS.MENU_SHARE_TITLE);
    return data;
};

/**
 * Initialize the share menu. This fetches the permalink.
 */
ShareMenu.prototype.initialize = function () {
    this._fetchPermalink();
};

/** @override */
ShareMenu.prototype.loadMenuLinks = nullFunction;

/**
 * Initial render (w/ content obscured by loader)
 * @override
 */
ShareMenu.prototype.render = function () {
    BaseMenu.prototype.render.call(this);

    var $container = $(loaderTemplate());
    this.$('.' + BaseMenu.CLASSES.BODY).append($container);
    loader.decorate($container, 60);
};

module.exports = ShareMenu;

});

define('annotations/thread/ui/threadpopover',['require','exports','module','jquery','annotations/util/internals','inherits','annotations/ui/popover'],function (require, exports, module) {/**
 * @fileoverview
 * The tooltip for sharing a selection or adding an annotation.
 */

var $ = require('jquery');
var debounce = require('annotations/util/internals').debounce;
var inherits = require('inherits');
var Popover = require('annotations/ui/popover');

/**
 * @constructor
 * @param {Object} opts View config opts
 * @param {View} opts.content
 * @extends {Popover}
 */
function ThreadPopover(opts) {
    Popover.call(this, $.extend({
        /**
         * Amount of pixels to pad the right of the popover.
         * @type {number}
         */
        leftPadding: 30,

        /**
         * Max width of the popover.
         * @type {number}
         */
        maxWidth: opts.maxWidth || 600,

        /**
         * Minimum amount of pixels that the popover should be in view. This
         * relates to when the popover is displayed at the bottom of the
         * viewport and is outside of the bottom fold. This amount of pixels
         * must be above the fold.
         * @type {number}
         */
        minPopoverInView: 200,

        /**
         * Min width of the popover.
         * @type {number}
         */
        minWidth: 320,

        /**
         * The amount of time the scroll animation should take to bring the
         * popover into view at the top or bottom of the viewport.
         * @type {number}
         */
        scrollDuration: 500,

        /**
         * Amount of pixels to pad the popover with.
         * @type {number}
         */
        sidePadding: 10,

        /**
         * Amount of pixels that should be above the popover at the top of
         * the viewport.
         * @type {number}
         */
        topSpacing: 20
    }, opts));

    /**
     * The position of the popover. It defaults to smart positioning.
     * @type {string}
     */
    this._position = this.opts.position || Popover.POSITIONS.SMART;
}
inherits(ThreadPopover, Popover);

/** @enum {string} */
ThreadPopover.CLASSES = {
    MAIN: 'lf-thread-popover',
    MEDIA_WRAPPER: 'lf-media-wrapper',
    POSITION_PREFIX: 'lf-pos-'
};
$.extend(ThreadPopover.CLASSES, Popover.CLASSES);

/** @override */
ThreadPopover.prototype.elClass = [
    Popover.prototype.elClass,
    ThreadPopover.CLASSES.MAIN
].join(' ');

/**
 * The amount of time to wait for the popover to resize after the window has
 * been resized. Don't want to do it too soon in case the user isn't satisfied.
 * @const {number}
 */
var WINDOW_RESIZE_DELAY = 500;

/**
 * Resize timeout var.
 * @type {number}
 */
var resizeTimeout;

/**
 * Handle the resize event. Trigger a timeout for a certain amount of time until
 * the popover should reposition itself.
 * @private
 */
ThreadPopover.prototype._handleResize = debounce(function () {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout($.proxy(function () {
        this.resizeAndReposition(this._blockEl);
    }, this), WINDOW_RESIZE_DELAY);
}, 200);

/** @override */
ThreadPopover.prototype.hide = function (opt_callback) {
    Popover.prototype.hide.call(this, opt_callback);
    $(window).off('resize', $.proxy(this._handleResize, this));
};

/** @override */
ThreadPopover.prototype.show = function (el, opt_callback) {
    this._blockEl = el;
    Popover.prototype.show.call(this, el, opt_callback);
    $(window).on('resize', $.proxy(this._handleResize, this));
};

module.exports = ThreadPopover;

});

define("hgn!templates/thread/thread/anonauthor", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<img src=\"");_.b(_.v(_.f("assetServer",c,p,0)));_.b("/images/default-avatar.png\" class=\"lf-anon-avatar\" />");_.b("\n" + i);_.b("<div class=\"lf-anon-editor\">");_.b(_.t(_.d("strings.signInToPost",c,p,0)));_.b("</div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/thread/anonauthorview',['require','exports','module','inherits','annotations/i18n/enumeration','view','annotations/events','hgn!templates/thread/thread/anonauthor'],function (require, exports, module) {/**
 * @fileOverview The anonymous author view class.
 */

var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');
var View = require('view');
var UserEvents = require('annotations/events').user;

/**
 * Author view.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
var AnonAuthorView = function(opts) {
    View.call(this, opts);
};
inherits(AnonAuthorView, View);

/** @enum {string} */
AnonAuthorView.CLASSES = {
    ANON_AUTHOR: 'lf-anon-author'
};

/** @override */
AnonAuthorView.prototype.elClass = AnonAuthorView.CLASSES.ANON_AUTHOR;

/** @override */
AnonAuthorView.prototype.events = {
    'click': '_handleLogin'
};

/** @override */
AnonAuthorView.prototype.template = require('hgn!templates/thread/thread/anonauthor');

/**
 * Handle the log in button click.
 * @private
 */
AnonAuthorView.prototype._handleLogin = function(ev) {
    this.$el.trigger(UserEvents.LOGIN);
};

/** @override */
AnonAuthorView.prototype.getTemplateContext = function() {
    return {
        assetServer: this.opts.assetServer,
        strings: {
            signInToPost: textEnumeration.get(textEnumeration.KEYS.SIGN_IN_TO_POST)
        }
    };
};

module.exports = AnonAuthorView;

});

define("hgn!templates/thread/thread/author", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-author-flip\">");_.b("\n" + i);_.b("    <div class=\"lf-author-flip-front\">");_.b("\n" + i);_.b("        <img src=\"");_.b(_.v(_.f("avatar",c,p,0)));_.b("\" class=\"lf-author-avatar\" onerror=\"javascript:this.src='");_.b(_.v(_.f("defaultAvatar",c,p,0)));_.b("';\" />");_.b("\n" + i);_.b("    </div>");_.b("\n" + i);_.b("    <div class=\"lf-author-flip-back fycon-settings-gear\"></div>");_.b("\n" + i);_.b("</div>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/thread/authorview',['require','exports','module','annotations/adapters','auth','inherits','annotations/events','view','hgn!templates/thread/thread/author'],function (require, exports, module) {/**
 * @fileOverview The author view class.
 */

var adaptAvatar = require('annotations/adapters').adaptAvatar;
var auth = require('auth');
var inherits = require('inherits');
var ThreadEvents = require('annotations/events').thread;
var View = require('view');

/**
 * Author view.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
var AuthorView = function(opts) {
    View.call(this, opts);
};
inherits(AuthorView, View);

/** @enum {string} */
AuthorView.CLASSES = {
    AUTHOR: 'lf-author-view'
};

/** @override */
AuthorView.prototype.elClass = AuthorView.CLASSES.AUTHOR;

/** @override */
AuthorView.prototype.events = {
    'click': '_handleClick'
};

/** @override */
AuthorView.prototype.template = require('hgn!templates/thread/thread/author');

/**
 * Handle the click event on the author's avatar.
 * @param {jQuery.Event} ev
 * @private
 */
AuthorView.prototype._handleClick = function (ev) {
    ev.stopPropagation();
    this.$el.trigger(ThreadEvents.NAVIGATE, {
        value: 'user'
    });
};

/** @override */
AuthorView.prototype.getTemplateContext = function () {
    var user = auth.get('livefyre');
    return {
        avatar: user ? adaptAvatar(user.get('avatar')) : '',
        defaultAvatar: this.opts.defaultAvatar
    };
};

module.exports = AuthorView;

});

define("hgn!templates/thread/thread/gradient", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<div class=\"lf-thread-gradient\" />");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/queuedecorator',['require','exports','module','jquery','annotations/models/comment','annotations/thread/ui/queuebutton','annotations/i18n/enumeration','annotations/events'],function (require, exports, module) {/**
 * @fileOverview Decorates a BaseThreadContaienr instance with new functions
 * and function overrides to support queue comment functionality.
 */

var $ = require('jquery');
var Comment = require('annotations/models/comment');
var QueueButton = require('annotations/thread/ui/queuebutton');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;

/** @type {Object} */
var QueueDecorator = {};

/** @enum {string} */
var CLASSES = {
    GRADIENT: 'lf-thread-gradient'
};

/**
 * Decorate a BaseThreadContainer class with queue comment functionality.
 * @param {BaseThreadContainer} threadContainer
 */
QueueDecorator.decorate = function(threadContainer) {
    var KEYS = textEnumeration.KEYS;
    var queueBtn = new QueueButton({
        plural: textEnumeration.get(KEYS.QUEUED_COMMENTS_PLURAL),
        singular: textEnumeration.get(KEYS.QUEUED_COMMENTS_SINGULAR)
    });
    queueBtn.render();

    threadContainer._queueBtn = queueBtn;
    threadContainer._queuedComments = [];
    decorateDestroy(threadContainer);
    decorateProcessComment(threadContainer);
    threadContainer.queueComment = queueComment;
    threadContainer.showQueuedComments = showQueuedComments;

    threadContainer._queueBtn.$el.on(ThreadEvents.SHOW_QUEUED_CONTENT,
        $.proxy(threadContainer.showQueuedComments, threadContainer));
};

/**
 * Decorate the destroy function. This should unlisten to the show queue content
 * function in addition to it's normal duties.
 * @param {BaseThreadContainer} threadContainer
 */
function decorateDestroy(threadContainer) {
    var existing = threadContainer.destroy;
    threadContainer.destroy = function() {
        existing.call(this);
        this._queueBtn.$el.off(ThreadEvents.SHOW_QUEUED_CONTENT,
            $.proxy(this.showQueuedComments, this));
    };
}

/**
 * Decorate the processComment function. This should determine whether or not
 * a comment should be processed or not depending on the origin.
 * @param {BaseThreadContainer} threadContainer
 */
function decorateProcessComment(threadContainer) {
    var existing = threadContainer.processComment;
    threadContainer.processComment = function(prepend, el, i, comment, opt_force) {
        var haveSeen = comment.hasBeenRendered;
        var isAuthor = comment.isUserAuthor();
        var isReply = !!comment.parentId;
        var isStream = comment.origin === Comment.ORIGIN.STREAM;

        // Streamed comments should be added to the queue.
        if (!opt_force && !isReply && !haveSeen && !isAuthor && isStream) {
            this.queueComment(comment);
            return;
        }
        existing.call(this, prepend, el, i, comment);
    };
}

/**
 * Queue a comment. Show the queue button.
 * @param {Comment} comment The comment to queue.
 */
function queueComment(comment) {
    this._queuedComments.push(comment);

    // If the parent node doesn't exist yet, that means it hasn't been added,
    // so add it now before showing it.
    if (!this._queueBtn.el.parentNode) {
        this._queueBtn.$el.insertBefore(this.$el.siblings('.' + CLASSES.GRADIENT));
    }
    this._queueBtn.setCount(this._queuedComments.length);
    this._queueBtn.show();
}

/**
 * Show all queued comments. Hide the queue button. Doesn't have to be a handler
 * of an event, but if it is, it should stop the event in it's tracks.
 * @param {jquery.Event=} opt_ev
 */
function showQueuedComments(opt_ev) {
    opt_ev && opt_ev.stopPropagation();
    var elem = this.getContainerElement();

    $.each(this._queuedComments, $.proxy(function(i, comment) {
        this.processComment(true, elem, null, comment, true);
    }, this));

    this._queuedComments = [];
    this._queueBtn.hide();
}

module.exports = QueueDecorator;

});

define("hgn!templates/thread/thread/view", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b(_.rp("loader",c,p,""));_.b("<a class=\"lf-powered-by\" href=\"http://livefyre.com\" target=\"_blank\">");_.b("\n" + i);_.b("    <span>");_.b(_.v(_.d("strings.appName",c,p,0)));_.b(" powered by</span>");_.b("\n" + i);_.b("</a>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/thread/view',['require','exports','module','jquery','annotations/thread/ui/thread/anonauthorview','auth','annotations/thread/ui/thread/authorview','streamhub-sdk/debug','annotations/thread/ui/editorview','hgn!templates/thread/thread/gradient','inherits','livefyre-bootstrap/loader','observer','annotations/thread/ui/queuedecorator','annotations/i18n/enumeration','annotations/thread/ui/threadcontainer','annotations/events','view','annotations/enums','annotations/events','hgn!templates/thread/thread/view','hgn!templates/thread/loader'],function (require, exports, module) {/**
 * @fileOverview The thread view class. This is the base view that loads the
 * editor and stream views. This is what gets loaded when the popover shows.
 */

var $ = require('jquery');
var AnonAuthorView = require('annotations/thread/ui/thread/anonauthorview');
var auth = require('auth');
var AuthorView = require('annotations/thread/ui/thread/authorview');
var debug = require('streamhub-sdk/debug');
var EditorView = require('annotations/thread/ui/editorview');
var gradientTemplate = require('hgn!templates/thread/thread/gradient');
var inherits = require('inherits');
var loader = require('livefyre-bootstrap/loader');
var Observer = require('observer');
var QueueDecorator = require('annotations/thread/ui/queuedecorator');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadContainer = require('annotations/thread/ui/threadcontainer');
var ThreadEvents = require('annotations/events').thread;
var View = require('view');
var viewEnum = require('annotations/enums').navigableViews;
var WriteEvents = require('annotations/events').write;

var log = debug('annotations/thread/ui/thread/view');

/**
 * Stream view.
 * @constructor
 * @extends {View}
 * @param {Object} opts Config options.
 */
var ThreadView = function(opts) {
    View.call(this, opts);

    /**
     * Author view.
     * @type {?(AuthorView|AnonAuthorView)}
     * @private
     */
    this._authorView = null;

    /**
     * Editor view.
     * @type {?EditorView}
     * @private
     */
    this._editorView = null;

    /**
     * Whether the user is logged in or not.
     * @type {boolean}
     * @private
     */
    this._loggedIn = false;

    /**
     * Stream view.
     * @type {ThreadContainer}
     * @private
     */
    this._streamView = this.createStreamView({
        assetServer: opts.assetServer,
        defaultAvatar: opts.defaultAvatar
    });

    QueueDecorator.decorate(this._streamView);

    // Bind login and logout events.
    Observer(this);
    this.listenTo(auth, 'login.livefyre', $.proxy(this._handleUserLogin, this));
    this.listenTo(auth, 'logout', $.proxy(this._handleUserLogout, this));
};
inherits(ThreadView, View);

/** @enum {string} */
ThreadView.CLASSES = {
    LOADER: 'lf-loader-container',
    POWERED_BY: 'lf-powered-by',
    THREAD: 'lf-thread'
};

/** @override */
ThreadView.prototype.elClass = ThreadView.CLASSES.THREAD;

/** @override */
ThreadView.prototype.elTag = 'section';

/** @override */
ThreadView.prototype.events = (function () {
    var events = {};
    events['click .' + ThreadView.CLASSES.POWERED_BY] = '_handlePoweredByClick';
    return events;
})();

/** @override */
ThreadView.prototype.template = require('hgn!templates/thread/thread/view');

/**
 * Handle the powered by click event. Open the info menu.
 * @param {jQuery.Event} ev
 * @private
 */
ThreadView.prototype._handlePoweredByClick = function (ev) {
    if (this.opts.isCustomNetwork) {
        return;
    }
    ev.preventDefault();
    this.$el.trigger(ThreadEvents.NAVIGATE, {
        value: viewEnum.INFO
    });
};

/**
 * Handle the user login event.
 * @private
 */
ThreadView.prototype._handleUserLogin = function () {
    if (this._loggedIn) {
        return;
    }
    this._loggedIn = true;
    this._authorView && this._authorView.destroy();
    this._authorView = new AuthorView({
        defaultAvatar: this.opts.defaultAvatar
    });
    this._authorView.render();

    this._editorView = new EditorView({
        editorId: this.opts.blockId,
        postEvent: WriteEvents.POST_ANNOTATION
    });
    this._editorView.render();
    this.$el.prepend(this._authorView.$el, this._editorView.$el);
    this._editorView.initialize();
};

/**
 * Handle the user logout event.
 * @private
 */
ThreadView.prototype._handleUserLogout = function () {
    this._loggedIn = false;
    this._authorView && this._authorView.destroy();
    this._editorView && this._editorView.destroy();
    this._editorView = null;

    this._authorView = new AnonAuthorView({
        assetServer: this.opts.assetServer
    });
    this._authorView.render();
    this.$el.prepend(this._authorView.$el);
};

/**
 * Load the thread view the way FSM intended, with an editor and content.
 * @private
 */
ThreadView.prototype._renderChildren = function () {
    this.$el.prepend($(gradientTemplate()));
    this._streamView.render();
    this.$('.' + ThreadView.CLASSES.LOADER).remove();
    this.$el.children().first().after(this._streamView.$el);

    if (auth.get('livefyre')) {
        this._handleUserLogin();
        return;
    }
    this._handleUserLogout();
};

/**
 * @param {Object} opts
 * @return {ThreadContainer} comment
 */
ThreadView.prototype.createStreamView = function (opts) {
    return new ThreadContainer(opts);
};

/** @override */
ThreadView.prototype.destroy = function () {
    View.prototype.destroy.call(this);

    this._authorView && this._authorView.destroy();
    this._authorView = null;
    this._editorView && this._editorView.destroy();
    this._editorView = null;

    this.stopListening();
};

/** @override */
ThreadView.prototype.getTemplateContext = function () {
    return {
        strings: {
            appName: textEnumeration.get(textEnumeration.KEYS.APP_NAME)
        }
    };
};

/**
 * @return {ThreadContainer} comment
 */
ThreadView.prototype.getThreadContainer = function () {
    return this._streamView;
};

/**
 * Handle the thread retrieval failure response.
 * @param {string} err Err info.
 */
ThreadView.prototype.handleFetchThreadFailure = function (err) {
    err && log(err);
    this._renderChildren();
};

/**
 * Handle the thread retrieval success response, or the case of a new thread
 * with no content yet. Load the thread view the way FSM intended, with an
 * editor and content.
 * @param {?Array.<Comment>} opt_comments Thread data.
 */
ThreadView.prototype.handleFetchThreadSuccess = function (opt_comments) {
    this._renderChildren();

    if (!opt_comments || !opt_comments.length) {
        return;
    }

    // Need to sort the comments so that we have the top level comments come
    // before the replies.
    opt_comments.sort(function(a, b) {
        return !a.parentId ? -1 : 1;
    });
    this._streamView.initialize(opt_comments);
};

/** @override */
ThreadView.prototype.render = function () {
    this.$el.html(this.template(this.getTemplateContext(), {
        loader: require('hgn!templates/thread/loader').template
    }));
    loader.decorate(this.$('.' + ThreadView.CLASSES.LOADER), 60);
};

module.exports = ThreadView;

});

define("hgn!templates/thread/menu/user", ["hogan"], function(hogan){  var tmpl = new hogan.Template(function(c,p,i){var _=this;_.b(i=i||"");_.b("<img src=\"");_.b(_.v(_.f("avatar",c,p,0)));_.b("\" class=\"lf-title-avatar\" />");_.b("\n" + i);_.b("<span class=\"lf-title-display-name\">");_.b(_.v(_.f("displayName",c,p,0)));_.b("</span>");_.b("\n");return _.fl();;}, "", hogan);  function render(){ return tmpl.render.apply(tmpl, arguments); } render.template = tmpl; return render;});

define('annotations/thread/ui/menu/user',['require','exports','module','jquery','annotations/adapters','auth','annotations/thread/ui/menu/base','inherits','annotations/i18n/enumeration','annotations/events','annotations/events','hgn!templates/thread/menu/user'],function (require, exports, module) {/**
 * @fileOverview User menu view. This provides all of the user options.
 */

var $ = require('jquery');
var adaptAvatar = require('annotations/adapters').adaptAvatar;
var auth = require('auth');
var BaseMenu = require('annotations/thread/ui/menu/base');
var inherits = require('inherits');
var textEnumeration = require('annotations/i18n/enumeration');
var ThreadEvents = require('annotations/events').thread;
var UserEvents = require('annotations/events').user;
var userMenuTemplate = require('hgn!templates/thread/menu/user');

/**
 * User menu.
 * @constructor
 * @extends {BaseMenu}
 * @param {Object} opts Config options.
 */
function UserMenu(opts) {
    BaseMenu.call(this, opts);
}
inherits(UserMenu, BaseMenu);

/** @enum {string} */
var OPTIONS = {
    ADMIN: 'admin',
    EDIT_PROFILE: 'editProfile',
    LOGOUT: 'logout'
};

/** @type {Object.<string, string>} */
var OPTION_EVENT_MAP = (function () {
    var map = {};
    map[OPTIONS.ADMIN] = UserEvents.ADMIN;
    map[OPTIONS.EDIT_PROFILE] = UserEvents.EDIT_PROFILE;
    map[OPTIONS.LOGOUT] = UserEvents.LOGOUT;
    return map;
})();

/** @enum {string} */
var CLASSES = {
    USER: 'lf-user'
};

/** @override */
UserMenu.prototype.elClass = [
    BaseMenu.CLASSES.MENU,
    CLASSES.USER
].join(' ');

/** @override */
UserMenu.prototype.getLinkConfig = function () {
    var user = auth.get('livefyre');
    var KEYS = textEnumeration.KEYS;
    var cfg = [
        {
            key: OPTIONS.EDIT_PROFILE,
            str: textEnumeration.get(KEYS.MENU_USER_EDIT_PROFILE)
        }, {
            key: OPTIONS.LOGOUT,
            str: textEnumeration.get(KEYS.MENU_USER_LOGOUT)
        }
    ];

    // Only add the admin link if the user is a moderator.
    if (user && user.isMod({collectionId: this.opts.collection.id})) {
        cfg.splice(1, 0, {
            key: OPTIONS.ADMIN,
            str: textEnumeration.get(KEYS.MENU_USER_ADMIN)
        });
    }
    return cfg;
};

/** @override */
UserMenu.prototype.getTemplateContext = function () {
    var data = BaseMenu.prototype.getTemplateContext.call(this);
    var KEYS = textEnumeration.KEYS;
    var user = auth.get('livefyre');
    data.strings.backBtn = textEnumeration.get(KEYS.MENU_USER_BACK_BTN);
    data.strings.title = userMenuTemplate({
        avatar: user ? adaptAvatar(user.get('avatar')) : '',
        displayName: user ? user.get('displayName') : ''
    });
    return data;
};

/** @override */
UserMenu.prototype.handleOptionClick = function (ev) {
    ev.stopPropagation();
    var selected = $(ev.target).attr('data-value');
    this.$el.trigger(OPTION_EVENT_MAP[selected]);
    this.$el.trigger(ThreadEvents.NAVIGATE_BACK);
};

module.exports = UserMenu;

});

define('annotations/thread/controller',['require','exports','module','jquery','annotations/thread/ui/menu/auth','annotations/controller/base','annotations/events','annotations/models/comment','annotations/events','annotations/thread/ui/menu/confirm','annotations/ui/container','streamhub-sdk/debug','annotations/thread/ui/menu/edit','annotations/thread/ui/menu/etc','annotations/thread/ui/menu/flag','annotations/thread/ui/menu/info','inherits','annotations/thread/ui/thread/notification','annotations/util/object','annotations/thread/ui/permalinkthreadcontainer','annotations/util/permalink','scriptloader','annotations/thread/ui/menu/share','annotations/events','annotations/util/storage','annotations/events','annotations/thread/ui/threadpopover','annotations/thread/ui/thread/view','annotations/util/useragent','annotations/events','annotations/thread/ui/menu/user','annotations/enums','annotations/events'],function (require, exports, module) {/**
 * @fileOverview Thread controller.
 */

var $ = require('jquery');
var AuthMenu = require('annotations/thread/ui/menu/auth');
var BaseController = require('annotations/controller/base');
var BlockEvents = require('annotations/events').block;
var Comment = require('annotations/models/comment');
var CommentEvents = require('annotations/events').comment;
var ConfirmMenu = require('annotations/thread/ui/menu/confirm');
var Container = require('annotations/ui/container');
var debug = require('streamhub-sdk/debug');
var EditMenu = require('annotations/thread/ui/menu/edit');
var EtcMenu = require('annotations/thread/ui/menu/etc');
var FlagMenu = require('annotations/thread/ui/menu/flag');
var InfoMenu = require('annotations/thread/ui/menu/info');
var inherits = require('inherits');
var NotificationView = require('annotations/thread/ui/thread/notification');
var objectUtil = require('annotations/util/object');
var PermalinkThreadContainer = require('annotations/thread/ui/permalinkthreadcontainer');
var permalinkUtil = require('annotations/util/permalink');
var ScriptLoader = require('scriptloader');
var ShareMenu = require('annotations/thread/ui/menu/share');
var SourceEvents = require('annotations/events').source;
var Storage = require('annotations/util/storage');
var ThreadEvents = require('annotations/events').thread;
var ThreadPopover = require('annotations/thread/ui/threadpopover');
var ThreadView = require('annotations/thread/ui/thread/view');
var userAgentUtil = require('annotations/util/useragent');
var UserEvents = require('annotations/events').user;
var UserMenu = require('annotations/thread/ui/menu/user');
var viewEnum = require('annotations/enums').navigableViews;
var WriteEvents = require('annotations/events').write;

var log = debug('annotations');

/**
 * Thread controller.
 * @extends {BaseController}
 * @param {Object} opts Config options.
 */
function ThreadController(opts) {
    BaseController.call(this, opts);

    // Load the thread CSS.
    this._loadCSS();

    /**
     * The active view.
     * @type {?ThreadView|BaseMenu}
     * @private
     */
    this._activeView = null;

    /**
     * Container component. This will be a container or a popover depending on
     * whether the custom container option was specified.
     * @type {Container|ThreadPopover}
     * @private
     */
    this._container = this.createContainer(opts.config);
    this.bindListeners(this._container.$el);

    /**
     * Scroll top position of the thread view. This gets updated when navigation
     * is triggered and the current active view is the ThreadView.
     * @type {number}
     * @private
     */
    this._scrollTop = 0;

    /**
     * Thread view component.
     * @type {?ThreadView}
     * @private
     */
    this._threadView = null;

    /**
     * History of views that the user has visited. Keeping track of this is
     * necessary so that we can go back in time when they click back.
     * @type {Array.<View>}
     * @private
     */
    this._viewHistory = [];
    this._initPermalink();
}
inherits(ThreadController, BaseController);

/**
 * Valid events that we will show a notification to users.
 * @type {Array.<string>}
 */
var VALID_NOTIFICATION_EVENTS = (function() {
    var events = {};
    events[WriteEvents.POST_APPROVE] = true;
    events[WriteEvents.POST_DELETE] = true;
    events[WriteEvents.POST_FLAG] = true;
    events[WriteEvents.POST_HIDE] = true;
    return events;
})();

/**
 * Events to listen on the container for.
 * @enum {string}
 */
ThreadController.prototype.containerEvents = (function() {
    return $.map([
        CommentEvents,
        SourceEvents,
        ThreadEvents,
        UserEvents,
        WriteEvents],
    function(Event) {
        return objectUtil.getValues(Event);
    });
})();

/** @enum {string} */
ThreadController.prototype.events = (function() {
    var events = {};
    events[CommentEvents.ACTION_SUCCESS] = '_handleCommentActionSuccess';
    events[ThreadEvents.ACTIVATE_THREAD] = '_activateThread';
    events[ThreadEvents.CHANGE_VIEW] = '_handleViewChange';
    events[ThreadEvents.DESTROY_THREAD] = '_destroyThread';
    events[ThreadEvents.NAVIGATE] = '_handleNavigate';
    events[ThreadEvents.NAVIGATE_BACK] = '_handleNavigateBack';
    events[ThreadEvents.NAVIGATE_TO_THREAD] = '_handleNavigateToThread';
    events[ThreadEvents.PERMALINK_BACK] = '_handlePermalinkBack';
    events[WriteEvents.POST_APPROVE] = '_handleNavigateToThread';
    events[WriteEvents.POST_DELETE] = '_handleNavigateToThread';
    events[WriteEvents.POST_FLAG] = '_handleNavigateToThread';
    events[WriteEvents.POST_HIDE] = '_handleNavigateToThread';
    return events;
})();

/** @enum {string} */
ThreadController.prototype.globalEvents = (function() {
    var events = {};
    events[SourceEvents.THREAD_BTN_CLICK] = '_handleGlobalThreadBtnClick';
    return events;
})();

/** @type {string} */
ThreadController.prototype.threadCSS = '/css/thread.css';

/** @enum {string} */
ThreadController.prototype.VIEW_MAP = (function() {
    var map = {};
    map[viewEnum.AUTH] = AuthMenu;
    map[viewEnum.CONFIRM] = ConfirmMenu;
    map[viewEnum.EDIT] = EditMenu;
    map[viewEnum.ETC] = EtcMenu;
    map[viewEnum.FLAG] = FlagMenu;
    map[viewEnum.INFO] = InfoMenu;
    map[viewEnum.SHARE] = ShareMenu;
    map[viewEnum.THREAD] = ThreadView;
    map[viewEnum.USER] = UserMenu;
    return map;
})();

/**
 * Activate a thread. This loads a modal for the thread to live in and adds it.
 * @param {Event} ev
 * @param {Object=} opts=
 * @private
 */
ThreadController.prototype._activateThread = function (ev, opts) {
    if (!this._getActiveBlock()) {
        return;
    }
    if (this._container.isShowing()) {
        return;
    }

    this._destroyThread();
    this._container.onHide($.proxy(function() {
        this._initThread();
        this._loadThreadContent({
            forceEmpty: !!(opts || {}).forceWriteCard
        });
    }, this));
};

/**
 * Set the scroll position back to it's original form on the ThreadView.
 * @private
 */
ThreadController.prototype._applyScrollPosition = function () {
    this._activeView.getThreadContainer().$el.scrollTop(this._scrollTop);
    this._scrollTop = 0;
};

/**
 * Destroy the thread view and hide the popover.
 * @param {jQuery.Event} ev
 * @private
 */
ThreadController.prototype._destroyThread = function (ev) {
    var callback = $.proxy(function() {
        this._threadView && this._threadView.destroy();
        this._threadView = null;
        this._activeView && this._activeView.destroy();
        this._activeView = null;
        $.each(this._viewHistory, function(i, view) {
            view.destroy();
        });
        this._viewHistory = [];
    }, this);
    if (this._container.isVisible()) {
        this._container.hide(callback);
        return;
    }
    callback();
};

/**
 * Fetch thread data.
 * @private
 */
ThreadController.prototype._fetchThread = function () {
    var block = this._getActiveBlock();
    var callback = $.proxy(this._handleThreadFetched, this, block);
    this._collection.fetchThread(block.id, callback);
};

/**
 * Handle the comment action success event. This should show a message to the
 * user in the current popover.
 * @param {Event} ev
 * @param {Object} data
 * @private
 */
ThreadController.prototype._handleCommentActionSuccess = function (ev, data) {
    var eventName = data.event.type + '.' + data.event.namespace;
    if (!VALID_NOTIFICATION_EVENTS[eventName] || !this._activeView) {
        return;
    }

    var notification = this.createNotification({event: eventName});
    notification.decorate(this._activeView.$el);
};

/**
 * Handle new comments
 * @param {Array.<Comment>} comments
 * @private
 */
ThreadController.prototype._handleCommentBatch = function (comments) {
    var streamView = this._threadView.getThreadContainer();
    var prepend;

    $.each(comments, function(i, comment) {
        comment.origin = comment.origin || Comment.ORIGIN.STREAM;
        // Comments should only be prepended if they're from the current user
        // and if they are top level comments.
        prepend = comment.isUserAuthor() && !comment.parentId;
        streamView.addComment(comment, prepend);
    });
};

/**
 * Handle the global thread button click event. Only destroy the thread if it
 * was triggered from a different app instance.
 * @private
 */
ThreadController.prototype._handleGlobalThreadBtnClick =
    BaseController.onlyHandleExternalMessage(ThreadController.prototype._destroyThread);

/**
 * Handle the navigate event. This moves the user forward, adding the view to
 * the history array.
 * @param {jQuery.Event} ev The event that got us here.
 * @param {Object} opts The event data.
 * @private
 */
ThreadController.prototype._handleNavigate = function (ev, opts) {
    var ViewFn = this.VIEW_MAP[opts.value];
    if (!ViewFn) {
        return;
    }

    if (this._activeView) {
        if (this._activeView instanceof ThreadView) {
            // Save the scroll top position of the thread view to be used
            // when the thread view is navigated back to.
            this._scrollTop = this._activeView.getThreadContainer().$el.scrollTop();
        }
        this._activeView.detach();
        this._viewHistory.push(this._activeView);
    }

    opts.collection = this._collection;
    this._activeView = new ViewFn(opts);
    this._activeView.render();
    this._container.setContentNode(this._activeView.$el);
    this._initializeView(this._activeView);
};

/**
 * Handle the navigate back event. This should go to the previous view.
 * @private
 */
ThreadController.prototype._handleNavigateBack = function () {
    this._activeView.destroy();
    this._activeView = this._viewHistory.pop();
    this._activeView && this._container.setContentNode(this._activeView.$el);

    if (!(this._activeView instanceof ThreadView)) {
        return;
    }
    // Scroll back to the position that was saved earlier.
    this._applyScrollPosition();
};

/**
 * Handle the navigate to thread event. This will go back to the thread view
 * and clear out the history.
 * @private
 */
ThreadController.prototype._handleNavigateToThread = function () {
    $.each(this._viewHistory, $.proxy(function(i, view) {
        if (view instanceof this._threadView.constructor) {
            return;
        }
        view.destroy();
    }, this));
    this._activeView = this._threadView;
    this._container.setContentNode(this._activeView.$el);
    this._initializeView(this._activeView);
    this._viewHistory = [];

    // Only in desktop-land
    if (!(this._activeView instanceof ThreadView)) {
        return;
    }
    this._applyScrollPosition();
};



/**
 * Handle a potential permalink in the URL. If one doesn't exist, do nothing.
 * If it does, however, do some wicked shit.
 * @private
 */
ThreadController.prototype._handlePermalink = function (contentId) {
    if (!contentId) return;

    var self = this;
    this._collection.getThread({contentId: contentId}, function (err, blockId, comments) {
        var block = Storage.get(blockId);
        self._collection.block = block;
        self.$antenna.trigger(ThreadEvents.ACTIVATE_BLOCK, {block: block});

        permalinkUtil.scrollToPermalink(block.el, function () {
            self._activeView = self._threadView = self.createPermalinkThreadContainer();
            self._loadPopover(self._activeView);
            self._activeView.initialize(comments);
        });
    });
};

/**
* Sets up postMessage listener on window and sends a registration
* message to the permalink-hub running inside of Livefyre.js. On
* message from the hub it will perform its default permalink
* behavior.
* @private
*/
ThreadController.prototype._initPermalink = function() {
    //If we ever need more than one annotations app on the
    //same page we can change this.
    var name = 'annotations';
    var msgEvent = window.addEventListener ? 'message' : 'onmessage';
    var addEvent = window.addEventListener || window.attachEvent;

    var onPostMessage = function(event) {
        var msg = null;

        if (typeof event.data === 'object') {
            msg = event.data;
        } else {
            try {
                msg = JSON.parse(event.data);
            } catch(e) {
                return;
            }
        }

        if (msg.to !== name || !msg.data || msg.action !== 'put') {
            return;
        }

        this._handlePermalink(msg.data.contentId);
    };

    var sendRegistration = function(collectionId) {
        var msg = {
            from: name,
            to: 'permalink',
            action: 'post',
            data: {
                name: name,
                collectionId: collectionId
            }
        };
        window.postMessage(JSON.stringify(msg),'*');
    };

    var self = this;
    addEvent(msgEvent, function(event) {
        onPostMessage.call(self, event);
    }, false);
    sendRegistration(this._collection.id);
};

/**
 * Handle the permalink back event. This should show the thread view of the same
 * block that the permalink was in.
 * @private
 */
ThreadController.prototype._handlePermalinkBack = function () {
    this._activeView.destroy();
    this._initThread();
    this._loadThreadContent();
};

/**
 * Handle thread data
 * @param {Block} block
 * @param {?Error} err
 * @private
 */
ThreadController.prototype._handleThreadFetched = function (block, err) {
    if (this._getActiveBlock().getId() !== block.id) {
        // the user may have changed threads impatiently
        return;
    }
    if (err) {
        this._threadView.handleFetchThreadFailure(err);
        return;
    }
    // Reaching into storage to get all of the comments so that streamed
    // comments are included in case they are not in bootstrap yet.
    var comments = Storage.getCommentsForBlock(block.id);
    // Update the number of annotations on the block. This will update the
    // count on the thread button.
    this.$antenna.trigger(BlockEvents.UPDATE_COUNT, {
        blockId: block.id,
        count: Storage.getNumCommentsForBlock(block.id)
    });
    this._threadView.handleFetchThreadSuccess(comments);
};

/**
 * Handle the view change event. This should load a new view and handle the
 * this display of the view. This is the start point for the navigation history.
 * @param {jQuery.Event} ev The event that got us here.
 * @param {Object} data The event data.
 * @private
 */
ThreadController.prototype._handleViewChange = function (ev, opts) {
    this._viewHistory = [];
    this._handleNavigate(ev, opts);
};

/**
 * Initialize the view if it is supported.
 * @param {ThreadView|BaseMenu} view
 * @private
 */
ThreadController.prototype._initializeView = function (view) {
    (typeof view.initialize === 'function') && view.initialize();
};

/**
 * Initialize a new block. Remove the old one and add the new one to the
 * popover.
 * @private
 */
ThreadController.prototype._initThread = function () {
    this._threadView = this._activeView = this.createThreadView();
    this._loadPopover(this._threadView);
};

/**
 * Load the CSS.
 * @private
 */
ThreadController.prototype._loadCSS = function () {
    // TODO, run time deps for threadpopover + threadview
    ScriptLoader.loadCSS(this._config.servers.assets + this.threadCSS);

    // IE8 gets special
    if (userAgentUtil.isIE() && userAgentUtil.getIEVersion() === 8) {
        ScriptLoader.loadCSS(this._config.servers.assets + '/css/ie8.css');
    }
};

/**
 * Load a view into the popover. Render the view, add it's element to the
 * popover and show the popover.
 * @param {ThreadContainer} view
 * @private
 */
ThreadController.prototype._loadPopover = function (view) {
    this._container.show(this._getActiveBlock().el);
    view.render();
    this._container.setContentNode(view.$el);
};

/**
 * Get the content for a thread. This checks a few different places for the data
 * or fetches it if it doesn't exist in the app yet.
 * @param {Object=} opts
 * @param {boolean=} opts.forceEmpty
 * @private
 */
ThreadController.prototype._loadThreadContent = function (opts) {
    var block = this._getActiveBlock();

    if ((opts || {}).forceEmpty) {
        this._threadView.handleFetchThreadSuccess();
        return;
    }

    if (block.getFetchedState()) {
        var comments = Storage.getCommentsForBlock(block.id);
        this._threadView.handleFetchThreadSuccess(comments);
        return;
    }
    this._fetchThread();
};

/**
 * Maybe count the comment. This is determined by whether the comment's event
 * is newer than what was in init and whether it's been counted already.
 * @param {Comment} comment The comment to possibly count.
 * @param {Block} block The block to update the count on.
 * @private
 */
ThreadController.prototype._maybeCountComment = function (comment, block) {
    if (this._collection.maxEventId >= comment.meta.event) {
        return;
    }
    // Update the number of annotations on the block. This will update the
    // count on the thread button.
    this.$antenna.trigger(BlockEvents.UPDATE_COUNT, {
        blockId: block.id,
        inc: comment.calculateCountIncrement()
    });
};

/** @return {Container|ThreadPopover} */
ThreadController.prototype.createContainer = function (opts) {
    if (this._config.threadContainerEl) {
        opts.parentEl = this._config.threadContainerEl;
        return new Container(opts);
    }
    return new ThreadPopover(opts);
};

/** @return {NotificationView} */
ThreadController.prototype.createNotification = function (opts) {
    return new NotificationView(opts);
};

/** @return {ThreadContainer} */
ThreadController.prototype.createPermalinkThreadContainer = function () {
    return new PermalinkThreadContainer();
};

/** @return {ThreadView} */
ThreadController.prototype.createThreadView = function () {
    return new ThreadView({
        assetServer: this._config.servers.assets,
        blockId: this._getActiveBlock().id,
        defaultAvatar: this._config.defaultAvatar,
        isCustomNetwork: this._collection.isCustomNetwork()
    });
};

/** @override */
ThreadController.prototype.destroy = function () {
    BaseController.prototype.destroy.call(this);
    this._destroyThread();
    this._container.destroy();
    this._collection = null;
    this._config = null;
};

/**
 * Handle new data from stream (or erefs)
 */
ThreadController.prototype.handleReadable = function () {
    var activeBlock = this._getActiveBlock();
    var block;
    var comment;
    var comments = [];
    var stored;

    // If there isn't an active block or a thread view, we shouldn't process
    // streamed content for this block. The thread view won't exist if the user
    // has not opened it yet or if there is a permalink open, in which case they
    // haven't opened it anyway. In the permalink case, there will be an active
    // block but the thread view won't exist yet.
    var shouldProcess = activeBlock && this._threadView;

    while (comment = this._collection.read()) {
        // Grab the comment out of storage if we have it so that we can attempt
        // to get the blockId. If this comment is deleted, it won't have a
        // blockId, so we need to get it somehow. No matter what the state, it
        // will always be here since it will have been added prior to getting
        // here via stream.
        stored = Storage.get(comment.id);
        // We need to fetch the block model for the comment. Since replies don't
        // have blockId attributes, we will need to find it on the parent
        // comment in Storage. If this is a reply that doesn't have a parent in
        // Storage yet, the block can be null.
        block = Storage.get(comment.blockId || stored.blockId);
        if (!block) {
            log('We can\'t seem to find the block for comment: ' + comment.id);
            continue;
        }
        this._maybeCountComment(comment, block);

        if (!shouldProcess) {
            continue;
        }

        // Add comment to the batched comments list that we will deal with soon...
        if (block.id === activeBlock.id) {
            comments.push(comment);
        }
    }

    shouldProcess && this._handleCommentBatch(comments);
};

module.exports = ThreadController;

});

define('annotations/mobile/thread/controller',['require','exports','module','jquery','inherits','annotations/mobile/thread/ui/editorview','annotations/mobile/thread/ui/thread/notification','annotations/mobile/thread/ui/threadpopover','annotations/mobile/thread/ui/thread/view','annotations/mobile/thread/ui/menu/question','annotations/mobile/thread/ui/stream/repliesthreadcontainer','annotations/thread/controller','annotations/events','annotations/enums','annotations/events','xrange/xrange'],function (require, exports, module) {/**
 * @fileOverview Mobile thread controller.
 */

var $ = require('jquery');
var inherits = require('inherits');
var MobileEditorView = require('annotations/mobile/thread/ui/editorview');
var MobileNotificationView = require('annotations/mobile/thread/ui/thread/notification');
var MobileThreadPopover = require('annotations/mobile/thread/ui/threadpopover');
var MobileThreadView = require('annotations/mobile/thread/ui/thread/view');
var MobileQuestionMenu = require('annotations/mobile/thread/ui/menu/question');
var RepliesThreadContainer =
        require('annotations/mobile/thread/ui/stream/repliesthreadcontainer');
var ThreadController = require('annotations/thread/controller');
var ThreadEvents = require('annotations/events').thread;
var viewEnum = require('annotations/enums').navigableViews;
var WriteEvents = require('annotations/events').write;
var XRange = require('xrange/xrange');

/**
 * Mobile thread controller.
 * @constructor
 * @extends {ThreadController}
 * @param {Object} opts Config options.
 */
function MobileThreadController (opts) {
    ThreadController.call(this, opts);

    /**
     * The selected text, cleared and then readded so that the mobile tooltip doesn't show up
     * from behind the fullscreen popover.
     * @type {XRange}
     * @private
     */
    this._range;
}
inherits(MobileThreadController, ThreadController);

/**
 * Height of the header.
 * @const {number}
 */
var HEADER_HEIGHT = 56;

/** @enum {string} */
MobileThreadController.prototype.events = (function() {
    var events = {};
    events[ThreadEvents.TUCK_THREAD] = '_handleTuckThread';
    events[ThreadEvents.UNTUCK_THREAD] = '_handleUntuckThread';
    return events;
})();
$.extend(MobileThreadController.prototype.events, ThreadController.prototype.events);

/** @type {string} */
MobileThreadController.prototype.threadCSS = '/css/mobile-thread.css';

/** @override */
MobileThreadController.prototype.VIEW_MAP = (function () {
    var map = {};
    $.extend(map, ThreadController.prototype.VIEW_MAP);
    map[viewEnum.EDIT] = MobileEditorView;
    map[viewEnum.EDITOR] = MobileEditorView;
    map[viewEnum.QUESTION] = MobileQuestionMenu;
    map[viewEnum.REPLIES] = RepliesThreadContainer;
    return map;
}());

/** @override */
MobileThreadController.prototype._applyScrollPosition = function () {
    window.scrollTo(0, this._scrollTop);
    this._scrollTop = 0;

    this._range && this._range.addToSelection();
    this._range = null;
};

/** @override */
MobileThreadController.prototype._handleCommentActionSuccess = function (ev, data) {
    var event = [data.event.type, data.event.namespace].join('.');
    if (event === WriteEvents.POST_DELETE ||
        event === WriteEvents.POST_HIDE) {
        this.$antenna.trigger(ThreadEvents.DESTROY_THREAD);
    }
    ThreadController.prototype._handleCommentActionSuccess.call(this, ev, data);
};

/** @override */
MobileThreadController.prototype._handleNavigate = function (ev, opts) {
    if (this._activeView && this._activeView instanceof MobileThreadView) {
        // Save the scroll position of the viewport.
        this._scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    }
    ThreadController.prototype._handleNavigate.call(this, ev, opts);

    this._range = new XRange();
    this._range.clearNativeSelection();
    this._container.setFullScreen();
};

/** @override */
MobileThreadController.prototype._handleNavigateBack = function (ev, opts) {
    ThreadController.prototype._handleNavigateBack.call(this, ev, opts);
    if (this._viewHistory.length !== 0) {
        return;
    }
    this._container.unsetFullScreen && this._container.unsetFullScreen();

    if (!(this._activeView instanceof MobileThreadView)) {
        return;
    }
    this._applyScrollPosition();
};

/** @override */
MobileThreadController.prototype._handleNavigateToThread = function () {
    ThreadController.prototype._handleNavigateToThread.call(this);
    this._container.unsetFullScreen();

    if (!(this._activeView instanceof MobileThreadView)) {
        return;
    }
    this._applyScrollPosition();
};

/** @override */
MobileThreadController.prototype._handlePermalinkBack = function () {
    this._container.unsetFullScreen();
    this._viewHistory = [];
    ThreadController.prototype._handlePermalinkBack.call(this);
};

/**
 * Handle a scrolling tuck.
 * @private
 */
MobileThreadController.prototype._handleTuckThread = function () {
    if (!(this._activeView instanceof MobileThreadView)) {
        return;
    }
    var offset = this._container.$el.outerHeight() - HEADER_HEIGHT;  // - the header height
    var px = offset + 'px';
    if (offset !== 0) {
        px = '-' + px;
    }
    this._container.$el.css('bottom', px);
};

/**
 * Handle an end scrolling untuck.
 * @private
 */
MobileThreadController.prototype._handleUntuckThread = function () {
    this._container.$el.css('bottom', '');
};

/** @override */
MobileThreadController.prototype.createContainer = function (opts) {
    return new MobileThreadPopover(opts);
};

/** @return {NotificationView} */
MobileThreadController.prototype.createNotification = function (opts) {
    return new MobileNotificationView(opts);
};

/** @override */
MobileThreadController.prototype.createPermalinkThreadContainer = function () {
    var repliesThreadContainer = new RepliesThreadContainer({ permalinkView: true });
    this._container.setFullScreen();
    this._viewHistory.push(repliesThreadContainer);
    return repliesThreadContainer;
};

/** @override */
MobileThreadController.prototype.createThreadView = function () {
    return new MobileThreadView({
        blockId : this._getActiveBlock().id
    });
};

module.exports = MobileThreadController;

});

define('annotations/mobile/jquery-mobile-events',['require','exports','module','jquery'],function (require, exports, module) {(function(e){function d(){var e=o();if(e!==u){u=e;i.trigger("orientationchange")}}function E(t,n,r,i){var s=r.type;r.type=n;e.event.dispatch.call(t,r,i);r.type=s}e.attrFn=e.attrFn||{};var t=navigator.userAgent.toLowerCase(),n=t.indexOf("chrome")>-1&&(t.indexOf("windows")>-1||t.indexOf("macintosh")>-1||t.indexOf("linux")>-1)&&t.indexOf("mobile")<0,r={tap_pixel_range:5,swipe_h_threshold:50,swipe_v_threshold:50,taphold_threshold:750,doubletap_int:500,touch_capable:"ontouchstart"in document.documentElement&&!n,orientation_support:"orientation"in window&&"onorientationchange"in window,startevent:"ontouchstart"in document.documentElement&&!n?"touchstart":"mousedown",endevent:"ontouchstart"in document.documentElement&&!n?"touchend":"mouseup",moveevent:"ontouchstart"in document.documentElement&&!n?"touchmove":"mousemove",tapevent:"ontouchstart"in document.documentElement&&!n?"tap":"click",scrollevent:"ontouchstart"in document.documentElement&&!n?"touchmove":"scroll",hold_timer:null,tap_timer:null};e.isTouchCapable=function(){return r.touch_capable};e.getStartEvent=function(){return r.startevent};e.getEndEvent=function(){return r.endevent};e.getMoveEvent=function(){return r.moveevent};e.getTapEvent=function(){return r.tapevent};e.getScrollEvent=function(){return r.scrollevent};e.each(["tapstart","tapend","tap","singletap","doubletap","taphold","swipe","swipeup","swiperight","swipedown","swipeleft","swipeend","scrollstart","scrollend","orientationchange"],function(t,n){e.fn[n]=function(e){return e?this.on(n,e):this.trigger(n)};e.attrFn[n]=true});e.event.special.tapstart={setup:function(){var t=this,n=e(t);n.on(r.startevent,function(e){n.data("callee",arguments.callee);if(e.which&&e.which!==1){return false}var i=e.originalEvent,s={position:{x:r.touch_capable?i.touches[0].screenX:e.screenX,y:r.touch_capable?i.touches[0].screenY:e.screenY},offset:{x:r.touch_capable?i.touches[0].pageX-i.touches[0].target.offsetLeft:e.offsetX,y:r.touch_capable?i.touches[0].pageY-i.touches[0].target.offsetTop:e.offsetY},time:(new Date).getTime(),target:e.target};E(t,"tapstart",e,s);return true})},remove:function(){e(this).off(r.startevent,e(this).data.callee)}};e.event.special.tapmove={setup:function(){var t=this,n=e(t);n.on(r.moveevent,function(e){n.data("callee",arguments.callee);var i=e.originalEvent,s={position:{x:r.touch_capable?i.touches[0].screenX:e.screenX,y:r.touch_capable?i.touches[0].screenY:e.screenY},offset:{x:r.touch_capable?i.touches[0].pageX-i.touches[0].target.offsetLeft:e.offsetX,y:r.touch_capable?i.touches[0].pageY-i.touches[0].target.offsetTop:e.offsetY},time:(new Date).getTime(),target:e.target};E(t,"tapmove",e,s);return true})},remove:function(){e(this).off(r.moveevent,e(this).data.callee)}};e.event.special.tapend={setup:function(){var t=this,n=e(t);n.on(r.endevent,function(e){n.data("callee",arguments.callee);var i=e.originalEvent;var s={position:{x:r.touch_capable?i.changedTouches[0].screenX:e.screenX,y:r.touch_capable?i.changedTouches[0].screenY:e.screenY},offset:{x:r.touch_capable?i.changedTouches[0].pageX-i.changedTouches[0].target.offsetLeft:e.offsetX,y:r.touch_capable?i.changedTouches[0].pageY-i.changedTouches[0].target.offsetTop:e.offsetY},time:(new Date).getTime(),target:e.target};E(t,"tapend",e,s);return true})},remove:function(){e(this).off(r.endevent,e(this).data.callee)}};e.event.special.taphold={setup:function(){var t=this,n=e(t),i,s,o={x:0,y:0};n.on(r.startevent,function(e){if(e.which&&e.which!==1){return false}else{n.data("tapheld",false);i=e.target;var s=e.originalEvent;var u=(new Date).getTime(),a={x:r.touch_capable?s.touches[0].screenX:e.screenX,y:r.touch_capable?s.touches[0].screenY:e.screenY},f={x:r.touch_capable?s.touches[0].pageX-s.touches[0].target.offsetLeft:e.offsetX,y:r.touch_capable?s.touches[0].pageY-s.touches[0].target.offsetTop:e.offsetY};o.x=e.originalEvent.targetTouches?e.originalEvent.targetTouches[0].pageX:e.pageX;o.y=e.originalEvent.targetTouches?e.originalEvent.targetTouches[0].pageY:e.pageY;r.hold_timer=window.setTimeout(function(){var l=e.originalEvent.targetTouches?e.originalEvent.targetTouches[0].pageX:e.pageX,c=e.originalEvent.targetTouches?e.originalEvent.targetTouches[0].pageY:e.pageY;if(e.target==i&&o.x==l&&o.y==c){n.data("tapheld",true);var h=(new Date).getTime(),p={x:r.touch_capable?s.touches[0].screenX:e.screenX,y:r.touch_capable?s.touches[0].screenY:e.screenY},d={x:r.touch_capable?s.touches[0].pageX-s.touches[0].target.offsetLeft:e.offsetX,y:r.touch_capable?s.touches[0].pageY-s.touches[0].target.offsetTop:e.offsetY};duration=h-u;var v={startTime:u,endTime:h,startPosition:a,startOffset:f,endPosition:p,endOffset:d,duration:duration,target:e.target};n.data("callee1",arguments.callee);E(t,"taphold",e,v)}},r.taphold_threshold);return true}}).on(r.endevent,function(){n.data("callee2",arguments.callee);n.data("tapheld",false);window.clearTimeout(r.hold_timer)})},remove:function(){e(this).off(r.startevent,e(this).data.callee1).off(r.endevent,e(this).data.callee2)}};e.event.special.doubletap={setup:function(){var t=this,n=e(t),i,s,o,u;n.on(r.startevent,function(e){if(e.which&&e.which!==1){return false}else{n.data("doubletapped",false);i=e.target;n.data("callee1",arguments.callee);u=e.originalEvent;o={position:{x:r.touch_capable?u.touches[0].screenX:e.screenX,y:r.touch_capable?u.touches[0].screenY:e.screenY},offset:{x:r.touch_capable?u.touches[0].pageX-u.touches[0].target.offsetLeft:e.offsetX,y:r.touch_capable?u.touches[0].pageY-u.touches[0].target.offsetTop:e.offsetY},time:(new Date).getTime(),target:e.target};return true}}).on(r.endevent,function(e){var a=(new Date).getTime();var f=n.data("lastTouch")||a+1;var l=a-f;window.clearTimeout(s);n.data("callee2",arguments.callee);if(l<r.doubletap_int&&l>0&&e.target==i&&l>100){n.data("doubletapped",true);window.clearTimeout(r.tap_timer);var c={position:{x:r.touch_capable?u.touches[0].screenX:e.screenX,y:r.touch_capable?u.touches[0].screenY:e.screenY},offset:{x:r.touch_capable?u.touches[0].pageX-u.touches[0].target.offsetLeft:e.offsetX,y:r.touch_capable?u.touches[0].pageY-u.touches[0].target.offsetTop:e.offsetY},time:(new Date).getTime(),target:e.target};var h={firstTap:o,secondTap:c,interval:c.time-o.time};E(t,"doubletap",e,h)}else{n.data("lastTouch",a);s=window.setTimeout(function(e){window.clearTimeout(s)},r.doubletap_int,[e])}n.data("lastTouch",a)})},remove:function(){e(this).off(r.startevent,e(this).data.callee1).off(r.endevent,e(this).data.callee2)}};e.event.special.singletap={setup:function(){var t=this,n=e(t),i=null,s=null,o={x:0,y:0};n.on(r.startevent,function(e){if(e.which&&e.which!==1){return false}else{s=(new Date).getTime();i=e.target;n.data("callee1",arguments.callee);o.x=e.originalEvent.targetTouches?e.originalEvent.targetTouches[0].pageX:e.pageX;o.y=e.originalEvent.targetTouches?e.originalEvent.targetTouches[0].pageY:e.pageY;return true}}).on(r.endevent,function(e){n.data("callee2",arguments.callee);if(e.target==i){end_pos_x=e.originalEvent.changedTouches?e.originalEvent.changedTouches[0].pageX:e.pageX;end_pos_y=e.originalEvent.changedTouches?e.originalEvent.changedTouches[0].pageY:e.pageY;r.tap_timer=window.setTimeout(function(){if(!n.data("doubletapped")&&!n.data("tapheld")&&o.x==end_pos_x&&o.y==end_pos_y){var i=e.originalEvent;var u={position:{x:r.touch_capable?i.changedTouches[0].screenX:e.screenX,y:r.touch_capable?i.changedTouches[0].screenY:e.screenY},offset:{x:r.touch_capable?i.changedTouches[0].pageX-i.changedTouches[0].target.offsetLeft:e.offsetX,y:r.touch_capable?i.changedTouches[0].pageY-i.changedTouches[0].target.offsetTop:e.offsetY},time:(new Date).getTime(),target:e.target};if(u.time-s<r.taphold_threshold){E(t,"singletap",e,u)}}},r.doubletap_int)}})},remove:function(){e(this).off(r.startevent,e(this).data.callee1).off(r.endevent,e(this).data.callee2)}};e.event.special.tap={setup:function(){var t=this,n=e(t),i=false,s=null,o,u={x:0,y:0};n.on(r.startevent,function(e){n.data("callee1",arguments.callee);if(e.which&&e.which!==1){return false}else{i=true;u.x=e.originalEvent.targetTouches?e.originalEvent.targetTouches[0].pageX:e.pageX;u.y=e.originalEvent.targetTouches?e.originalEvent.targetTouches[0].pageY:e.pageY;o=(new Date).getTime();s=e.target;return true}}).on(r.endevent,function(e){n.data("callee2",arguments.callee);var a=e.originalEvent.targetTouches?e.originalEvent.changedTouches[0].pageX:e.pageX,f=e.originalEvent.targetTouches?e.originalEvent.changedTouches[0].pageY:e.pageY;diff_x=u.x-a,diff_y=u.y-f;if(s==e.target&&i&&(new Date).getTime()-o<r.taphold_threshold&&(u.x==a&&u.y==f||diff_x>=-r.tap_pixel_range&&diff_x<=r.tap_pixel_range&&diff_y>=-r.tap_pixel_range&&diff_y<=r.tap_pixel_range)){var l=e.originalEvent;var c={position:{x:r.touch_capable?l.changedTouches[0].screenX:e.screenX,y:r.touch_capable?l.changedTouches[0].screenY:e.screenY},offset:{x:r.touch_capable?l.changedTouches[0].pageX-l.changedTouches[0].target.offsetLeft:e.offsetX,y:r.touch_capable?l.changedTouches[0].pageY-l.changedTouches[0].target.offsetTop:e.offsetY},time:(new Date).getTime(),target:e.target};E(t,"tap",e,c)}})},remove:function(){e(this).off(r.startevent,e(this).data.callee1).off(r.endevent,e(this).data.callee2)}};e.event.special.swipe={setup:function(){function f(t){n=e(t.target);n.data("callee1",arguments.callee);o.x=t.originalEvent.targetTouches?t.originalEvent.targetTouches[0].pageX:t.pageX;o.y=t.originalEvent.targetTouches?t.originalEvent.targetTouches[0].pageY:t.pageY;u.x=o.x;u.y=o.y;i=true;var s=t.originalEvent;a={position:{x:r.touch_capable?s.touches[0].screenX:t.screenX,y:r.touch_capable?s.touches[0].screenY:t.screenY},offset:{x:r.touch_capable?s.touches[0].pageX-s.touches[0].target.offsetLeft:t.offsetX,y:r.touch_capable?s.touches[0].pageY-s.touches[0].target.offsetTop:t.offsetY},time:(new Date).getTime(),target:t.target};var f=new Date;while(new Date-f<100){}}function l(t){n=e(t.target);n.data("callee2",arguments.callee);u.x=t.originalEvent.targetTouches?t.originalEvent.targetTouches[0].pageX:t.pageX;u.y=t.originalEvent.targetTouches?t.originalEvent.targetTouches[0].pageY:t.pageY;window.clearTimeout(r.hold_timer);var f;var l=n.data("xthreshold"),c=n.data("ythreshold"),h=typeof l!=="undefined"&&l!==false&&parseInt(l)?parseInt(l):r.swipe_h_threshold,p=typeof c!=="undefined"&&c!==false&&parseInt(c)?parseInt(c):r.swipe_v_threshold;if(o.y>u.y&&o.y-u.y>p){f="swipeup"}if(o.x<u.x&&u.x-o.x>h){f="swiperight"}if(o.y<u.y&&u.y-o.y>p){f="swipedown"}if(o.x>u.x&&o.x-u.x>h){f="swipeleft"}if(f!=undefined&&i){o.x=0;o.y=0;u.x=0;u.y=0;i=false;var d=t.originalEvent;endEvnt={position:{x:r.touch_capable?d.touches[0].screenX:t.screenX,y:r.touch_capable?d.touches[0].screenY:t.screenY},offset:{x:r.touch_capable?d.touches[0].pageX-d.touches[0].target.offsetLeft:t.offsetX,y:r.touch_capable?d.touches[0].pageY-d.touches[0].target.offsetTop:t.offsetY},time:(new Date).getTime(),target:t.target};var v=Math.abs(a.position.x-endEvnt.position.x),m=Math.abs(a.position.y-endEvnt.position.y);var g={startEvnt:a,endEvnt:endEvnt,direction:f.replace("swipe",""),xAmount:v,yAmount:m,duration:endEvnt.time-a.time};s=true;n.trigger("swipe",g).trigger(f,g)}}function c(t){n=e(t.target);var o="";n.data("callee3",arguments.callee);if(s){var u=n.data("xthreshold"),f=n.data("ythreshold"),l=typeof u!=="undefined"&&u!==false&&parseInt(u)?parseInt(u):r.swipe_h_threshold,c=typeof f!=="undefined"&&f!==false&&parseInt(f)?parseInt(f):r.swipe_v_threshold;var h=t.originalEvent;endEvnt={position:{x:r.touch_capable?h.changedTouches[0].screenX:t.screenX,y:r.touch_capable?h.changedTouches[0].screenY:t.screenY},offset:{x:r.touch_capable?h.changedTouches[0].pageX-h.changedTouches[0].target.offsetLeft:t.offsetX,y:r.touch_capable?h.changedTouches[0].pageY-h.changedTouches[0].target.offsetTop:t.offsetY},time:(new Date).getTime(),target:t.target};if(a.position.y>endEvnt.position.y&&a.position.y-endEvnt.position.y>c){o="swipeup"}if(a.position.x<endEvnt.position.x&&endEvnt.position.x-a.position.x>l){o="swiperight"}if(a.position.y<endEvnt.position.y&&endEvnt.position.y-a.position.y>c){o="swipedown"}if(a.position.x>endEvnt.position.x&&a.position.x-endEvnt.position.x>l){o="swipeleft"}var p=Math.abs(a.position.x-endEvnt.position.x),d=Math.abs(a.position.y-endEvnt.position.y);var v={startEvnt:a,endEvnt:endEvnt,direction:o.replace("swipe",""),xAmount:p,yAmount:d,duration:endEvnt.time-a.time};n.trigger("swipeend",v)}i=false;s=false}var t=this,n=e(t),i=false,s=false,o={x:0,y:0},u={x:0,y:0},a;n.on(r.startevent,f);n.on(r.moveevent,l);n.on(r.endevent,c)},remove:function(){e(this).off(r.startevent,e(this).data.callee1).off(r.moveevent,e(this).data.callee2).off(r.endevent,e(this).data.callee3)}};e.event.special.scrollstart={setup:function(){function o(e,n){i=n;E(t,i?"scrollstart":"scrollend",e)}var t=this,n=e(t),i,s;n.on(r.scrollevent,function(e){n.data("callee",arguments.callee);if(!i){o(e,true)}clearTimeout(s);s=setTimeout(function(){o(e,false)},50)})},remove:function(){e(this).off(r.scrollevent,e(this).data.callee)}};var i=e(window),s,o,u,a,f,l={0:true,180:true};if(r.orientation_support){var c=window.innerWidth||e(window).width(),h=window.innerHeight||e(window).height(),p=50;a=c>h&&c-h>p;f=l[window.orientation];if(a&&f||!a&&!f){l={"-90":true,90:true}}}e.event.special.orientationchange=s={setup:function(){if(r.orientation_support){return false}u=o();i.on("throttledresize",d);return true},teardown:function(){if(r.orientation_support){return false}i.off("throttledresize",d);return true},add:function(e){var t=e.handler;e.handler=function(e){e.orientation=o();return t.apply(this,arguments)}}};e.event.special.orientationchange.orientation=o=function(){var e=true,t=document.documentElement;if(r.orientation_support){e=l[window.orientation]}else{e=t&&t.clientWidth/t.clientHeight<1.1}return e?"portrait":"landscape"};e.event.special.throttledresize={setup:function(){e(this).on("resize",m)},teardown:function(){e(this).off("resize",m)}};var v=250,m=function(){b=(new Date).getTime();w=b-g;if(w>=v){g=b;e(this).trigger("throttledresize")}else{if(y){window.clearTimeout(y)}y=window.setTimeout(d,v-w)}},g=0,y,b,w;e.each({scrollend:"scrollstart",swipeup:"swipe",swiperight:"swipe",swipedown:"swipe",swipeleft:"swipe",swipeend:"swipe"},function(t,n,r){e.event.special[t]={setup:function(){e(this).on(n,e.noop)}}})})(require('jquery'))

});

define('annotations/main',['require','exports','module','jquery','annotations/controller/analytics','annotations/clients/annotationscollection','annotations/blocks/controller','annotations/controller/comment','annotations/config','streamhub-sdk/debug','event-emitter','annotations/controller/external','annotations/events','inherits','observer','annotations/config','scriptloader','annotations/util/selector','annotations/util/useragent','annotations/user/controller','annotations/mobile/controller/body','annotations/controller/body','annotations/mobile/thread/controller','annotations/thread/controller','annotations/mobile/jquery-mobile-events'],function (require, exports, module) {var $ = require('jquery');
var AnalyticsController = require('annotations/controller/analytics');
var AnnotationsCollection = require('annotations/clients/annotationscollection');
var BlockController = require('annotations/blocks/controller');
var CommentController = require('annotations/controller/comment');
var configData = require('annotations/config').data;
var debug = require('streamhub-sdk/debug');
var EventEmitter = require('event-emitter');
var ExternalController = require('annotations/controller/external');
var ExternalEvents = require('annotations/events').external;
var inherits = require('inherits');
var Observer = require('observer');
var parseConfig = require('annotations/config').parseConfig;
var ScriptLoader = require('scriptloader');
var selectorUtil = require('annotations/util/selector');
var UserAgentUtil = require('annotations/util/useragent');
var UserController = require('annotations/user/controller');

var log = debug('annotations');

/**
 * @typedef selector {string}
 * A css selector
 */

/**
 * @typedef Collection {Object}
 * @property network {string}
 * @property siteId {string}
 * @property articleId {string}
 * @property [environment] {string}
 * @property checksum
 */

/**
 * @typedef Annotation
 * @property body {string} The comment body.
 * @property blockId {string}
 * @property index {number}
 * @property hash {string} aka simhash
 * @property fullText {string}
 * @property selectedText {string}
 * @property [shareTypes] {ShareType} TODO(jj)
 * @property fingerprint {string}
 */

/**
 * @typedef AnnotationCfg {Object}
 * @property selectors {Array.<selector>}
 * @property authDelegate {function}
 * @property collection {Collection}
 * @property collectionMeta {CollectionMeta} streamhub-sdk/src/collection/clients/create-client.js
 */

/**
 * @typedef callback {function}
 * @param {(null|err)} err
 * @param {Object} dataz
 */

/**
 * Entry point for annotations app
 * @param {AnnotationCfg} cfg
 * @constructor
 * @extends {EventEmitter}
 */
function AnnotationApp(cfg) {
    EventEmitter.call(this);

    // Iniitialize the messenger ($antenna) that will be used throughout the
    // application.
    this._initMessenger();

    /**
     * Block controller for blocky things.
     * @type {?BlockController}
     * @private
     */
    this._blockController = null;

    /**
     * Body controller for bodyy things.
     * @type {?BodyController}
     * @private
     */
    this._bodyController = null;

    /**
     * Comment controller for commenty things.
     * @type {?CommentController}
     * @private
     */
    this._commentController = null;

    /**
     * External events controller.
     * @type {?ExternalController}
     * @private
     */
    this._externalController = null;

    /**
     * Whether the stream is currently running on not.
     * @type {boolean}
     * @private
     */
    this._streamRunning = false;

    /**
     * Thread controller for thready things.
     * @type {?ThreadController}
     * @private
     */
    this._threadController = null;

    /**
     * User controller for usery things.
     * @type {?UserController}
     * @private
     */
    this._userController = null;

    /**
     * Config object.
     * @type {?Object}
     * @private
     */
    this._config = null;

    Observer(this);
    this._config = parseConfig(cfg);

    this._initCollection();
}
inherits(AnnotationApp, EventEmitter);

/**
 * The messenger version.
 * @type {number}
 */
var messengerId = 0;

/**
 * Fetch a body controller instance.
 * @param {Object} opts Config options.
 * @return {BodyController}
 */
function createBodyController(opts) {
    var BodyController;
    if (UserAgentUtil.isMobile()) {
        BodyController = require('annotations/mobile/controller/body');
    } else {
        BodyController = require('annotations/controller/body');
    }
    return new BodyController(opts);
}

/**
 * Fetch a thread controller instance.
 * @param {Object} opts Config options.
 * @return {ThreadController}
 */
function createThreadController(opts) {
    var ThreadController;
    if (UserAgentUtil.isMobile()) {
        ThreadController = require('annotations/mobile/thread/controller');
    } else {
        ThreadController =  require('annotations/thread/controller');
    }
    return new ThreadController(opts);
}

/**
 * Gets the options used to initialize the controllers.
 * @return {Object}
 * @private
 */
AnnotationApp.prototype._getControllerOptions = function () {
    return {
        app: this,
        antenna: this.$antenna,
        collection: this._collection,
        config: this._config
    };
};

/**
 * Gets a new messenger object.
 * return {jQuery}
 * @private
 */
AnnotationApp.prototype._initMessenger = function () {
    messengerId++;
    this.$antenna = $('<div id="fyre-messenger-'+ messengerId +'"></div>');
    $('body').append(this.$antenna);
};

/**
 * Handle the collection initialization success.
 * @param {Object} err Error object.
 * @param {Object} data Collection data.
 * @private
 */
AnnotationApp.prototype._handleInitComplete = function (err, data) {
    if (err) {
        log(err);
        return;
    }
    if (UserAgentUtil.isMobile()) {
        ScriptLoader.loadCSS(this._config.servers.assets + '/css/mobile-block.css');
        // Extends the jQueries
        require('annotations/mobile/jquery-mobile-events');
    } else {
        ScriptLoader.loadCSS(this._config.servers.assets + '/css/block.css');
    }
    this._loadControllers();
    this._blockController.initialize(data);
    this.updateAnchors();
    this._initStream();
    this.emit(ExternalEvents.INITIALIZED);
};

/**
 * Entry point for fetching initial annotations data via its collection.
 * @private
 */
AnnotationApp.prototype._initCollection = function () {
    this._collection = new AnnotationsCollection({
        network: this._config.collection.network,
        siteId: this._config.collection.siteId,
        articleId: this._config.collection.articleId,
        environment: this._config.collection.environment,
        collectionMeta: this._config.collectionMeta,
        signed: (typeof this._config.collectionMeta === 'string')
    });
    this._collection.initFromBootstrap($.proxy(this._handleInitComplete, this));
};

/**
 * Begin listening to stream as long as it's not disabled.
 * @private
 */
AnnotationApp.prototype._initStream = function () {
    this.startStream();
};

/**
 * Load all controllers that the app needs.
 * @private
 */
AnnotationApp.prototype._loadControllers = function () {
    var opts = this._getControllerOptions();
    // this._analyticsController = new AnalyticsController(opts);
    this._blockController = new BlockController(opts);
    this._bodyController = createBodyController(opts);
    this._commentController = new CommentController(opts);
    this._externalController = new ExternalController(opts);
    this._threadController = createThreadController(opts);
    this._userController = new UserController(opts);
};

/**
 * Clean up any dom references and listeners for removal from page.
 */
AnnotationApp.prototype.destroy = function () {
    this.stopStream();
    this._collection && this._collection.destroy();
    this._collection = null;
    this._config = null;
    // this._analyticsController && this._analyticsController.destroy();
    // this._analyticsController = null;
    this._blockController && this._blockController.destroy();
    this._blockController = null;
    this._bodyController && this._bodyController.destroy();
    this._bodyController = null;
    this._commentController && this._commentController.destroy();
    this._commentController = null;
    this._externalController && this._externalController.destroy();
    this._externalController = null;
    this._threadController && this._threadController.destroy();
    this._threadController = null;
    this._userController && this._userController.destroy();
    this._userController = null;
    this.$antenna.remove();
};

/**
 * Start the stream if it's not running already.
 */
AnnotationApp.prototype.startStream = function () {
    if (this._streamRunning) {
        return;
    }
    this._streamRunning = true;
    var cb = $.proxy(this._threadController.handleReadable, this._threadController);
    this.listenTo(this._collection, 'readable', cb);
    /**
     * Listening to readable triggers stream, and we want readables events from cbs,
     * but not from stream.
     */
    this._config.disableStream && this._collection.pause();
};

/**
 * Stop the stream.
 */
AnnotationApp.prototype.stopStream = function () {
    if (!this._streamRunning) {
        return;
    }
    this._streamRunning = false;
    this.stopListening();
};

/**
 * Update the blocks that are on the page by adding some new ones. If the
 * optional argument is provided, it will add those elements as blocks. If no
 * argument is passed, it will use the selectors that were provided in the
 * beginning and find all new matching elements.
 * @param {Array.<Element>|Object|string=} opt_newSelectors Optional new set of
 *   selectors for the new set of block elements.
 */
AnnotationApp.prototype.updateAnchors = function (opt_newSelectors) {
    if (!this._blockController) {
        throw 'Sidenotes app has not initialized yet, please wait...';
    }
    var selectors = opt_newSelectors || this._config.selectorString;
    selectors = selectorUtil.parseSelectors(selectors);
    // Remove all selectors that already have been block-ified...
    selectors = selectors.not(':has(.lf-thread-btn)').not(':has(.lf-mobile-thread-btn)');
    this._blockController.initializeBlocks(selectors);
};

module.exports = AnnotationApp;

});

define('annotations', ['annotations/main'], function (main) { return main; });
    //The modules for your project will be inlined above
    //this snippet. Ask almond to synchronously require the
    //module value for 'main' here and return it as the
    //value to use for the public API for the built file.
    return require('annotations');
}));

//# sourceMappingURL=sidenotes.min.js.map